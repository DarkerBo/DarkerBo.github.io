<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>Bowen_blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Bowen">
<meta name="keywords" content="前端,Html,css,JavaScript,Vue">
<meta property="og:type" content="website">
<meta property="og:title" content="Bowen_blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Bowen_blog">
<meta property="og:description" content="Bowen">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bowen_blog">
<meta name="twitter:description" content="Bowen">
  
    <link rel="alternative" href="/atom.xml" title="Bowen_blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.0cf68a.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

</head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/img/header.jpg" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">Bowen</a></h1>
		</hgroup>
		
		<p class="header-subtitle">欢迎来到我的博客~</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/" title="github"><i class="icon-github"></i></a>
		        
					<a class="mail" target="_blank" href="/948266921@qq.com" title="mail"><i class="icon-mail"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/img/header.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">Bowen</h1>
			</hgroup>
			
			<p class="header-subtitle"><i class="icon icon-quo-left"></i>欢迎来到我的博客~<i class="icon icon-quo-right"></i></p>
			
			
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/" title="github"><i class="icon-github"></i></a>
			        
						<a class="mail" target="_blank" href="/948266921@qq.com" title="mail"><i class="icon-mail"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 50%">
				
				
					<li style="width: 100%"><a href="/">主页</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-JavaScript Async" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/12/JavaScript Async/">JavaScript Async</a>
    </h1>
  

        
        <a href="/2018/08/12/JavaScript Async/" class="archive-article-date">
  	<time datetime="2018-08-11T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-08-12</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JavaScript-Async"><a href="#JavaScript-Async" class="headerlink" title="JavaScript Async"></a>JavaScript Async</h2><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>所谓同步编程，就是计算机一行一行按顺序依次执行代码，当前代码任务耗时执行会阻塞后续代码的执行</p>
<blockquote>
<p>同步编程，即是一种典型的请求-响应模型，当请求调用一个函数或方法后，需等待其响应返回，然后执行后续代码</p>
</blockquote>
<p>一般情况下，同步编程，代码按序依次执行，能很好的保证程序的执行，但是在某些场景下，比如读取文件内容，或请求服务器接口数据，需要根据返回的数据内容执行后续操作，读取文件和请求接口直到数据返回这一过程是需要时间的，网络越差，耗费时间越长，如果按照同步编程方式实现，在等待数据返回这段时间，JavaScript是不能处理其他任务的，此时页面的交互，滚动等任何操作也都会被阻塞，这显然是及其不友好，不可接受的，而这正是需要异步编程大显身手的场景。例如，有两个任务A、B，如果A是耗时任务，任务A就会阻塞任务B的执行，等到任务A执行完才能继续执行B</p>
<p>当使用异步编程时，在等待当前任务的响应返回之前，可以继续执行后续代码，即当前执行任务不会阻塞后续执行</p>
<blockquote>
<p>异步编程，不同于同步编程的请求-响应模式，其是一种事件驱动编程，请求调用函数或方法后，无需立即等待响应，可以继续执行其他任务，而之前任务响应返回后可以通过状态、通知和回调来通知调用者</p>
</blockquote>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>异步编程能很好的解决同步编程阻塞的问题，那么实现异步的方式有哪些呢？通常实现异步方式是多线程，如C#，Java即同时开启多个线程，不同操作能并行执行</p>
<h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>JavaScript语言执行环境是单线程的，单线程在程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行，而使用异步实现时，多个任务可以并发执行</p>
<h4 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h4><p>多线程的任务可以并行执行，而JavaScript单线程异步编程可以实现多任务并发执行，并行与并发的区别：</p>
<ul>
<li>并行，指同一时刻内多任务同时进行</li>
<li>并发，指在同一时间段内，多任务同时进行着，但是某一时刻，只有某一任务执行</li>
</ul>
<h3 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h3><p>JavaScript执行异步任务时，不需要等待响应返回，可以继续执行其他任务，而在响应返回时，会得到通知，执行回调或事件处理程序。那么这一切具体是如何完成的，又以什么规则或顺序运作呢？</p>
<p><strong>注：回调和事件处理程序本质上并无区别，只是在不同情况下，不同的叫法</strong></p>
<p>JavaScript异步编程使得多个任务可以并发执行，而实现这一功能的基础是JavScript拥有一个基于事件循环的并发模型</p>
<h4 id="堆栈与队列"><a href="#堆栈与队列" class="headerlink" title="堆栈与队列"></a>堆栈与队列</h4><p>介绍JavaScript并发模型之前，先简单介绍堆栈和队列的区别：</p>
<ul>
<li>堆（heap）：内存中某一未被阻止的区域，通常存储对象（引用类型）</li>
<li>栈（stack）：后进先出的顺序存储数据结构，通常存储函数参数和基本类型值变量（按值访问）</li>
<li>队列（queue）：先进先出顺序存储数据结构</li>
</ul>
<h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>JavaScript引擎负责解析，执行JavaScript代码，但它并不能单独运行，通常都得有一个宿主环境，一般如浏览器或Node服务器，前文说到的单线程是指在这些宿主环境创建单一线程，提供一种机制，调用JavaScript引擎完成多个JavaScript代码块的调度，执行（是的，JavaScript代码都是按块执行的），这种机制就称为事件循环（Event Loop）</p>
<p><strong>注：这里的事件与DOM事件不要混淆，可以说这里的事件包括DOM事件，所有异步操作都是一个事件，诸如ajax请求就可以看作一个request请求事件</strong></p>
<p>JavaScript执行环境中存在的两个结构需要了解：</p>
<ul>
<li>消息队列(message queue)，也叫任务队列（task queue）：存储待处理消息及对应的回调函数或事件处理程序</li>
<li>执行栈(execution context stack)，也可以叫执行上下文栈：JavaScript执行栈，顾名思义，是由执行上下文组成，当函数调用时，创建并插入一个执行上下文，通常称为执行栈帧（frame），存储着函数参数和局部变量，当该函数执行结束时，弹出该执行栈帧</li>
</ul>
<p><strong>注：关于全局代码，由于所有的代码都是在全局上下文执行，所以执行栈顶总是全局上下文就很容易理解，直到所有代码执行完毕，全局上下文退出执行栈，栈清空了；也即是全局上下文是第一个入栈，最后一个出栈</strong></p>
<h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>分析事件循环流程前，先阐述两个概念，有助于理解事件循环：同步任务和异步任务</p>
<p>任务很好理解，JavaScript代码执行就是在完成任务，所谓任务就是一个函数或一个代码块，通常以功能或目的划分，比如完成一次加法计算，完成一次ajax请求；很自然的就分为同步任务和异步任务。同步任务是连续的，阻塞的；而异步任务则是不连续，非阻塞的，包含异步事件及其回调，当谈及执行异步任务时，通常指执行其回调函数</p>
<h4 id="事件循环流程"><a href="#事件循环流程" class="headerlink" title="事件循环流程"></a>事件循环流程</h4><p>关于事件循环流程分解如下：</p>
<ol>
<li>宿主环境为JavaScript创建线程时，会创建堆(heap)和栈(stack)，堆内存储JavaScript对象，栈内存储执行上下文</li>
<li>栈内执行上下文的同步任务按序执行，执行完即退栈，而当异步任务执行时，该异步任务进入等待状态（不入栈），同时通知线程：当触发该事件时（或该异步操作响应返回时），需向消息队列插入一个事件消息</li>
<li>当事件触发或响应返回时，线程向消息队列插入该事件消息（包含事件及回调）</li>
<li>当栈内同步任务执行完毕后，线程从消息队列取出一个事件消息，其对应异步任务（函数）入栈，执行回调函数，如果未绑定回调，这个消息会被丢弃，执行完任务后退栈</li>
<li>当线程空闲（即执行栈清空）时继续拉取消息队列下一轮消息（next tick，事件循环流转一次称为一次tick）</li>
</ol>
<p>使用代码可以描述如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eventLoop = [];</span><br><span class="line"><span class="keyword">var</span> event;</span><br><span class="line"><span class="keyword">var</span> i = eventLoop.length - <span class="number">1</span>; <span class="comment">// 后进先出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(eventLoop[i]) &#123;</span><br><span class="line">    event = eventLoop[i--]; </span><br><span class="line">    <span class="keyword">if</span> (event) &#123; <span class="comment">// 事件回调存在</span></span><br><span class="line">        event();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则事件消息被丢弃</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>这里注意的一点是等待下一个事件消息的过程是同步的</em></p>
<p><strong>并发模型与事件循环：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ele = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clickCb</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'clicked'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    ele.addEventListener(<span class="string">'click'</span>, callback);</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">bindEvent(clickCb);</span><br></pre></td></tr></table></figure>
<h4 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h4><p>每个Web Worker或一个跨域的iframe都有各自的堆栈和消息队列，这些不同的文档只能通过postMessage方法进行通信，当一方监听了message事件后，另一方才能通过该方法向其发送消息，这个message事件也是异步的，当一方接收到另一方通过postMessage方法发送来的消息后，会向自己的消息队列插入一条消息</p>
<h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><p><strong>“异步模式”非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是Ajax操作。在服务器端，”异步模式”甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降，很快就会失去响应</strong></p>
<p><strong>JS常用的异步操作：</strong></p>
<ul>
<li><strong>网络请求，如<code>ajax</code> <code>http.get</code></strong></li>
<li><strong>IO 操作，如<code>readFile</code> <code>readdir</code></strong></li>
<li><strong>定时函数，如<code>setTimeout</code> <code>setInterval</code></strong></li>
<li><strong>事件绑定，如<code>$btn.on(&#39;click&#39;, function() {...})</code></strong></li>
</ul>
<p><strong>关于JavaScript的异步实现，ES6之前”异步模式”编程的几种方法：</strong></p>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>这是异步编程最基本的方法。假定有两个函数f1和f2，后者等待前者的执行结果：<code>f1(); f2();</code><br>如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">　　　　setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　　　　　<span class="comment">// f1的任务代码</span></span><br><span class="line">　　　　　　callback();</span><br><span class="line">　　　　&#125;, <span class="number">1000</span>);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码就变成这样：<code>f1(f2);</code><br>采用这种方式，把同步操作变成了异步操作，f1不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行<br>回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数</p>
<h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p>另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生<br>还是以f1和f2为例。首先，为f1绑定一个事件（这里采用的jQuery的写法）：<code>f1.on(‘done’, f2);</code><br>上面这行代码的意思是，当f1发生done事件，就执行f2。然后，对f1进行改写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　　　　　<span class="comment">// f1的任务代码</span></span><br><span class="line">　　　　　　f1.trigger(<span class="string">'done'</span>);   <span class="comment">//触发事件</span></span><br><span class="line">　　　　&#125;, <span class="number">1000</span>);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p>f1.trigger(‘done’)表示，执行完成后，立即触发done事件，从而开始执行f2<br>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰</p>
<h4 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布-订阅"></a>发布-订阅</h4><p>PubSub，即Publish/Subscribe，发布、订阅模式， 用以分发事件。常见的有jQuery的自定义事件监听、Node的EventEmitter对象等</p>
<p>上一节的”事件”，完全可以理解成”信号”。假定存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）<br>这个模式有多种实现，下面采用的是Ben Alman的Tiny Pub/Sub，这是jQuery的一个插件：<br>首先，f2向”信号中心”jQuery订阅”done”信号：<code>jQuery.subscribe(“done”, f2);</code>，然后，f1进行如下改写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　　　　　<span class="comment">// f1的任务代码</span></span><br><span class="line">　　　　　　jQuery.publish(<span class="string">"done"</span>);</span><br><span class="line">　　　　&#125;, <span class="number">1000</span>);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p>jQuery.publish(“done”)的意思是，f1执行完成后，向”信号中心”jQuery发布”done”信号，从而引发f2的执行<br>此外，f2完成执行后，也可以取消订阅（unsubscribe）：<code>jQuery.unsubscribe(“done”, f2);</code><br>这种方法的性质与”事件监听”类似，但是明显优于后者。因为可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行</p>
<h4 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h4><p>Promise是CommonJS的规范之一，拥有resolve、reject、done、fail、then等方法，能够控制代码的流程：</p>
<blockquote>
<ol>
<li>一个promise可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected）</li>
<li>一个promise的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换</li>
<li>promise必须实现then方法（可以说，then就是promise的核心），而且then必须返回一个promise，同一个promise的then可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致</li>
<li>then方法接受两个参数，第一个参数是成功时的回调，在promise由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在promise由“等待”态转换到“拒绝”态时调用</li>
<li>同时，then可以接受另一个promise传入，也接受一个“类then”的对象或方法，即thenable对象</li>
</ol>
</blockquote>
<p>不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为”回调函数噩梦”（callback hell）。 Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。采用Promise，连续读取多个文件，写法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFile = <span class="built_in">require</span>(<span class="string">'fs-readfile-promise'</span>);</span><br><span class="line">readFile(fileA)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> readFile(fileB);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如，f1的回调函数f2,可以写成： <code>f1().then(f2);</code>。f1要进行如下改写（这里使用的是jQuery的实现）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> dfd = $.Deferred();</span><br><span class="line">　　　　setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　　　　　<span class="comment">// f1的任务代码</span></span><br><span class="line">　　　　　　dfd.resolve();</span><br><span class="line">　　　　&#125;, <span class="number">500</span>);</span><br><span class="line">　　　　<span class="keyword">return</span> dfd.promise;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p>这样写的优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。比如，指定多个回调函数：<code>f1().then(f2).then(f3);</code>；再比如，指定发生错误时的回调函数：<code>f1().then(f2).fail(f3);</code>。而且，它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，不必担心是否错过了某个事件或信号</p>
<p>但是，Promise 的最大问题是代码冗余，原来的任务被Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚</p>
<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><h4 id="Generator方式"><a href="#Generator方式" class="headerlink" title="Generator方式"></a>Generator方式</h4><p>ECMAScript 2015作为下一代 JavaScript 语言，将 JavaScript 异步编程带入了一个全新的阶段</p>
<p>Generator 函数是协程在 ES6 的实现，<strong>最大特点就是可以交出函数的执行权（即暂停执行）。Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</strong>next 方法返回值的 value 属性，是 Generator 函数向外输出数据；next 方法还可以接受参数，这是向 Generator 函数体内输入数据。如下例：</p>
<p>特性1：暂停执行与恢复执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="comment">//(1)每次调用next只会执行yield后面的代码</span></span><br><span class="line">  <span class="comment">//(2)第二次调用next的时候可以将上一次调用yield后的结果返回给下一次的调用</span></span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是通过yield来暂停执行，通过next来恢复执行</p>
<p>特性2：函数体内外的数据交换</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() </span><br><span class="line"><span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next(<span class="number">2</span>) </span><br><span class="line"><span class="comment">// &#123; value: 2, done: true &#125;</span></span><br><span class="line"><span class="comment">// 这里的g.next(2)相当于向generator函数传入值(即表示上一次调用g.next得到的值为2)，作为上一个yield的返回值，所以得到的结果为2</span></span><br></pre></td></tr></table></figure>
<p>通过调用next方法获取到的value代表函数体向外输出的数据，而调用next方法传入的参数本身代表向Generator传入数据</p>
<p>特性3：错误处理机制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e)&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next();</span><br><span class="line">g.throw（<span class="string">'出错了'</span>）;</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure>
<p>上面代码的最后一行，Generator 函数体外，使用指针对象的 throw 方法抛出的错误，可以被函数体内的 try … catch 代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的</p>
<p>下面是Generator处理实际任务的一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">'https://api.github.com/users/github'</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">  <span class="built_in">console</span>.log(result.bio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的执行过程如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> result = g.next();</span><br><span class="line"><span class="comment">//(1)第一步调用g.next表示从服务端获取数据，即得到yield fetch(url)的结果</span></span><br><span class="line"><span class="comment">//(2)第一个then方法表示将yield的结果转化为json</span></span><br><span class="line"><span class="comment">//(3)第二个then方法表示将json传回到generator方法，此时可以打印result.bio的值</span></span><br><span class="line">result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  g.next(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="thunk函数"><a href="#thunk函数" class="headerlink" title="thunk函数"></a>thunk函数</h4><p><strong>基本概念</strong></p>
<p>编译器的”传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> m * <span class="number">2</span>;     </span><br><span class="line">&#125;</span><br><span class="line">f(x + <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> thunk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">thunk</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> thunk() * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数 f 的参数 x + 5 被一个函数替换了。凡是用到原参数的地方，对 Thunk 函数求值即可。这就是 Thunk 函数的定义，它是”传名调用”的一种实现策略，用来替换某个表达式</p>
<p><strong>JavaScript中的thunk函数</strong></p>
<p>JavaScript 语言是传值调用，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，<strong>Thunk 函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数</strong></p>
<p>thunk函数的实现机制还是通过闭包来完成的。其调用分为三步，首先是传入一个函数,接着是传入该函数的所有除了callback以外的参数,最后是传入回调函数callback</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkify</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//第一步：传入函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//第二步：传入除了callback以外的参数</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">arguments</span>.length);</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; ++i) &#123;</span><br><span class="line">      args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//第三步：传入回调函数</span></span><br><span class="line">      <span class="keyword">var</span> called;</span><br><span class="line">      args.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//回调函数只会运行一次</span></span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        done.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fn.apply(ctx, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        done(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="thunk与Generator"><a href="#thunk与Generator" class="headerlink" title="thunk与Generator"></a>thunk与Generator</h4><p><strong>Generator的yield返回的必须是thunkify的函数才能递归</strong></p>
<p>Thunk 函数有什么用？回答在以前确实没什么用，但是 ES6 有了 Generator 函数，Thunk 函数现在可以用于 Generator 函数的自动流程管理</p>
<p>以读取文件为例。下面的 Generator 函数封装了两个异步操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">'thunkify'</span>);</span><br><span class="line"><span class="keyword">var</span> readFile = thunkify(fs.readFile);</span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> r1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="comment">//1.交出执行权</span></span><br><span class="line">  <span class="built_in">console</span>.log(r1.toString());</span><br><span class="line">  <span class="keyword">var</span> r2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">   <span class="comment">//1.交出执行权</span></span><br><span class="line">  <span class="built_in">console</span>.log(r2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，yield 命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。这种方法就是 Thunk 函数，因为它可以在回调函数里，将执行权交还给 Generator 函数。手动执行上面这Generator 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> r1 = g.next();</span><br><span class="line"><span class="comment">//2.查看这里的程序你可以清楚的看到，这里是将同一个回调函数反复的传入到g.next返回的value中。但是这个返回的value必须是thunkify过后的函数，这样它只会接受一个参数，那么就满足这里的定义了</span></span><br><span class="line">r1.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="keyword">var</span> r2 = g.next(data);</span><br><span class="line">  r2.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//2.value必须是thunkify的函数才会只接受一个callback参数</span></span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    g.next(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量 g 是 Generator 函数的内部指针，表示目前执行到哪一步。next 方法负责将指针移动到下一步，并返回该步的信息（value 属性和 done 属性）。 仔细查看上面的代码，可以发现 Generator 函数的执行过程，其实是将同一个回调函数，反复传入 next 方法的 value 属性。这使得可以用<code>递归</code>来自动完成这个过程</p>
<p><strong>使用thunkify来自动执行Generator函数从而将执行权交还给Generator</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> gen = fn();</span><br><span class="line">  <span class="comment">//获取到generator内部指针，这里的next就是thunk函数的回调函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = gen.next(data);</span><br><span class="line">    <span class="comment">//获取generator内部状态</span></span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</span><br><span class="line">    result.value(next);</span><br><span class="line">    <span class="comment">//Gnerator的value必须是thunkify函数，此时才会只接受一个回调函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>
<p>下面是一个读取多个文件的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'fileA'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'fileB'</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> fn = <span class="keyword">yield</span> readFile(<span class="string">'fileN'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数 gen 封装了 n 个异步的读取文件操作，只要执行 run 函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行</p>
<p>Thunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点</p>
<h4 id="co函数库"><a href="#co函数库" class="headerlink" title="co函数库"></a>co函数库</h4><p>co 函数库是著名程序员 TJ Holowaychuk 于2013年6月发布的一个小工具，用于 Generator 函数的自动执行</p>
<p><strong>co函数库自动执行Generator，但是yield后必须是promise或者thunk函数</strong></p>
<p>比如，有一个 Generator 函数，用于依次读取两个文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>co 函数库可以让你不用编写 Generator 函数的执行器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line">co(gen);</span><br></pre></td></tr></table></figure>
<p>上面代码中，Generator 函数只要传入 co 函数，就会自动执行。co 函数返回一个 <code>Promise 对象</code>，因此可以用 then 方法添加回调函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">co(gen).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Generator 函数执行完成'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面代码中，等到 Generator 函数执行结束，就会输出一行提示。相对于thunkify，co的yeild后可以是promise或者thunk函数，其中后者是通过递归来实现的</p>
<p><strong>co函数库自动执行Generator的原理</strong></p>
<p>为什么 co 可以自动执行 Generator 函数？</p>
<p>Generator 函数就是一个异步操作的容器，它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权</p>
<p>两种方法可以做到这一点：</p>
<ul>
<li>回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权</li>
<li>Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。 co 函数库其实就是将<strong>两种自动执行器（Thunk 函数和 Promise 对象），包装成一个库</strong>。使用 co 的前提条件是，Generator 函数的 yield 命令后面，只能是 Thunk 函数或 Promise 对象</li>
</ul>
<p>下面展示如何使用Promise来交还执行权：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//这里new Promise导致readFile本身返回的是一个Promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">      <span class="comment">//then方法的回调函数中会得到这里的data数据</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="comment">//这里返回的是一个Promise对象，所以通过g.next().value获取到的对象可以继续调用then方法</span></span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>手动执行上面这个Generator函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="comment">//g.next()开始执行第一个readFile方法，g.next().value表示执行第一个readFile返回的promise对象</span></span><br><span class="line">g.next().value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//g.next(data)表示将上一个yield的执行结果交还给Generator，相当于将结果赋值给变量f1</span></span><br><span class="line">  g.next(data).value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    g.next(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注意：如果是下面这样，那么f1最后将会是undefined(toString报错)，因为第一个yield执行结果并没有交还给Generator，所以无法获取到内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line">g.next().value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//下面不是g.next(data)，所以第一个读取文件的结果没有交还给Generator的f1</span></span><br><span class="line">  g.next().value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    g.next(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>而下面展示的就是一个通过Promise来自动执行Generator的实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> g = gen();</span><br><span class="line">  <span class="comment">//获取指针</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = g.next(data);</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line">    <span class="comment">//result.value此处返回的是Promise对象</span></span><br><span class="line">    result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      next(data);</span><br><span class="line">      <span class="comment">//将data交给上一个yield执行结果</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><h4 id="async和Generator"><a href="#async和Generator" class="headerlink" title="async和Generator"></a>async和Generator</h4><p>一句话，async 函数就是 Generator 函数的语法糖。比如一个 Generator 函数，依次读取两个文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>写成 async 函数，就是下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已</p>
<h4 id="async函数优点"><a href="#async函数优点" class="headerlink" title="async函数优点"></a>async函数优点</h4><p>async 函数对 Generator 函数的改进，体现在以下三点：</p>
<p>（1）内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = asyncReadFile();</span><br></pre></td></tr></table></figure>
<p>（2）更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果</p>
<p>（3）更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）</p>
<h4 id="async的用法"><a href="#async的用法" class="headerlink" title="async的用法"></a>async的用法</h4><p>同 Generator 函数一样，<strong>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数</strong>。当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句</p>
<p>下面的例子，指定多少毫秒后输出一个值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(ms);</span><br><span class="line">  <span class="comment">//遇到await了，所有先返回，得到异步操作完成，执行后面的代码</span></span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码指定50毫秒以后，输出”hello world”</p>
<p><strong>async自动执行器实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//genF是Generator函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">genF</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//返回promise和co一样，但是co只能是promise和thunk函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gen = genF();</span><br><span class="line">    <span class="comment">//得到Generator内部指针</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">nextF</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> next = nextF();</span><br><span class="line">       <span class="comment">//next获取到第一个await返回的结果</span></span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e); </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(next.done) &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(next.value);</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">//如果done为true那么直接resolve</span></span><br><span class="line">      <span class="built_in">Promise</span>.resolve(next.value).then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//第一个await返回的对象的value表示结果&#123;value:'',done:false&#125;</span></span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(v); &#125;);  </span><br><span class="line">        <span class="comment">//调用gen.next()获取到下一个await的结果并传入上一次的await调用后得到的value    </span></span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.throw(e); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(<span class="literal">undefined</span>); &#125;);</span><br><span class="line">    <span class="comment">//首次执行的时候传入第一个await的data为undefined</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="附：Promise函数深入理解"><a href="#附：Promise函数深入理解" class="headerlink" title="附：Promise函数深入理解"></a>附：Promise函数深入理解</h3><p>每一个promise对象都会提供一个then方法或者是catch方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// I'm inside a then() function!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在then方法内部，可以做三件事：</p>
<ol>
<li>return 一个promise对象</li>
<li>return 一个同步的值或者是 undefined</li>
<li>同步的 throw 一个错误</li>
</ol>
<p><strong>返回另一个promise对象</strong></p>
<p>这种写法很常见，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">&#125;).then(funcxtion (userAccount) &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码里面的return非常关键，没有这个return的话，getUserAccountById只是一个普通的被别的函数调用的函数。下一个回调函数会接收到undefined而不是userAccount</p>
<p><strong>返回一个同步的值或者是 undefined</strong></p>
<p>返回一个 undefined 大多数情况下是错误的，但是返回一个同步的值确实是一个将同步代码转化成promise风格代码的好方法。举个例子，现在在内存中有users。可以：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(fcuntion (user) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">        <span class="keyword">return</span> inMemoryCache[user.id]; </span><br><span class="line">         <span class="comment">// returning a synchronous value!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inMemoryCache[user.id]; </span><br><span class="line">    <span class="comment">// returning a promise</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// I got a user account</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>第二个回调函数并不关心userAccount是通过同步的方式得到的还是异步的方式得到的，而第一个回调函数既可以返回同步的值又可以返回异步的值。不幸的是，如果不显式调用return语句的话，javaScript里的函数会返回 undefined 。这也就意味着在想返回一些值的时候，不显式调用return会产生一些副作用</p>
<p>因此，最好的习惯就是在<code>then方法内部永远显式的调用return或者throw</code></p>
<p><strong>抛出一个同步的错误</strong></p>
<p>说到throw，这又体现了promise的功能强大。在用户退出的情况下，代码中会采用抛出异常的方式进行处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user.isLoggedOut()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'user logged out!'</span>); <span class="comment">// throwing a synchronous error!</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">    <span class="keyword">return</span> inMemoryCache[user.id];       <span class="comment">// returning a synchronous value!</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id);    <span class="comment">// returning a promise!</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I got a user account!</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Boo, I got an error!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果用户已经登出的话， catch() 会收到一个同步的错误，如果有promise对象的状态变为rejected的话，它也会收到一个异步的错误。 catch() 的回调函数不用关心错误是异步的还是同步的</p>
<p>在使用promise的时候抛出异常在开发阶段很有用，它能定位代码中的错误。比方说，在then函数内部调用 JSON.parse() ，如果JSON对象不合法的话，可能会抛出异常，在回调函数中，这个异常会被吞噬，但是在使用promise之后，就可以捕获到这个异常了</p>
<p>有助于深入的理解Promise的例子：</p>
<p>例子1</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doSomethingElse();</span><br><span class="line">  <span class="comment">//undefined</span></span><br><span class="line">&#125;).then(finalHandler);</span><br><span class="line"><span class="comment">//finalHandler会接受到前面then指定的函数的返回值，因为它明确的return了，注意return不可少</span></span><br></pre></td></tr></table></figure>
<p>答案如下：then方法中没有形参接受到doSomething返回的值，所以为undefined</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|-----------------|</span><br><span class="line">                  doSomethingElse(undefined) </span><br><span class="line">                  |------------------|</span><br><span class="line">                                     finalHandler(resultOfDoSomethingElse)</span><br><span class="line">                                     |------------------|</span><br></pre></td></tr></table></figure>
<p>例子2</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  doSomethingElse();</span><br><span class="line">&#125;).then(finalHandler);</span><br></pre></td></tr></table></figure>
<p>答案如下:finalHandler也会接受到undefined，因为前面的then中的函数没有明确的return值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|-----------------|</span><br><span class="line">                  doSomethingElse(undefined)</span><br><span class="line">                  |------------------|</span><br><span class="line">                  finalHandler(undefined)</span><br><span class="line">                  |------------------|</span><br></pre></td></tr></table></figure>
<p>例子3</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(doSomethingElse())</span><br><span class="line"><span class="comment">//doSomethingElse()返回了Promise的情况比较特殊，finalHandler接受到doSomething的值</span></span><br><span class="line">  .then(finalHandler);</span><br></pre></td></tr></table></figure>
<p>答案如下：因为then方法中的doSomethingElse()返回的是一个Promise对象，即typeof doSomethingElse()为”object”，所以finalHandler会接收到doSomething返回的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|-----------------|</span><br><span class="line">doSomethingElse(undefined)</span><br><span class="line">|---------------------------------|</span><br><span class="line">                  finalHandler(resultOfDoSomething)</span><br><span class="line">                  |------------------|</span><br></pre></td></tr></table></figure>
<p>比如下面的例子依然输出的为”qinliang”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f=<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;<span class="built_in">console</span>.log(result);&#125;</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">"qinliang"</span>).then(f);</span><br></pre></td></tr></table></figure>
<p>和下面的代码输出结果完全相同:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'qinliang'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;<span class="built_in">console</span>.log(result);&#125;)</span><br></pre></td></tr></table></figure>
<p>其实它们的then方法传入函数签名完全一致</p>
<p>例子4</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(doSomethingElse)</span><br><span class="line"><span class="comment">//doSomethingElse会接受到doSomething()的结果</span></span><br><span class="line">  .then(finalHandler);</span><br><span class="line"><span class="comment">//finalHandler会接受到doSomethingElse的结果</span></span><br></pre></td></tr></table></figure>
<p>答案如下：doSomethingElse只是一个<code>函数句柄(如const doSomething=function(){})</code>，通过调用这个函数句柄doSomethingElse()会得到Promise对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|-----------------|</span><br><span class="line">                  doSomethingElse(resultOfDoSomething)</span><br><span class="line">                  |------------------|</span><br><span class="line">                                     finalHandler(resultOfDoSomethingElse)</span><br><span class="line">                                     |------------------|</span><br></pre></td></tr></table></figure>
<p>需要说明的是，在上述的例子中，都假设 doSomething() 和 doSomethingElse() 返回<strong>(注意是返回了，即return的情况下，而不是第一个例子的方式)</strong>一个promise对象，这些promise对象都代表了一个异步操作，这样的操作会在当前event loop之外结束，比如说有关IndexedDB，network的操作，或者是使用 setTimeout</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">JavaScript</a>
        		</li>
      		
		</ul>
	</div>

      

      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-JavaScript Math&amp;Date" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/12/JavaScript Math&Date/">JavaScript Math&amp;Date</a>
    </h1>
  

        
        <a href="/2018/08/12/JavaScript Math&Date/" class="archive-article-date">
  	<time datetime="2018-08-11T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-08-12</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JavaScript-Math"><a href="#JavaScript-Math" class="headerlink" title="JavaScript Math"></a>JavaScript Math</h2><h3 id="Math中的属性"><a href="#Math中的属性" class="headerlink" title="Math中的属性"></a>Math中的属性</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Math.E</td>
<td style="text-align:center">欧拉常数，也是自然对数的底数</td>
<td style="text-align:center">约2.718</td>
</tr>
<tr>
<td style="text-align:center">Math.LN2</td>
<td style="text-align:center">2的自然对数</td>
<td style="text-align:center">约0.693</td>
</tr>
<tr>
<td style="text-align:center">Math.LN10</td>
<td style="text-align:center">10的自然对数</td>
<td style="text-align:center">约2.303</td>
</tr>
<tr>
<td style="text-align:center">Math.LOG2E</td>
<td style="text-align:center">以2为底E的对数</td>
<td style="text-align:center">约1.443</td>
</tr>
<tr>
<td style="text-align:center">Math.LOG10E</td>
<td style="text-align:center">以10为底E的对数</td>
<td style="text-align:center">约0.434</td>
</tr>
<tr>
<td style="text-align:center">Math.PI</td>
<td style="text-align:center">圆周率</td>
<td style="text-align:center">约3.14</td>
</tr>
<tr>
<td style="text-align:center">Math.SQRT1_2</td>
<td style="text-align:center">1/2的平方根</td>
<td style="text-align:center">约0.707</td>
</tr>
<tr>
<td style="text-align:center">Math.SQRT2</td>
<td style="text-align:center">2的平方根</td>
<td style="text-align:center">约1.414</td>
</tr>
</tbody>
</table>
<h3 id="Math中的方法"><a href="#Math中的方法" class="headerlink" title="Math中的方法"></a>Math中的方法</h3><p>Math对象本就有很多用于运算的方法，值得关注的是, ES6 规范又对Math对象做了一些扩展，增加了一系列便捷的方法。而这些方法大致可以分为以下三类：</p>
<h4 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h4><table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Math.sin(x)</td>
<td style="text-align:center">返回x的正弦值</td>
</tr>
<tr>
<td style="text-align:center">Math.sinh(x) ES6新增</td>
<td style="text-align:center">返回x的双曲正弦值</td>
</tr>
<tr>
<td style="text-align:center">Math.cos(x)</td>
<td style="text-align:center">返回x的余弦值</td>
</tr>
<tr>
<td style="text-align:center">Math.cosh(x) ES6新增</td>
<td style="text-align:center">返回x的双曲余弦值</td>
</tr>
<tr>
<td style="text-align:center">Math.tan(x)</td>
<td style="text-align:center">返回x的正切值</td>
</tr>
<tr>
<td style="text-align:center">Math.tanh(x) ES6新增</td>
<td style="text-align:center">返回x的双曲正切值</td>
</tr>
<tr>
<td style="text-align:center">Math.asin(x)</td>
<td style="text-align:center">返回x的反正弦值</td>
</tr>
<tr>
<td style="text-align:center">Math.asinh(x) ES6新增</td>
<td style="text-align:center">返回x的反双曲正弦值</td>
</tr>
<tr>
<td style="text-align:center">Math.acos(x)</td>
<td style="text-align:center">返回x的反余弦值</td>
</tr>
<tr>
<td style="text-align:center">Math.atan(x)</td>
<td style="text-align:center">返回x的反正切值</td>
</tr>
<tr>
<td style="text-align:center">Math.atan2(x, y)</td>
<td style="text-align:center">返回 y/x 的反正切值</td>
</tr>
<tr>
<td style="text-align:center">Math.atanh(x) ES6新增</td>
<td style="text-align:center">返回 x 的反双曲正切值</td>
</tr>
</tbody>
</table>
<h4 id="数学运算方法"><a href="#数学运算方法" class="headerlink" title="数学运算方法"></a>数学运算方法</h4><table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Math.sqrt(x)</td>
<td style="text-align:center">返回x的平方根</td>
<td style="text-align:center">Math.sqrt(9);//3</td>
</tr>
<tr>
<td style="text-align:center">Math.exp(x)</td>
<td style="text-align:center">返回欧拉常数(e)的x次幂</td>
<td style="text-align:center">Math.exp(1);//约2.718</td>
</tr>
<tr>
<td style="text-align:center">Math.pow(x,y)</td>
<td style="text-align:center">返回x的y次幂, 如果y未初始化, 则返回x</td>
<td style="text-align:center">Math.pow(2, 3);//8</td>
</tr>
<tr>
<td style="text-align:center">Math.expm1(x) ES6新增</td>
<td style="text-align:center">返回欧拉常数(e)的x次幂减去1的值</td>
<td style="text-align:center">Math.exp(1);//约1.718</td>
</tr>
<tr>
<td style="text-align:center">Math.log(x)</td>
<td style="text-align:center">返回x的自然对数</td>
<td style="text-align:center">Math.log(1);//0</td>
</tr>
<tr>
<td style="text-align:center">Math.log1p(x) ES6新增</td>
<td style="text-align:center">返回x+1后的自然对数</td>
<td style="text-align:center">Math.log1p(0);//0</td>
</tr>
<tr>
<td style="text-align:center">Math.log2(x) ES6新增</td>
<td style="text-align:center">返回x以2为底的对数</td>
<td style="text-align:center">Math.log2(8);//3</td>
</tr>
<tr>
<td style="text-align:center">Math.log10(x) ES6新增</td>
<td style="text-align:center">返回x以10为底的对数</td>
<td style="text-align:center">Math.log10(100);//2</td>
</tr>
<tr>
<td style="text-align:center">Math.cbrt(x) ES6新增</td>
<td style="text-align:center">返回x的立方根</td>
<td style="text-align:center">Math.cbrt(8);//约2</td>
</tr>
<tr>
<td style="text-align:center">Math.clz32() ES6新增</td>
<td style="text-align:center">返回一个数字在转换成 32位无符号整型数字的二进制形式后, 开头的 0 的个数</td>
<td style="text-align:center">Math.clz32(2);//30</td>
</tr>
<tr>
<td style="text-align:center">Math.hypot(x,y,z) ES6新增</td>
<td style="text-align:center">返回所有参数的平方和的平方根</td>
<td style="text-align:center">Math.hypot(3,4);//5</td>
</tr>
<tr>
<td style="text-align:center">Math.imul(x,y) ES6新增</td>
<td style="text-align:center">返回两个参数的类C的32位整数乘法运算的运算结果</td>
<td style="text-align:center">Math.imul(0xffffffff, 5);//-5</td>
</tr>
</tbody>
</table>
<h4 id="数值运算方法"><a href="#数值运算方法" class="headerlink" title="数值运算方法"></a>数值运算方法</h4><table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Math.abs(x)</td>
<td style="text-align:center">返回x的绝对值</td>
<td style="text-align:center">Math.abs(-5);//5</td>
</tr>
<tr>
<td style="text-align:center">Math.floor(x)</td>
<td style="text-align:center">返回小于x的最大整数</td>
<td style="text-align:center">Math.floor(8.2);//8</td>
</tr>
<tr>
<td style="text-align:center">Math.ceil(x)</td>
<td style="text-align:center">返回大于x的最小整数</td>
<td style="text-align:center">Math.ceil(8.2);//9</td>
</tr>
<tr>
<td style="text-align:center">Math.trunc(x) ES6新增</td>
<td style="text-align:center">返回x的整数部分</td>
<td style="text-align:center">Math.trunc(1.23);//1</td>
</tr>
<tr>
<td style="text-align:center">Math.fround(x) ES6新增</td>
<td style="text-align:center">返回离它最近的单精度浮点数形式的数字</td>
<td style="text-align:center">Math.fround(1.1);//1.100000023841858</td>
</tr>
<tr>
<td style="text-align:center">Math.min(x,y,z)</td>
<td style="text-align:center">返回多个数中的最小值</td>
<td style="text-align:center">Math.min(3,1,5);//1</td>
</tr>
<tr>
<td style="text-align:center">Math.max(x,y,z)</td>
<td style="text-align:center">返回多个数中的最大值</td>
<td style="text-align:center">Math.max(3,1,5);//5</td>
</tr>
<tr>
<td style="text-align:center">Math.round(x)</td>
<td style="text-align:center">返回四舍五入后的整数</td>
<td style="text-align:center">Math.round(8.2);//8</td>
</tr>
<tr>
<td style="text-align:center">Math.random()</td>
<td style="text-align:center">返回0到1之间的伪随机数</td>
<td style="text-align:center">Math.random();</td>
</tr>
<tr>
<td style="text-align:center">Math.sign(x) ES6新增</td>
<td style="text-align:center">返回一个数的符号( 5种返回值, 分别是 1, -1, 0, -0, NaN. 代表的各是正数, 负数, 正零, 负零, NaN)</td>
<td style="text-align:center">Math.sign(-5);//-1</td>
</tr>
</tbody>
</table>
<p><strong>附：Number类型数值运算方法</strong></p>
<p>Number.prototype中有一个方法叫做toFixed()，用于将数值装换为指定小数位数的形式</p>
<ul>
<li>没有参数或者参数为零的情况下，toFixed() 方法返回该数值的四舍五入后的整数形式，等同于 Math.round(x);</li>
<li>其他情况下，返回该数的指定小数位数的四舍五入后的结果</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1234.56789</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(),num.toFixed(<span class="number">0</span>));<span class="comment">//1235,1235</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">1</span>));<span class="comment">//1234.6</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-1.235</span>.toFixed(<span class="number">2</span>));<span class="comment">//-1.24</span></span><br></pre></td></tr></table></figure>
<h3 id="Math方法规律"><a href="#Math方法规律" class="headerlink" title="Math方法规律"></a>Math方法规律</h3><p>数值运算中, 存在如下规律：</p>
<ol>
<li>Math.trunc(x) 方法当 ① x为正数时，运算结果同 Math.floor(x); ② x为负数时，运算结果同 Math.ceil(x)。实际上，它完全可以由位运算替代，且运算速度更快，如 2.5&amp;-1 或 2.5|0 或 ~~2.5 或 2.5^0，它们的运算结果都为2；如 -2.5&amp;-1 或 -2.5|0 或 ~~-2.5 或 -2.5^0，它们的运算结果都为-2</li>
<li>Math.min(x,y,z) 与 Math.max(x,y,z) 方法由于可接无限个参数，可用于求数组元素的最小最大值。如：<code>Math.max.apply(null,[5,3,8,9]); // 9</code> 但是Math.min 不传参数返回 <code>Infinity</code>，Math.max 不传参数返回 <code>-Infinity</code> </li>
<li>稍微利用 Math.random() 方法的特性， 就可以生成任意范围的数字。 如: 生成10到80之间的随机数，~~(Math.random()*70 + 10);// 返回10~80之间的随机数， 包含10不包含80</li>
</ol>
<p>除去上述方法，Math作为对象，继承了来之Object对象的方法。 其中一些如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.valueOf();<span class="comment">//返回Math对象本身</span></span><br><span class="line">+<span class="built_in">Math</span>; <span class="comment">//NaN, 试图转换成数字,由于不能转换为数字,返回NaN</span></span><br><span class="line"><span class="built_in">Math</span>.toString();<span class="comment">//"[object Math]"</span></span><br></pre></td></tr></table></figure>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="数值的二进制值"><a href="#数值的二进制值" class="headerlink" title="数值的二进制值"></a>数值的二进制值</h4><p>由于位运算是基于二进制的，因此需要先获取数值的二进制值。实际上，toString 方法已经做好了一部分工作，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正整数可通过toString获取</span></span><br><span class="line"><span class="number">12.</span>.toString(<span class="number">2</span>);<span class="comment">//1100</span></span><br><span class="line"><span class="comment">//负整数问题就来了</span></span><br><span class="line">(<span class="number">-12</span>).toString(<span class="number">2</span>);<span class="comment">//-1100</span></span><br></pre></td></tr></table></figure>
<p>已知：负数在计算机内部是采用补码表示的。 例如 -1， 1的原码是 0000 0001，那么1的反码是 1111 1110，补码是 1111 1111</p>
<p>故： 负数的十进制转换为二进制时，符号位不变,其它位取反后+1。 即： <strong>-x的二进制 = x的二进制取反+1</strong>。 由按位取反可借助^运算符，故负整数的二进制可以借助下面这个函数来获取：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBinary</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = (-num).toString(<span class="number">2</span>),</span><br><span class="line">      array = [].map.call(s,<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v^<span class="number">1</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">  array.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">previousValue, value, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> v = previousValue ^ value;</span><br><span class="line">    array[index] = v;</span><br><span class="line">    <span class="keyword">return</span> +!v;</span><br><span class="line">  &#125;,<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> array.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line">getBinary(<span class="number">-12</span>);<span class="comment">//0100, 前面未补全的部分全部为1</span></span><br></pre></td></tr></table></figure>
<p>然后，多试几次就会发现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getBinary(<span class="number">-1</span>) == <span class="number">1.</span>.toString(<span class="number">2</span>); <span class="comment">//true</span></span><br><span class="line">getBinary(<span class="number">-2</span>) == <span class="number">2.</span>.toString(<span class="number">2</span>); <span class="comment">//true</span></span><br><span class="line">getBinary(<span class="number">-4</span>) == <span class="number">4.</span>.toString(<span class="number">2</span>); <span class="comment">//true</span></span><br><span class="line">getBinary(<span class="number">-8</span>) == <span class="number">8.</span>.toString(<span class="number">2</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>这表明：</p>
<ul>
<li><strong>2的整数次方的值与它的相对数, 他们后面真正有效的那几位都相同</strong></li>
</ul>
<p>同样，负数的二进制转十进制时，符号位不变，其他位取反后+1。可参考：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translateBinary2Decimal</span>(<span class="params">binaryString</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> array = [].map.call(binaryString,<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v^<span class="number">1</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  array.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">previousValue, value, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> v = previousValue ^ value;</span><br><span class="line">    array[index] = v;</span><br><span class="line">    <span class="keyword">return</span> +!v;</span><br><span class="line">  &#125;,<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(array.join(<span class="string">''</span>),<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">translateBinary2Decimal(getBinary(<span class="number">-12</span>));<span class="comment">//12</span></span><br></pre></td></tr></table></figure>
<p>由上，二进制转十进制和十进制转二进制的函数，大部分都可以共用， 因此下面提供一个统一的函数解决它们的互转问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translateBinary</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="literal">null</span>,</span><br><span class="line">      array = <span class="literal">null</span>,</span><br><span class="line">      type = <span class="keyword">typeof</span> item,</span><br><span class="line">      symbol = !<span class="regexp">/^-/</span>.test(item+<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"number"</span>: </span><br><span class="line">      s = <span class="built_in">Math</span>.abs(item).toString(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span>(symbol)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"string"</span>:</span><br><span class="line">      <span class="keyword">if</span>(symbol)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parseInt</span>(item,<span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      s = item.substring(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//按位取反</span></span><br><span class="line">  array = [].map.call(s,<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v^<span class="number">1</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//+1</span></span><br><span class="line">  array.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">previousValue, value, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> v = (previousValue + value)==<span class="number">2</span>;</span><br><span class="line">    array[index] = previousValue ^ value;</span><br><span class="line">    <span class="keyword">return</span> +v;</span><br><span class="line">  &#125;,<span class="number">1</span>);</span><br><span class="line">  s = array.join(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">return</span> type==<span class="string">"number"</span>?<span class="string">'-'</span>+s:-<span class="built_in">parseInt</span>(s,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">translateBinary(<span class="number">-12</span>);<span class="comment">//"-0100"</span></span><br><span class="line">translateBinary(<span class="string">'-0100'</span>);<span class="comment">//-12</span></span><br></pre></td></tr></table></figure>
<h4 id="常用的二进制数"><a href="#常用的二进制数" class="headerlink" title="常用的二进制数"></a>常用的二进制数</h4><table>
<thead>
<tr>
<th style="text-align:center">二进制数</th>
<th style="text-align:center">二进制值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0xAAAAAAAA</td>
<td style="text-align:center">10101010101010101010101010101010</td>
</tr>
<tr>
<td style="text-align:center">0x55555555</td>
<td style="text-align:center">01010101010101010101010101010101</td>
</tr>
<tr>
<td style="text-align:center">0xCCCCCCCC</td>
<td style="text-align:center">11001100110011001100110011001100</td>
</tr>
<tr>
<td style="text-align:center">0x33333333</td>
<td style="text-align:center">00110011001100110011001100110011</td>
</tr>
<tr>
<td style="text-align:center">0xF0F0F0F0</td>
<td style="text-align:center">11110000111100001111000011110000</td>
</tr>
<tr>
<td style="text-align:center">0x0F0F0F0F</td>
<td style="text-align:center">00001111000011110000111100001111</td>
</tr>
<tr>
<td style="text-align:center">0xFF00FF00</td>
<td style="text-align:center">11111111000000001111111100000000</td>
</tr>
<tr>
<td style="text-align:center">0x00FF00FF</td>
<td style="text-align:center">00000000111111110000000011111111</td>
</tr>
<tr>
<td style="text-align:center">0xFFFF0000</td>
<td style="text-align:center">11111111111111110000000000000000</td>
</tr>
<tr>
<td style="text-align:center">0x0000FFFF</td>
<td style="text-align:center">00000000000000001111111111111111</td>
</tr>
</tbody>
</table>
<p>可以使用上述方法来验证下常用的二进制值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">translateBinary(<span class="number">0xAAAAAAAA</span>);<span class="comment">//"10101010101010101010101010101010"</span></span><br></pre></td></tr></table></figure>
<h4 id="按位与-amp"><a href="#按位与-amp" class="headerlink" title="按位与(&amp;)"></a>按位与(&amp;)</h4><p>&amp;运算符用于连接两个数, 连接的两个数它们二进制补码形式的值每位都将参与运算，只有相对应的位上都为1时，该位的运算才返回1。比如 3 和 9 进行按位与运算，以下是运算过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	<span class="number">0011</span>	<span class="comment">//3的二进制补码形式</span></span><br><span class="line">&amp;	<span class="number">1001</span>	<span class="comment">//9的二进制补码形式</span></span><br><span class="line">--------------------</span><br><span class="line">	<span class="number">0001</span>	<span class="comment">//1,相同位数依次运算,除最后一位都是1,返回1以外, 其它位数由于不同时为1都返回0</span></span><br></pre></td></tr></table></figure>
<p>由上，3&amp;9的运算结果为1。实际上，由于按位与(&amp;)运算同位上返回1的要求较为严苛，因此，它是一种趋向减小最大值的运算。(无论最大值是正数还是负数，参与按位与运算后，该数总是趋向减少二进制值位上1的数量，因此总是有值减小的趋势 ) 对于按位与(&amp;)运算， 满足如下规律：</p>
<ol>
<li><strong>数值与自身(或者-1)按位与运算返回数值自身</strong></li>
<li><strong>2的整数次方的值与它的相对数按位与运算返回它自身</strong></li>
<li><strong>任意整数与0进行按位与运算, 都将会返回0</strong></li>
<li><strong>任意整数与1进行按位与运算, 都只有0 或1 两个返回值</strong></li>
<li><strong>按位与运算的结果不大于两数中的最大值</strong></li>
</ol>
<p>由公式1，可以对非整数取整。即 <code>x&amp;x === x&amp;-1 === Math.trunc(x)</code> 如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">5.2</span>&amp;<span class="number">5.2</span>);<span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-5.2</span>&amp;<span class="number">-1</span>);<span class="comment">//-5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="number">-5.2</span>)===(<span class="number">-5.2</span>&amp;<span class="number">-1</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>由公式4， 可以由此判断数值是否为奇数。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">1</span> &amp; x)&#123;<span class="comment">//如果x为奇数,它的二进制补码形式最后一位必然是1,同1进行按位与运算后,将返回1,而1又会隐式转换为true</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"x为奇数"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="按位或"><a href="#按位或" class="headerlink" title="按位或(|)"></a>按位或(|)</h4><p>|不同于&amp;，|运算符连接的两个数，只要其二进制补码形式的各位上有一个为1，该位的运算就返回1，否则返回0.。比如 3 和 12 进行按位或运算, 以下是运算过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	<span class="number">0011</span>	<span class="comment">//3的二进制补码形式</span></span><br><span class="line">|	<span class="number">1100</span>	<span class="comment">//12的二进制补码形式</span></span><br><span class="line">--------------------</span><br><span class="line">	<span class="number">1111</span>	<span class="comment">//15, 相同位数依次运算,遇1返回1,故最终结果为4个1.</span></span><br></pre></td></tr></table></figure>
<p>由上, 3|12的运算结果为15。 实际上，由于按位与(&amp;)运算同位上返回0的要求较为严苛，因此，它是一种趋向增大最小值的运算。对于按位或(|)运算, 满足如下规律：</p>
<ol>
<li><strong>数值与自身按位或运算返回数值自身</strong></li>
<li><strong>2的整数次方的值与它的相对数按位或运算返回它的相对数</strong></li>
<li><strong>任意整数与0进行按位或运算, 都将会返回它本身</strong></li>
<li><strong>任意整数与-1进行按位或运算, 都将返回-1</strong></li>
<li><strong>按位或运算的结果不小于两数中的最小值</strong></li>
</ol>
<p>利用公式1，可以将非整数取整。即 <strong>x|0 === Math.trunc(x)</strong> 如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">5.2</span>|<span class="number">0</span>);<span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-5.2</span>|<span class="number">0</span>);<span class="comment">//-5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="number">-5.2</span>)===(<span class="number">-5.2</span>|<span class="number">0</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>为什么 5.2|0 运算后会返回5呢？这是因为浮点数并不支持位运算，运算前，5.2会转换为整数5再和0进行位运算，故最终返回5</p>
<h4 id="按位非"><a href="#按位非" class="headerlink" title="按位非(~)"></a>按位非(~)</h4><p>~运算符，返回数值二进制补码形式的反码。什么意思呢， 就是说一个数值二进制补码形式中的每一位都将取反, 如果该位为1，取反为0，如果该位为0，取反为1：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~	<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span>	<span class="comment">//3的32位二进制补码形式</span></span><br><span class="line">--------------------------------------------</span><br><span class="line">	<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1100</span>	<span class="comment">//按位取反后为负数(最高位(第一位)表示正负,1代表负,0代表正)</span></span><br><span class="line">--------------------------------------------</span><br><span class="line">	<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span>	<span class="comment">//负数的二进制转换为十进制时,符号位不变,其它位取反(后+1)</span></span><br><span class="line">	<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0100</span> <span class="comment">// +1</span></span><br><span class="line">--------------------------------------------</span><br><span class="line">                                      <span class="number">-4</span>	 <span class="comment">//最终运算结果为-4</span></span><br></pre></td></tr></table></figure>
<p>实际上，按位非(~)操作不需要这么兴师动众地去计算，它有且仅有一条运算规律：</p>
<ul>
<li><strong>按位非操作一个数值, 等同于这个数值加1然后符号改变. 即: ~x === -x-1</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~<span class="number">5</span> ==&gt; <span class="number">-5</span><span class="number">-1</span> === <span class="number">-6</span>;</span><br><span class="line">~<span class="number">-2016</span> ==&gt; <span class="number">2016</span><span class="number">-1</span> === <span class="number">2015</span>;</span><br></pre></td></tr></table></figure>
<p>由上述公式可推出：<strong>~~x === -(-x-1)-1 === x</strong>。由于位运算摈除小数部分的特性，连续两次按位非也可用于将非整数取整. 即, <strong>~~x === Math.trunc(x)</strong>如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(~~<span class="number">5.2</span>);<span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(~~<span class="number">-5.2</span>);<span class="comment">//-5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="number">-5.2</span>)===(~~<span class="number">-5.2</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>按位非(~)运算符只能用来求数值的反码，并且还不能输出反码的二进制字符串。稍微扩展下，使它变得更易用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waveExtend</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="keyword">typeof</span> item == <span class="string">'number'</span> &amp;&amp; translateBinary(~item);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> s == <span class="string">'string'</span>?s:[].map.call(item,<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v===<span class="string">'-'</span>?v:v^<span class="number">1</span>;</span><br><span class="line">  &#125;).join(<span class="string">''</span>).replace(<span class="regexp">/^-?/</span>,<span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123;<span class="keyword">return</span> m==<span class="string">''</span>?<span class="string">'-'</span>:<span class="string">''</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">waveExtend(<span class="number">-8</span>);<span class="comment">//111 -8反码,正数省略的位全部为0</span></span><br><span class="line">waveExtend(<span class="number">12</span>);<span class="comment">//-0011 12的反码,负数省略的位全部为1</span></span><br></pre></td></tr></table></figure>
<p>实际上，按位非(~)运算符要求其运算数为整型，如果运算数不是整型， 它将和其他位运算符一样尝试将其转换为32位整型，如果无法转换，就返回NaN。 那么~NaN等于多少呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">20</span>);&#125;());<span class="comment">//先alert(20),然后输出-1</span></span><br></pre></td></tr></table></figure>
<p>以上语句意在打印一个自执行函数的按位非运算结果。 而该自执行函数又没有显式指定返回值，默认将返回undefined。因此它实际上是在输出~undefined的值。 而undefined值不能转换成整型，通过测试，运算结果为-1(即~NaN === -1)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(~<span class="string">'abc'</span>);<span class="comment">//-1</span></span><br><span class="line"><span class="built_in">console</span>.log(~[]);<span class="comment">//-1</span></span><br><span class="line"><span class="built_in">console</span>.log(~&#123;&#125;);<span class="comment">//-1</span></span><br><span class="line"><span class="built_in">console</span>.log(~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);<span class="comment">//-1</span></span><br><span class="line"><span class="built_in">console</span>.log(~<span class="regexp">/\d/</span>);<span class="comment">//-1</span></span><br><span class="line"><span class="built_in">console</span>.log(~<span class="literal">Infinity</span>);<span class="comment">//-1</span></span><br><span class="line"><span class="built_in">console</span>.log(~<span class="literal">null</span>);<span class="comment">//-1</span></span><br><span class="line"><span class="built_in">console</span>.log(~<span class="literal">undefined</span>);<span class="comment">//-1</span></span><br><span class="line"><span class="built_in">console</span>.log(~<span class="literal">NaN</span>);<span class="comment">//-1</span></span><br></pre></td></tr></table></figure>
<h4 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或(^)"></a>按位异或(^)</h4><p>^运算符连接的两个数，它们二进制补码形式的值每位参与运算，只有相对应的每位值不同，才返回1，否则返回0<br>(相同则消去, 有些类似两两消失的消消乐) 如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	<span class="number">0011</span>	<span class="comment">//3的二进制补码形式</span></span><br><span class="line">^	<span class="number">1000</span>	<span class="comment">//8的二进制补码形式</span></span><br><span class="line">--------------------</span><br><span class="line">	<span class="number">1011</span>	<span class="comment">//11, 相同位数依次运算, 值不同的返回1</span></span><br></pre></td></tr></table></figure>
<p>对于按位异或(^)操作，满足如下规律：</p>
<ol>
<li><strong>由于按位异或位运算的特殊性， 数值与自身按位异或运算返回0</strong>。如: <code>8^8=0</code> , 公式为 <code>a^a=0</code> </li>
<li><strong>任意整数与0进行按位异或运算， 都将会返回它本身</strong>。 如: <code>0^-98=-98</code> , 公式为 <code>0^a=a</code></li>
<li><strong>任意整数x与1(2的0次方)进行按位异或运算，若它为奇数, 则返回 x-1，若它为偶数, 则返回 x+1 </strong>。如: <code>1^-9=-10</code> , <code>1^100=101</code> 。公式为 <code>1^奇=奇-1</code> ， <code>1^偶=偶+1</code> ： 推而广之，<strong>任意整数x与2的n次方进行按位异或运算， 若它的二进制补码形式的倒数第n+1位是1，则返回 x-2的n次方，反之若为0，则返回 x+2的n次方 </strong></li>
<li><strong>任意整数x与-1(负2的1次方+1)进行按位异或运算，则将返回 -x-1，相当于~x运算 </strong>。如: <code>-1^100=-101</code> ，<code>-1^-9=8</code> 。公式为 <code>-1^x=-x-1=~x</code> </li>
<li><strong>任意整数连续按位异或两次相同的数值，返回它本身</strong>。如: <code>3^8^8=3</code> ， 公式为 <code>a^b^b=a</code> 或 <code>a^b^a=b</code> </li>
<li><strong>按位异或满足操作数与运算结果3个数值之间的交换律：按位异或的两个数值，以及他们运算的结果，共三个数值可以两两异或得到另外一个数值</strong> 。 如: <code>3^9=10</code> , <code>3^10=9</code> , <code>9^10=3</code> ; 公式为 <code>a^b=c</code> , <code>a^c=b</code> , <code>b^c=a</code> </li>
</ol>
<p>以上公式中，1, 2, 3和4都是由按位异或运算特性推出的，公式5可由公式1和2推出，公式6可由公式5推出</p>
<p>由于按位异或运算的这种可交换的性质，可用它辅助交换两个整数的值。 如下， 假设这两个值为a和b：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line"><span class="comment">//常规方法</span></span><br><span class="line"><span class="keyword">var</span> tmp = a;</span><br><span class="line">a=b;</span><br><span class="line">b=tmp;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);<span class="comment">//2 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用按位异或~的方法</span></span><br><span class="line">a=a^b;	<span class="comment">//假设a,b的原始值分别为a0,b0</span></span><br><span class="line">b=a^b;	<span class="comment">//等价于 b=a0^b0^b0 ==&gt; b=a0</span></span><br><span class="line">a=a^b;	<span class="comment">//等价于 a=a0^b0^a0 ==&gt; a=b0</span></span><br><span class="line"><span class="built_in">console</span>.log(a,b);<span class="comment">//2 1</span></span><br><span class="line"><span class="comment">//以上可简写为</span></span><br><span class="line">a^=b;b^=a;a^=b;</span><br></pre></td></tr></table></figure>
<h4 id="位运算小结"><a href="#位运算小结" class="headerlink" title="位运算小结"></a>位运算小结</h4><p>由上可以看出：</p>
<ul>
<li>由于连接两个数值的位运算均是对相同的位进行比较操作， 故运算数值的先后位置并不重要，这些位运算(&amp; | ^)满足交换律。即: <code>a操作符b === b操作符a</code></li>
<li>位运算中，数字0和1都比较特殊。记住它们的规律，常可简化运算</li>
<li>位运算(&amp;|~^)可用于取整，同 Math.trunc()</li>
</ul>
<h4 id="有符号左移-lt-lt"><a href="#有符号左移-lt-lt" class="headerlink" title="有符号左移(&lt;&lt;)"></a>有符号左移(&lt;&lt;)</h4><p>&lt;&lt;运算符, 表示将数值的32位二进制补码形式的除符号位之外的其他位都往左移动若干位数。当x为整数时，有：<code>x&lt;&lt;n === x*Math.pow(2,n)</code> 如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);<span class="comment">//8</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">100</span>&lt;&lt;<span class="number">4</span>);<span class="comment">//1600</span></span><br></pre></td></tr></table></figure>
<p>如此，Math.pow(2,n) 便可简写为 1&lt;&lt;n</p>
<p><strong>运算符之一为NaN</strong></p>
<p>对于表达式 <code>x&lt;&lt;n</code>，<strong>当运算数x无法被转换为整数时，运算结果为0</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;&#125;&lt;&lt;<span class="number">3</span>);<span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>&lt;&lt;<span class="number">2</span>);<span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p><strong>当运算数n无法被转换为整数时，运算结果为x.</strong> 相当于 <code>x&lt;&lt;0</code> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>&lt;&lt;<span class="literal">NaN</span>);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p><strong>当运算数x和n均无法被转换为整数时，运算结果为0</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>&lt;&lt;<span class="literal">NaN</span>);<span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<h4 id="有符号右移-gt-gt"><a href="#有符号右移-gt-gt" class="headerlink" title="有符号右移(&gt;&gt;)"></a>有符号右移(&gt;&gt;)</h4><p>>&gt;运算符，除了方向向右，其他同&lt;&lt;运算符。当x为整数时，有： <code>x&gt;&gt;n === Math.floor(x*Math.pow(2,-n))</code> 。 如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">-5</span>&gt;&gt;<span class="number">2</span>);<span class="comment">//-2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-7</span>&gt;&gt;<span class="number">3</span>);<span class="comment">//-1</span></span><br></pre></td></tr></table></figure>
<p>右移负整数时，返回值最大为-1</p>
<p>右移正整数时，返回值最小为0</p>
<h4 id="无符号右移-gt-gt-gt"><a href="#无符号右移-gt-gt-gt" class="headerlink" title="无符号右移(&gt;&gt;&gt;)"></a>无符号右移(&gt;&gt;&gt;)</h4><p>>&gt;&gt;运算符，表示连同符号也一起右移</p>
<p>注意：无符号右移(&gt;&gt;&gt;)会把负数的二进制码当成正数的二进制码。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">-8</span>&gt;&gt;&gt;<span class="number">5</span>);<span class="comment">//134217727</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-1</span>&gt;&gt;&gt;<span class="number">0</span>);<span class="comment">//4294967295</span></span><br></pre></td></tr></table></figure>
<p>以上， 虽然-1没有发生向右位移，但是-1的二进制码，已经变成了正数的二进制码。回顾下这个过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">translateAry(<span class="number">-1</span>);<span class="comment">//-1,补全-1的二进制码至32位: 11111111111111111111111111111111</span></span><br><span class="line">translateAry(<span class="string">'11111111111111111111111111111111'</span>);<span class="comment">//4294967295</span></span><br></pre></td></tr></table></figure>
<p>可见，-1的二进制原码本就是32个1，将这32个1当正数的二进制处理，直接还原成十进制， 刚好就是 4294967295</p>
<p>由此， 使用 &gt;&gt;&gt;运算符， 即使是右移0位，对于负数而言也是翻天覆地的变化。但是对于正数却没有改变。利用这个特性，可以判断数值的正负。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSymbol</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num === (num&gt;&gt;&gt;<span class="number">0</span>)?<span class="string">"正数"</span>:<span class="string">"负数"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getSymbol(<span class="number">-100</span>), getSymbol(<span class="number">123</span>));<span class="comment">//负数 正数</span></span><br></pre></td></tr></table></figure>
<h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><table>
<thead>
<tr>
<th style="text-align:center">优先级</th>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">后置++ , 后置– , [] , () 或 .</td>
<td style="text-align:center">后置++,后置–,数组下标,括号 或 属性选择</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">- , 前置++ , 前置– , ! 或 ~</td>
<td style="text-align:center">负号,前置++,前置–, 逻辑非 或 按位非</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">**(ES7新增)</td>
<td style="text-align:center">幂运算</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">* , / 或 %</td>
<td style="text-align:center">乘 , 除 或 取模</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">+ 或 -</td>
<td style="text-align:center">加 或 减</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">&lt;&lt; 或 &gt;&gt;</td>
<td style="text-align:center">左移 或 右移</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">&gt; , &gt;= , &lt; 或 &lt;=</td>
<td style="text-align:center">大于, 大于等于, 小于 或 小于等于</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">== 或 !=</td>
<td style="text-align:center">等于 或 不等于</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">按位与</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">^</td>
<td style="text-align:center">按位异或</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">或</td>
<td style="text-align:center">按位或</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">逻辑与</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">逻辑或</td>
<td style="text-align:center">逻辑或</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">?:</td>
<td style="text-align:center">条件运算符</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">=,/=,*=,%=,+=,-=,&lt;&lt;=,&gt;&gt;=,&amp;=,^=,按位或后赋值</td>
<td style="text-align:center">各种运算后赋值</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">,</td>
<td style="text-align:center">逗号</td>
</tr>
</tbody>
</table>
<p>① 除了按位非(~)以外，其他的位运算符的优先级都是低于+-运算符的；② 按位与(&amp;)，按位异或(^) 或 按位或(|) 的运算优先级均低于比较运算符(&gt;,&lt;,=等)；③位运算符中按位或(|)优先级最低</p>
<h3 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h3><p><strong>计算绝对值</strong></p>
<p>使用有符号右移(&gt;&gt;)运算符，以及按位异或(^)运算符，可以实现一个 Math.abs方法。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = num&gt;&gt;<span class="number">31</span>,	<span class="comment">//保留32二进制中的符号位,根据num的正负性分别返回0或-1</span></span><br><span class="line">      y = num^x;	<span class="comment">//返回正数,且利用按位异或中的公式2,若num为正数,num^0则返回num本身;若num为负数,则相当于num^-1,利用公式4, 此时返回-num-1</span></span><br><span class="line">  <span class="keyword">return</span> y-x;		<span class="comment">//若num为正数,则返回num-0即num;若num为负数则返回-num-1-(-1)即|num|</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>比较两数是否符号相同</strong></p>
<p>通常，比较两个数是否符号相同，使用x*y&gt;0 来判断即可。 但如果利用按位异或(^)，运算速度将更快</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">-17</span> ^ <span class="number">9</span> &gt; <span class="number">0</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p><strong>对2的n次方取模(n为正整数)</strong></p>
<p>比如 123%8，实际上就是求一个余数，并且这个余数还不大于8，最大为7。 然后剩下的就是比较二进制值里，123与7有几成相似了。 便不难推出公式: <code>x%(1&lt;&lt;n)==x&amp;(1&lt;&lt;n)-1</code> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span>%<span class="number">8</span>);<span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span>&amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>)<span class="number">-1</span>);<span class="comment">//3 , 为什么-1时不用括号括起来, 这是因为-优先级高于&amp;</span></span><br></pre></td></tr></table></figure>
<p><strong>统计正数二进制值中1的个数</strong></p>
<p>不妨先判断n的奇偶性，为奇数时计数器增加1，然后将n右移一位，重复上面步骤，直到递归退出</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTotalForOne</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> n?(n&amp;<span class="number">1</span>)+<span class="built_in">arguments</span>.callee(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">getTotalForOne(<span class="number">9</span>);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<h2 id="JavaScript-Date"><a href="#JavaScript-Date" class="headerlink" title="JavaScript Date"></a>JavaScript Date</h2><p><code>Date</code>对象是JavaScript提供的日期和时间的操作接口。它可以表示的时间范围是，1970年1月1日00:00:00前后的各1亿天（单位为毫秒）</p>
<p><code>Date</code>对象可以作为普通函数直接调用，返回一个代表当前时间的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>()</span><br><span class="line"><span class="comment">// "Tue Dec 01 2015 09:34:43 GMT+0800 (CST)"</span></span><br></pre></td></tr></table></figure>
<p>注意，即使带有参数，<code>Date</code>作为普通函数使用时，返回的还是当前时间</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// "Tue Dec 01 2015 09:34:43 GMT+0800 (CST)"</span></span><br></pre></td></tr></table></figure>
<p>上面代码说明，无论有没有参数，直接调用<code>Date</code>总是返回当前时间</p>
<h3 id="new-Date"><a href="#new-Date" class="headerlink" title="new Date()"></a>new Date()</h3><p><code>Date</code>还可以当作构造函数使用。对它使用<code>new</code>命令，会返回一个<code>Date</code>对象的实例。如果不加参数，生成的就是代表当前时间的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure>
<p>这个<code>Date</code>实例对应的字符串值，就是当前时间</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">today</span><br><span class="line"><span class="comment">// "Tue Dec 01 2017 09:34:43 GMT+0800 (CST)"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">today.toString()</span><br><span class="line"><span class="comment">// "Tue Dec 01 2017 09:34:43 GMT+0800 (CST)"</span></span><br></pre></td></tr></table></figure>
<p>作为构造函数时，<code>Date</code>对象可以接受多种格式的参数</p>
<p><strong>（1）new Date(milliseconds)</strong></p>
<p><code>Date</code>对象接受从1970年1月1日00:00:00 UTC开始计算的毫秒数作为参数。这意味着如果将Unix时间戳（单位为秒）作为参数，必须将Unix时间戳乘以1000</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1378218728000</span>)</span><br><span class="line"><span class="comment">// Tue Sep 03 2013 22:32:08 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1970年1月2日的零时</span></span><br><span class="line"><span class="keyword">var</span> Jan02_1970 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">3600</span> * <span class="number">24</span> * <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// Fri Jan 02 1970 08:00:00 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1969年12月31日的零时</span></span><br><span class="line"><span class="keyword">var</span> Dec31_1969 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">-3600</span> * <span class="number">24</span> * <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// Wed Dec 31 1969 08:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p>上面最后一个例子说明，Date构造函数的参数可以是一个负数，表示1970年1月1日之前的时间</p>
<p><strong>（2）new Date(datestring)</strong></p>
<p>Date对象还接受一个日期字符串作为参数，返回所对应的时间</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'January 6, 2013'</span>);</span><br><span class="line"><span class="comment">// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p>日期字符串的完整格式是“month day, year hours:minutes:seconds”，比如“December 25, 1995 13:30:00”。如果省略了小时、分钟或秒数，这些值会被设为0</p>
<p>但是，其他格式的日期字符串，也可以被解析。事实上，所有可以被<code>Date.parse()</code>方法解析的日期字符串，都可以当作<code>Date</code>对象的参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2013-2-15'</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2013/2/15'</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'02/15/2013'</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2013-FEB-15'</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'FEB, 15, 2013'</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'FEB 15, 2013'</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'Feberuary, 15, 2013'</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'Feberuary 15, 2013'</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'15 Feb 2013'</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'15, Feberuary, 2013'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fri Feb 15 2013 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p>上面多种日期字符串的写法，返回的都是同一个时间</p>
<p>注意，在ES5之中，如果日期采用连词线（<code>-</code>）格式分隔，且具有前导0，JavaScript会认为这是一个ISO格式的日期字符串，导致返回的时间是以UTC时区计算的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2014-01-01'</span>)</span><br><span class="line"><span class="comment">// Wed Jan 01 2014 08:00:00 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2014-1-1'</span>)</span><br><span class="line"><span class="comment">// Wed Jan 01 2014 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，日期字符串有没有前导0，返回的结果是不一样的。如果没有前导0，JavaScript引擎假设用户处于本地时区，所以本例返回0点0分。如果有前导0（即如果你以ISO格式表示日期），就假设用户处于格林尼治国际标准时的时区，所以返回8点0分。但是，ES6改变了这种做法，规定凡是没有指定时区的日期字符串，一律认定用户处于本地时区</p>
<p>总之，对于<code>YYYY-MM-DD</code>形式的字符串，JavaScript引擎可能会将其当作ISO格式来解析，采用格林尼治时区作为计时标准；而对于其他格式的日期字符串，一律视为非ISO格式，采用本地时区作为计时标准</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2014-12-11'</span>)</span><br><span class="line"><span class="comment">// Thu Dec 11 2014 08:00:00 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2014/12/11'</span>)</span><br><span class="line"><span class="comment">// Thu Dec 11 2014 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个日期字符串是ISO格式，第二个不是，导致生成的时间不一样</p>
<p><strong>（3）new Date(year, month [, day, hours, minutes, seconds, ms])</strong></p>
<p>Date对象还可以接受多个整数作为参数，依次表示年、月、日、小时、分钟、秒和毫秒。如果采用这种格式，最少需要提供两个参数（年和月），其他参数都是可选的，默认等于0。因为如果只使用“年”这一个参数，Date对象会将其解释为毫秒数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>)</span><br><span class="line"><span class="comment">// Thu Jan 01 1970 08:00:02 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，2013被解释为毫秒数，而不是年份</p>
<p>各个参数的取值范围如下：</p>
<ul>
<li>year：四位年份，如果写成两位数，则加上1900</li>
<li>month：表示月份，0表示一月，11表示12月</li>
<li>date：表示日期，1到31</li>
<li>hour：表示小时，0到23</li>
<li>minute：表示分钟，0到59</li>
<li>second：表示秒钟，0到59</li>
<li>ms：表示毫秒，0到999</li>
</ul>
<p>注意，月份从0开始计算，但是，天数从1开始计算。另外，除了日期默认为1，小时、分钟、秒钟和毫秒默认都是0</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p>上面代码返回的是2013年1月1日零点的时间</p>
<p>这些参数如果超出了正常范围，会被自动折算。比如，如果月设为15，就折算为下一年的4月</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">15</span>)</span><br><span class="line"><span class="comment">// Tue Apr 01 2014 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// Mon Dec 31 2012 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p>参数还可以使用负数，表示扣去的时间</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">// Sat Dec 01 2012 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">// Sun Dec 30 2012 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p>上面代码分别对月和日使用了负数，表示从基准日扣去相应的时间</p>
<p>年份如果是0到99，会自动加上1900。比如，0表示1900年，1表示1901年；如果为负数，则表示公元前</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// Mon Jan 01 1900 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// Tue Jan 01 1901 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// Fri Jan 01 -1 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<h3 id="日期的运算"><a href="#日期的运算" class="headerlink" title="日期的运算"></a>日期的运算</h3><p>类型转换时，Date对象的实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。所以，两个日期对象进行减法运算，返回的就是它们间隔的毫秒数；进行加法运算，返回的就是连接后的两个字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> d2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d2 - d1</span><br><span class="line"><span class="comment">// 2678400000</span></span><br><span class="line"></span><br><span class="line">d2 + d1</span><br><span class="line"><span class="comment">// "Sat Apr 01 2000 00:00:00 GMT+0800 (CST)Wed Mar 01 2000 00:00:00 GMT+0800 (CST)"</span></span><br></pre></td></tr></table></figure>
<h3 id="Date对象的静态方法"><a href="#Date对象的静态方法" class="headerlink" title="Date对象的静态方法"></a>Date对象的静态方法</h3><h4 id="Date-now"><a href="#Date-now" class="headerlink" title="Date.now()"></a>Date.now()</h4><p><code>Date.now</code>方法返回当前距离1970年1月1日 00:00:00 UTC的毫秒数（Unix时间戳乘以1000）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>.now() <span class="comment">// 1364026285194</span></span><br></pre></td></tr></table></figure>
<p>如果需要比毫秒更精确的时间，可以使用<code>window.performance.now()</code>。它提供页面加载到命令运行时的已经过去的时间，可以精确到千分之一毫秒</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.performance.now() <span class="comment">// 21311140.415</span></span><br></pre></td></tr></table></figure>
<h4 id="Date-parse"><a href="#Date-parse" class="headerlink" title="Date.parse()"></a>Date.parse()</h4><p><code>Date.parse</code>方法用来解析日期字符串，返回距离1970年1月1日 00:00:00的毫秒数</p>
<p>标准的日期字符串的格式，应该完全或者部分符合RFC 2822和ISO 8061，即<code>YYYY-MM-DDTHH:mm:ss.sssZ</code>格式，其中最后的<code>Z</code>表示时区。但是，其他格式也可以被解析，请看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>.parse(<span class="string">'Aug 9, 1995'</span>)</span><br><span class="line"><span class="comment">// 返回807897600000，以下省略返回值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>.parse(<span class="string">'January 26, 2011 13:51:50'</span>)</span><br><span class="line"><span class="built_in">Date</span>.parse(<span class="string">'Mon, 25 Dec 1995 13:30:00 GMT'</span>)</span><br><span class="line"><span class="built_in">Date</span>.parse(<span class="string">'Mon, 25 Dec 1995 13:30:00 +0430'</span>)</span><br><span class="line"><span class="built_in">Date</span>.parse(<span class="string">'2011-10-10'</span>)</span><br><span class="line"><span class="built_in">Date</span>.parse(<span class="string">'2011-10-10T14:48:00'</span>)</span><br></pre></td></tr></table></figure>
<p>如果解析失败，返回<code>NaN</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>.parse(<span class="string">'xxx'</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<h4 id="Date-UTC"><a href="#Date-UTC" class="headerlink" title="Date.UTC()"></a>Date.UTC()</h4><p>默认情况下，Date对象返回的都是当前时区的时间。<code>Date.UTC</code>方法可以返回UTC时间（世界标准时间）。该方法接受年、月、日等变量作为参数，返回当前距离1970年1月1日 00:00:00 UTC的毫秒数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line"><span class="built_in">Date</span>.UTC(year, month[, date[, hrs[, min[, sec[, ms]]]]])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="built_in">Date</span>.UTC(<span class="number">2011</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">567</span>)</span><br><span class="line"><span class="comment">// 1293847384567</span></span><br></pre></td></tr></table></figure>
<p>该方法的参数用法与<code>Date</code>构造函数完全一致，比如月从0开始计算，日期从1开始计算</p>
<h3 id="Date实例对象的方法"><a href="#Date实例对象的方法" class="headerlink" title="Date实例对象的方法"></a>Date实例对象的方法</h3><p><code>Date</code>的实例对象，有几十个自己的方法，分为以下三类</p>
<ul>
<li><code>to</code>类：从<code>Date</code>对象返回一个字符串，表示指定的时间</li>
<li><code>get</code>类：获取<code>Date</code>对象的日期和时间</li>
<li><code>set</code>类：设置<code>Date</code>对象的日期和时间</li>
</ul>
<h4 id="to类方法"><a href="#to类方法" class="headerlink" title="to类方法"></a>to类方法</h4><p><strong>（1）Date.prototype.toString()</strong></p>
<p><code>toString</code>方法返回一个完整的日期字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d.toString()</span><br><span class="line"><span class="comment">// "Tue Jan 01 2013 00:00:00 GMT+0800 (CST)"</span></span><br><span class="line"></span><br><span class="line">d</span><br><span class="line"><span class="comment">// "Tue Jan 01 2013 00:00:00 GMT+0800 (CST)"</span></span><br></pre></td></tr></table></figure>
<p>因为<code>toString</code>是默认的调用方法，所以如果直接读取Date对象实例，就相当于调用这个方法</p>
<p><strong>（2）Date.prototype.toUTCString()</strong></p>
<p><code>toUTCString</code>方法返回对应的UTC时间，也就是比北京时间晚8个小时</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d.toUTCString()</span><br><span class="line"><span class="comment">// "Mon, 31 Dec 2012 16:00:00 GMT"</span></span><br><span class="line"></span><br><span class="line">d.toString()</span><br><span class="line"><span class="comment">// "Tue Jan 01 2013 00:00:00 GMT+0800 (CST)"</span></span><br></pre></td></tr></table></figure>
<p><strong>（3）Date.prototype.toISOString()</strong></p>
<p><code>toISOString</code>方法返回对应时间的ISO8601写法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d.toString()</span><br><span class="line"><span class="comment">// "Tue Jan 01 2013 00:00:00 GMT+0800 (CST)"</span></span><br><span class="line"></span><br><span class="line">d.toISOString()</span><br><span class="line"><span class="comment">// "2012-12-31T16:00:00.000Z"</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>toISOString</code>方法返回的总是UTC时区的时间</p>
<p><strong>（4）Date.prototype.toJSON()</strong></p>
<p><code>toJSON</code>方法返回一个符合JSON格式的ISO格式的日期字符串，与<code>toISOString</code>方法的返回结果完全相同</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d.toJSON()</span><br><span class="line"><span class="comment">// "2012-12-31T16:00:00.000Z"</span></span><br><span class="line"></span><br><span class="line">d.toISOString()</span><br><span class="line"><span class="comment">// "2012-12-31T16:00:00.000Z"</span></span><br></pre></td></tr></table></figure>
<p><strong>（5）Date.prototype.toDateString()</strong></p>
<p><code>toDateString</code>方法返回日期字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">d.toDateString() <span class="comment">// "Tue Jan 01 2013"</span></span><br></pre></td></tr></table></figure>
<p><strong>（6）Date.prototype.toTimeString()</strong></p>
<p><code>toTimeString</code>方法返回时间字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">d.toTimeString() <span class="comment">// "00:00:00 GMT+0800 (CST)"</span></span><br></pre></td></tr></table></figure>
<p><strong>（7）Date.prototype.toLocaleDateString()</strong></p>
<p><code>toLocaleDateString</code>方法返回一个字符串，代表日期的当地写法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">d.toLocaleDateString()</span><br><span class="line"><span class="comment">// 中文版浏览器为"2013年1月1日"</span></span><br><span class="line"><span class="comment">// 英文版浏览器为"1/1/2013"</span></span><br></pre></td></tr></table></figure>
<p><strong>（8）Date.prototype.toLocaleTimeString()</strong></p>
<p><code>toLocaleTimeString</code>方法返回一个字符串，代表时间的当地写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(2013, 0, 1);</span><br><span class="line"></span><br><span class="line">d.toLocaleTimeString()</span><br><span class="line">// 中文版浏览器为&quot;上午12:00:00&quot;</span><br><span class="line">// 英文版浏览器为&quot;12:00:00 AM&quot;</span><br></pre></td></tr></table></figure>
<h4 id="get类方法"><a href="#get类方法" class="headerlink" title="get类方法"></a>get类方法</h4><p>Date对象提供了一系列<code>get*</code>方法，用来获取实例对象某个方面的值：</p>
<blockquote>
<ul>
<li><code>getTime()</code>：返回距离1970年1月1日00:00:00的毫秒数，等同于<code>valueOf</code>方法</li>
<li><code>getDate()</code>：返回实例对象对应每个月的几号（从1开始）</li>
<li><code>getDay()</code>：返回星期几，星期日为0，星期一为1，以此类推</li>
<li><code>getYear()</code>：返回距离1900的年数</li>
<li><code>getFullYear()</code>：返回四位的年份</li>
<li><code>getMonth()</code>：返回月份（0表示1月，11表示12月）</li>
<li><code>getHours()</code>：返回小时（0-23）</li>
<li><code>getMilliseconds()</code>：返回毫秒（0-999）</li>
<li><code>getMinutes()</code>：返回分钟（0-59）</li>
<li><code>getSeconds()</code>：返回秒（0-59）</li>
<li><code>getTimezoneOffset()</code>：返回当前时间与UTC的时区差异，以分钟表示，返回结果考虑到了夏令时因素</li>
</ul>
</blockquote>
<p>所有这些<code>get*</code>方法返回的都是整数，不同方法返回值的范围不一样：</p>
<blockquote>
<ul>
<li>分钟和秒：0 到 59</li>
<li>小时：0 到 23</li>
<li>星期：0（星期天）到 6（星期六）</li>
<li>日期：1 到 31</li>
<li>月份：0（一月）到 11（十二月）</li>
<li>年份：距离1900年的年数</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'January 6, 2013'</span>);</span><br><span class="line"></span><br><span class="line">d.getDate() <span class="comment">// 6</span></span><br><span class="line">d.getMonth() <span class="comment">// 0</span></span><br><span class="line">d.getYear() <span class="comment">// 113</span></span><br><span class="line">d.getFullYear() <span class="comment">// 2013</span></span><br><span class="line">d.getTimezoneOffset() <span class="comment">// -480</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，最后一行返回<code>-480</code>，表示UTC比当前时间晚480分钟，即8个小时</p>
<p>下面是一个例子，计算本年度还剩下多少天</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leftDays</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">var</span> endYear = <span class="keyword">new</span> <span class="built_in">Date</span>(today.getFullYear(), <span class="number">11</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999</span>);</span><br><span class="line">  <span class="keyword">var</span> msPerDay = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.round((endYear.getTime() - today.getTime()) / msPerDay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这些<code>get*</code>方法返回的都是当前时区的时间</p>
<p><code>Date</code>对象还提供了这些方法对应的UTC版本，用来返回UTC时间：</p>
<blockquote>
<ul>
<li><code>getUTCDate()</code></li>
<li><code>getUTCFullYear()</code></li>
<li><code>getUTCMonth()</code></li>
<li><code>getUTCDay()</code></li>
<li><code>getUTCHours()</code></li>
<li><code>getUTCMinutes()</code></li>
<li><code>getUTCSeconds()</code></li>
<li><code>getUTCMilliseconds()</code></li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'January 6, 2013'</span>);</span><br><span class="line"></span><br><span class="line">d.getDate() <span class="comment">// 6</span></span><br><span class="line">d.getUTCDate() <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，实例对象<code>d</code>表示当前时区（东八时区）的1月6日0点0分0秒，这个时间对于当前时区来说是1月6日，所以<code>getDate</code>方法返回6，对于UTC时区来说是1月5日，所以<code>getUTCDate</code>方法返回5</p>
<h4 id="set类方法"><a href="#set类方法" class="headerlink" title="set类方法"></a>set类方法</h4><p>Date对象提供了一系列<code>set*</code>方法，用来设置实例对象的各个方面：</p>
<blockquote>
<ul>
<li><code>setDate(date)</code>：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳</li>
<li><code>setYear(year)</code>: 设置距离1900年的年数</li>
<li><code>setFullYear(year [, month, date])</code>：设置四位年份</li>
<li><code>setHours(hour [, min, sec, ms])</code>：设置小时（0-23）</li>
<li><code>setMilliseconds()</code>：设置毫秒（0-999）</li>
<li><code>setMinutes(min [, sec, ms])</code>：设置分钟（0-59）</li>
<li><code>setMonth(month [, date])</code>：设置月份（0-11）</li>
<li><code>setSeconds(sec [, ms])</code>：设置秒（0-59）</li>
<li><code>setTime(milliseconds)</code>：设置毫秒时间戳</li>
</ul>
</blockquote>
<p>这些方法基本是跟<code>get*</code>方法一一对应的，但是没有<code>setDay</code>方法，因为星期几是计算出来的，而不是设置的。另外，需要注意的是，凡是涉及到设置月份，都是从0开始算的，即<code>0</code>是1月，<code>11</code>是12月</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span> (<span class="string">'January 6, 2013'</span>);</span><br><span class="line"></span><br><span class="line">d <span class="comment">// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line">d.setDate(<span class="number">9</span>) <span class="comment">// 1357660800000</span></span><br><span class="line">d <span class="comment">// Wed Jan 09 2013 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p><code>set*</code>方法的参数都会自动折算。以<code>setDate</code>为例，如果参数超过当月的最大天数，则向下一个月顺延，如果参数是负数，表示从上个月的最后一天开始减去的天数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'January 6, 2013'</span>);</span><br><span class="line"></span><br><span class="line">d1.setDate(<span class="number">32</span>) <span class="comment">// 1359648000000</span></span><br><span class="line">d1 <span class="comment">// Fri Feb 01 2013 00:00:00 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d2 = <span class="keyword">new</span> <span class="built_in">Date</span> (<span class="string">'January 6, 2013'</span>);</span><br><span class="line"></span><br><span class="line">d.setDate(<span class="number">-1</span>) <span class="comment">// 1356796800000</span></span><br><span class="line">d <span class="comment">// Sun Dec 30 2012 00:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p><code>set</code>类方法和<code>get</code>类方法，可以结合使用，得到相对时间</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将日期向后推1000天</span></span><br><span class="line">d.setDate( d.getDate() + <span class="number">1000</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将时间设为6小时后</span></span><br><span class="line">d.setHours(d.getHours() + <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将年份设为去年</span></span><br><span class="line">d.setFullYear(d.getFullYear() - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><code>set*</code>系列方法除了<code>setTime()</code>和<code>setYear()</code>，都有对应的UTC版本，即设置UTC时区的时间：</p>
<blockquote>
<ul>
<li><code>setUTCDate()</code></li>
<li><code>setUTCFullYear()</code></li>
<li><code>setUTCHours()</code></li>
<li><code>setUTCMilliseconds()</code></li>
<li><code>setUTCMinutes()</code></li>
<li><code>setUTCMonth()</code></li>
<li><code>setUTCSeconds()</code></li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'January 6, 2013'</span>);</span><br><span class="line">d.getUTCHours() <span class="comment">// 16</span></span><br><span class="line">d.setUTCHours(<span class="number">22</span>) <span class="comment">// 1357423200000</span></span><br><span class="line">d <span class="comment">// Sun Jan 06 2013 06:00:00 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，本地时区（东八时区）的1月6日0点0分，是UTC时区的前一天下午16点。设为UTC时区的22点以后，就变为本地时区的上午6点</p>
<h4 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h4><p><code>valueOf</code>方法返回实例对象距离1970年1月1日00:00:00 UTC对应的毫秒数，该方法等同于<code>getTime</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">d.valueOf() <span class="comment">// 1362790014817</span></span><br><span class="line">d.getTime() <span class="comment">// 1362790014817</span></span><br></pre></td></tr></table></figure>
<p>该方法可以用于计算精确时间</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">doSomething();</span><br><span class="line"><span class="keyword">var</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> elapsed = end.getTime() - start.getTime();</span><br></pre></td></tr></table></figure>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">JavaScript</a>
        		</li>
      		
		</ul>
	</div>

      

      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-JavaScript Event" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/12/JavaScript Event/">JavaScript Event</a>
    </h1>
  

        
        <a href="/2018/08/12/JavaScript Event/" class="archive-article-date">
  	<time datetime="2018-08-11T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-08-12</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JavaScript-Event"><a href="#JavaScript-Event" class="headerlink" title="JavaScript Event"></a>JavaScript Event</h2><h3 id="Event-Type"><a href="#Event-Type" class="headerlink" title="Event Type"></a>Event Type</h3><h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><p><strong>click 事件，dblclick 事件</strong></p>
<p>当用户在Element节点、<code>document</code>节点、<code>window</code>对象上单击鼠标（或者按下回车键）时，<code>click</code>事件触发</p>
<p>当用户在Element节点、<code>document</code>节点、<code>window</code>对象上双击击鼠标时，<code>dblclick</code>事件触发</p>
<p><strong>mouseup 事件，mousedown 事件，mousemove 事件</strong></p>
<p><code>mouseup</code>事件在释放按下的鼠标键时触发。</p>
<p><code>mousedown</code>事件在按下鼠标键时触发。</p>
<p><code>mousemove</code>事件当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发</p>
<p><strong>mouseover 事件，mouseenter 事件</strong></p>
<p><code>mouseover</code>事件和<code>mouseenter</code>事件，都是鼠标进入一个节点时触发</p>
<p>两者的区别是，<code>mouseenter</code>事件只触发一次，而只要鼠标在节点内部移动，<code>mouseover</code>事件会在子节点上触发多次</p>
<p><strong>mouseout 事件，mouseleave 事件</strong></p>
<p><code>mouseout</code>事件和<code>mouseleave</code>事件，都是鼠标离开一个节点时触发</p>
<p>两者的区别是，<code>mouseout</code>事件会冒泡，<code>mouseleave</code>事件不会</p>
<p><strong>contextmenu 事件</strong></p>
<p><code>contextmenu</code>事件在一个节点上点击鼠标右键时触发，或者按下“上下文菜单”键时触发</p>
<p><strong>MouseEvent对象</strong></p>
<p>鼠标事件使用<code>MouseEvent</code>对象表示，它继承<code>UIEvent</code>对象和<code>Event</code>对象。浏览器提供一个<code>MouseEvent</code>构造函数<code>new MouseEvent()</code>，用于新建一个<code>MouseEvent</code>实例</p>
<p><code>MouseEvent</code>构造函数的第一个参数是事件名称（可能的值包括<code>click</code>、<code>mousedown</code>、<code>mouseup</code>、<code>mouseover</code>、<code>mousemove</code>、<code>mouseout</code>），第二个参数是一个事件初始化对象。该对象可以配置以下属性：</p>
<blockquote>
<ul>
<li>screenX，设置鼠标相对于屏幕的水平坐标（但不会移动鼠标），默认为0，等同于MouseEvent.screenX属性</li>
<li>screenY，设置鼠标相对于屏幕的垂直坐标，默认为0，等同于MouseEvent.screenY属性</li>
<li>clientX，设置鼠标相对于窗口的水平坐标，默认为0，等同于MouseEvent.clientX属性</li>
<li>clientY，设置鼠标相对于窗口的垂直坐标，默认为0，等同于MouseEvent.clientY属性</li>
<li>pageX，设置鼠标相对于文档的水平坐标，默认为0，非标准</li>
<li>pageY，设置鼠标相对于文档的垂直坐标，默认为0，非标准</li>
<li>offsetX，设置鼠标相对于源元素的水平坐标，默认为0，非标准</li>
<li>offsetY，设置鼠标相对于源元素的垂直坐标，默认为0，非标准</li>
<li>ctrlKey，设置是否按下ctrl键，默认为false，等同于MouseEvent.ctrlKey属性</li>
<li>shiftKey，设置是否按下shift键，默认为false，等同于MouseEvent.shiftKey属性</li>
<li>altKey，设置是否按下alt键，默认为false，等同于MouseEvent.altKey属性</li>
<li>metaKey，设置是否按下meta键，默认为false，等同于MouseEvent.metaKey属性</li>
<li>button，设置按下了哪一个鼠标按键，默认为0。-1表示没有按键，0表示按下主键（通常是左键），1表示按下辅助键（通常是中间的键），2表示按下次要键（通常是右键）</li>
<li>buttons，设置按下了鼠标哪些键，是一个3个比特位的二进制值，默认为0。1表示按下主键（通常是左键），2表示按下次要键（通常是右键），4表示按下辅助键（通常是中间的键）</li>
<li>relatedTarget，设置一个Element节点，在mouseenter和mouseover事件时，表示鼠标刚刚离开的那个Element节点，在mouseout和mouseleave事件时，表示鼠标正在进入的那个Element节点。默认为null，等同于MouseEvent.relatedTarget属性</li>
<li>bubbles，布尔值，设置事件是否冒泡，默认为false，等同于Event.bubbles属性</li>
<li>cancelable，布尔值，设置事件是否可取消，默认为false，等同于Event.cancelable属性</li>
<li>view，设置事件的视图，一般是window或document.defaultView，等同于Event.view属性</li>
<li>detail，设置鼠标点击的次数，等同于Event.detail属性</li>
</ul>
</blockquote>
<p><strong>altKey，ctrlKey，metaKey，shiftKey</strong></p>
<p>以下属性返回一个布尔值，表示鼠标事件发生时，是否按下某个键：</p>
<blockquote>
<ul>
<li><code>altKey</code>属性：Alt 键</li>
<li><code>ctrlKey</code>属性：Ctrl 键</li>
<li><code>metaKey</code>属性：Meta 键</li>
<li><code>shiftKey</code>属性：Shift 键</li>
</ul>
</blockquote>
<p><strong>button</strong></p>
<p>button属性返回一个数值，表示按下了鼠标哪个键：</p>
<blockquote>
<ul>
<li>-1：没有按下键</li>
<li>0：按下主键（通常是左键）</li>
<li>1：按下辅助键（通常是中键或者滚轮键）</li>
<li>2：按下次键（通常是右键）</li>
</ul>
</blockquote>
<p><strong>buttons</strong></p>
<p>buttons属性返回一个3个比特位的值，表示同时按下了哪些键。它用来处理同时按下多个鼠标键的情况：</p>
<blockquote>
<ul>
<li>1：二进制为001，表示按下左键</li>
<li>2：二进制为010，表示按下右键</li>
<li>4：二进制为100，表示按下中键或滚轮键</li>
</ul>
</blockquote>
<p>同时按下多个键的时候，每个按下的键对应的比特位都会有值。比如，同时按下左键和右键，会返回3（二进制为011）</p>
<p><strong>clientX，clientY</strong></p>
<p>clientX属性返回鼠标位置相对于浏览器窗口左上角的水平坐标，单位为像素，与页面是否横向滚动无关</p>
<p>clientY属性返回鼠标位置相对于浏览器窗口左上角的垂直坐标，单位为像素，与页面是否纵向滚动无关</p>
<p><strong>movementX，movementY</strong></p>
<p>movementX属性返回一个水平位移，单位为像素，表示当前位置与上一个mousemove事件之间的水平距离</p>
<p>movementY属性返回一个垂直位移，单位为像素，表示当前位置与上一个mousemove事件之间的垂直距离</p>
<p><strong>screenX，screenY</strong></p>
<p>screenX属性返回鼠标位置相对于屏幕左上角的水平坐标，单位为像素</p>
<p>screenY属性返回鼠标位置相对于屏幕左上角的垂直坐标，单位为像素</p>
<p><strong>relatedTarget</strong></p>
<p>relatedTarget属性返回事件的次要相关节点。对于那些没有次要相关节点的事件，该属性返回null</p>
<h4 id="滚轮事件"><a href="#滚轮事件" class="headerlink" title="滚轮事件"></a>滚轮事件</h4><p><code>wheel</code>事件是与鼠标滚轮相关的事件，目前只有一个<code>wheel</code>事件。用户滚动鼠标的滚轮，就触发这个事件</p>
<p>该事件除了继承了MouseEvent、UIEvent、Event的属性，还有几个自己的属性：</p>
<blockquote>
<ul>
<li>deltaX：返回一个数值，表示滚轮的水平滚动量</li>
<li>deltaY：返回一个数值，表示滚轮的垂直滚动量</li>
<li>deltaZ：返回一个数值，表示滚轮的Z轴滚动量</li>
<li>deltaMode：返回一个数值，表示滚动的单位，适用于上面三个属性。0表示像素，1表示行，2表示页</li>
</ul>
</blockquote>
<p>浏览器提供一个WheelEvent构造函数<code>new WheelEvent()</code>，可以用来生成滚轮事件的实例。它接受两个参数，第一个是事件名称，第二个是配置对象</p>
<h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><p>键盘事件用来描述键盘行为，主要有keydown、keypress、keyup三个事件：</p>
<blockquote>
<ul>
<li><code>keydown</code>：按下键盘时触发该事件</li>
<li><code>keypress</code>：只要按下的键并非Ctrl、Alt、Shift和Meta，就接着触发keypress事件</li>
<li><code>keyup</code>：松开键盘时触发该事件</li>
</ul>
</blockquote>
<p>如果用户一直按键不松开，就会连续触发键盘事件</p>
<p>键盘事件使用KeyboardEvent对象表示，该对象继承了UIEvent和MouseEvent对象。浏览器提供KeyboardEvent构造函数<code>new KeyboardEvent()</code>，用来新建键盘事件的实例</p>
<p><code>KeyboardEvent</code>构造函数的第一个参数是一个字符串，表示事件类型，第二个参数是一个事件配置对象，可配置以下字段：</p>
<blockquote>
<ul>
<li>key，对应KeyboardEvent.key属性，默认为空字符串</li>
<li>ctrlKey，对应KeyboardEvent.ctrlKey属性，默认为false</li>
<li>shiftKey，对应KeyboardEvent.shiftKey属性，默认为false</li>
<li>altKey，对应KeyboardEvent.altKey属性，默认为false</li>
<li>metaKey，对应KeyboardEvent.metaKey属性，默认为false</li>
</ul>
</blockquote>
<p><strong>key</strong></p>
<p>key属性返回一个字符串，表示按下的键名。如果同时按下一个控制键和一个符号键，则返回符号键的键名。比如，按下Ctrl+a，则返回a。如果无法识别键名，则返回字符串Unidentified</p>
<p><strong>charCode</strong></p>
<p>charCode属性返回一个数值，表示keypress事件按键的Unicode值，keydown和keyup事件不提供这个属性。注意，该属性已经从标准移除，虽然浏览器还支持，但应该尽量不使用</p>
<h4 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h4><p>进度事件用来描述一个事件进展的过程，比如XMLHttpRequest对象发出的HTTP请求的过程、<img>、<audio>、<video>、<style>、<link>加载外部资源的过程。下载和上传都会发生进度事件：</p>
<blockquote>
<ul>
<li><code>abort</code>事件：当进度事件被中止时触发。如果发生错误，导致进程中止，不会触发该事件</li>
<li><code>error</code>事件：由于错误导致资源无法加载时触发</li>
<li><code>load</code>事件：进度成功结束时触发</li>
<li><code>loadstart</code>事件：进度开始时触发</li>
<li><code>loadend</code>事件：进度停止时触发，发生顺序排在error事件\abort事件\load事件后面</li>
<li><code>progress</code>事件：当操作处于进度之中，由传输的数据块不断触发</li>
<li><code>timeout</code>事件：进度超过限时触发</li>
</ul>
</blockquote>
<p>进度事件使用ProgressEvent对象表示，浏览器提供一个ProgressEvent构造函数<code>new ProgressEvent()</code>，用来生成进度事件的实例</p>
<p>ProgressEvent构造函数的第一个参数是事件类型（字符串），第二个参数是配置对象，可配置以下字段：</p>
<blockquote>
<ul>
<li>lengthComputable：返回一个布尔值，表示当前进度是否具有可计算的长度。如果为false，就表示当前进度无法测量</li>
<li>total：返回一个数值，表示当前进度的总长度。如果是通过HTTP下载某个资源，表示内容本身的长度，不含HTTP头部的长度。如果lengthComputable属性为false，则total属性就无法取得正确的值</li>
<li>loaded：返回一个数值，表示当前进度已经完成的数量。该属性除以total属性，就可以得到目前进度的百分比</li>
</ul>
</blockquote>
<h4 id="拖拉事件"><a href="#拖拉事件" class="headerlink" title="拖拉事件"></a>拖拉事件</h4><blockquote>
<ul>
<li><strong>drag事件</strong>：拖拉过程中，在被拖拉的节点上持续触发</li>
<li><strong>dragstart事件</strong>：拖拉开始时在被拖拉的节点上触发，该事件的target属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据</li>
<li><strong>dragend事件</strong>：拖拉结束时（释放鼠标键或按下escape键）在被拖拉的节点上触发，该事件的target属性是被拖拉的节点。它与dragstart事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，dragend事件总是会触发的</li>
<li><strong>dragenter事件</strong>：拖拉进入当前节点时，在当前节点上触发，该事件的target属性是当前节点。通常应该在这个事件的监听函数中，指定是否允许在当前节点放下（drop）拖拉的数据。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置</li>
<li><strong>dragover事件</strong>：拖拉到当前节点上方时，在当前节点上持续触发，该事件的target属性是当前节点。该事件与dragenter事件基本类似，默认会重置当前的拖拉事件的效果（DataTransfer对象的dropEffect属性）为none，即不允许放下被拖拉的节点，所以如果允许在当前节点drop数据，通常会使用preventDefault方法，取消重置拖拉效果为none</li>
<li><strong>dragleave事件</strong>：拖拉离开当前节点范围时，在当前节点上触发，该事件的target属性是当前节点。在视觉上显示拖拉离开当前节点，就在这个事件的监听函数中设置</li>
<li><strong>drop事件</strong>：被拖拉的节点或选中的文本，释放到目标节点时，在目标节点上触发。注意，如果当前节点不允许drop，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下Escape键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理</li>
</ul>
</blockquote>
<h4 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h4><p>触摸引发的事件，有以下几类。可以通过TouchEvent.type属性，查看到底发生的是哪一种事件：</p>
<blockquote>
<ul>
<li><code>touchstart</code>：用户接触触摸屏时触发，它的target属性返回发生触摸的Element节点</li>
<li><code>touchend</code>：用户不再接触触摸屏时（或者移出屏幕边缘时）触发，它的target属性与touchstart事件的target属性是一致的，它的changedTouches属性返回一个TouchList对象，包含所有不再触摸的触摸点（Touch对象）</li>
<li><code>touchmove</code>：用户移动触摸点时触发，它的target属性与touchstart事件的target属性一致。如果触摸的半径、角度、力度发生变化，也会触发该事件</li>
<li><code>touchcancel</code>：触摸点取消时触发，比如在触摸区域跳出一个情态窗口（modal window）、触摸点离开了文档区域（进入浏览器菜单栏区域）、用户放置更多的触摸点（自动取消早先的触摸点）</li>
</ul>
</blockquote>
<p><strong>触摸API由三个对象组成：</strong></p>
<blockquote>
<ul>
<li>Touch</li>
<li>TouchList</li>
<li>TouchEvent</li>
</ul>
</blockquote>
<p><code>Touch</code>对象表示触摸点（一根手指或者一根触摸笔），用来描述触摸动作，包括位置、大小、形状、压力、目标元素等属性。有时，触摸动作由多个触摸点（多根手指或者多根触摸笔）组成，多个触摸点的集合由<code>TouchList</code>对象表示。<code>TouchEvent</code>对象代表由触摸引发的事件，只有触摸屏才会引发这一类事件</p>
<p><strong>Touch对象</strong></p>
<p>Touch对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。它有以下属性：</p>
<blockquote>
<ul>
<li><strong>identifier</strong>：表示Touch实例的独一无二的识别符。它在整个触摸过程中保持不变</li>
<li><strong>screenX，screenY</strong>：分别表示触摸点相对于屏幕左上角的横坐标和纵坐标，与页面是否滚动无关</li>
<li><strong>clientX，clientY</strong>：分别表示触摸点相对于浏览器视口左上角的横坐标和纵坐标，与页面是否滚动无关</li>
<li><strong>pageX，pageY</strong>：分别表示触摸点相对于当前页面左上角的横坐标和纵坐标，包含了页面滚动带来的位移</li>
<li><strong>radiusX，radiusY</strong>：分别返回触摸点周围受到影响的椭圆范围的X轴和Y轴，单位为像素</li>
<li><strong>rotationAngle</strong>：表示触摸区域的椭圆的旋转角度，单位为度数，在0到90度之间</li>
<li><strong>force</strong>：返回一个0到1之间的数值，表示触摸压力。0代表没有压力，1代表硬件所能识别的最大压力</li>
<li><strong>target</strong>：返回一个Element节点，代表触摸发生的那个节点</li>
</ul>
</blockquote>
<p><strong>TouchList对象</strong></p>
<p>TouchList对象是一个类似数组的对象，成员是与某个触摸事件相关的所有触摸点。比如，用户用三根手指触摸，产生的TouchList对象就有三个成员，每根手指对应一个Touch对象</p>
<p>TouchList实例的length属性，返回TouchList对象的成员数量</p>
<p>TouchList实例的identifiedTouch方法和item方法，分别使用id属性和索引值（从0开始）作为参数，取出指定的Touch对象</p>
<p><strong>TouchEvent对象</strong></p>
<p>TouchEvent对象继承Event对象和UIEvent对象，表示触摸引发的事件。除了被继承的属性以外，它还有一些自己的属性：</p>
<blockquote>
<ul>
<li><strong>键盘相关属性</strong>：以下属性（altKey 是否按下alt键、ctrlKey 是否按下ctrl键、metaKey 是否按下meta键、shiftKey 是否按下shift键）都为只读属性，返回一个布尔值，表示触摸的同时，是否按下某个键</li>
<li><strong>changedTouches</strong>：changedTouches属性返回一个TouchList对象，包含了由当前触摸事件引发的所有Touch对象（即相关的触摸点）。对于touchstart事件，它代表被激活的触摸点；对于touchmove事件，代表发生变化的触摸点；对于touchend事件，代表消失的触摸点（即不再被触碰的点）</li>
<li><strong>targetTouches</strong>：targetTouches属性返回一个TouchList对象，包含了触摸的目标Element节点内部，所有仍然处于活动状态的触摸点</li>
<li><strong>touches</strong>：touches属性返回一个TouchList对象，包含了所有仍然处于活动状态的触摸点</li>
</ul>
</blockquote>
<h4 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h4><p><strong>input事件</strong></p>
<p><code>input</code>事件当<input>、<textarea>的值发生变化时触发。此外，打开contenteditable属性的元素，只要值发生变化，也会触发input事件。input事件的一个特点，就是会连续触发，比如用户每次按下一次按键，就会触发一次input事件</p>
<p><strong>select事件</strong></p>
<p><code>select</code>事件当在<input>、<textarea>中选中文本时触发</p>
<p><strong>search事件</strong></p>
<p><code>search</code>事件在用户向搜索域按下”ENTER（回车）” 按键或点击 type=”search” 的 <input> 元素的 “x(搜索)” 按钮时触发</p>
<p><strong>change事件</strong></p>
<p><code>change</code>事件当<input>、<select>、<textarea>的值发生变化时触发。它与input事件的最大不同，就是不会连续触发，只有当全部修改完成时才会触发，而且input事件必然会引发change事件</p>
<p><strong>reset事件</strong></p>
<p><code>reset</code>事件当表单重置（所有表单成员变回默认值）时触发</p>
<p><strong>submit事件</strong></p>
<p><code>submi</code>t事件当表单数据向服务器提交时触发。注意，submit事件的发生对象是form元素，而不是button元素（即使它的类型是submit），因为提交的是表单，而不是按钮</p>
<h4 id="文档事件"><a href="#文档事件" class="headerlink" title="文档事件"></a>文档事件</h4><p><strong>beforeunload事件</strong></p>
<p><code>beforeunload</code>事件在窗口将要关闭，或者网页（即<code>document</code>对象）将要卸载时触发</p>
<p><strong>unload事件</strong></p>
<p><code>unload</code>事件在窗口关闭或者document对象将要卸载时触发，发生在window、body、frameset等对象上面。它的触发顺序排在beforeunload、pagehide事件后面。unload事件只在页面没有被浏览器缓存时才会触发，换言之，如果通过按下“前进/后退”导致页面卸载，并不会触发unload事件</p>
<p><strong>load事件，error事件</strong></p>
<p><code>load</code>事件在页面加载成功时触发</p>
<p><code>error</code>事件在页面加载失败时触发</p>
<p>注意，页面从浏览器缓存加载，并不会触发<code>load</code>事件</p>
<p><strong>pageshow事件</strong></p>
<p><code>pageshow</code>事件在页面加载时触发，包括第一次加载和从缓存加载两种情况</p>
<p>pageshow事件有一个persisted属性，返回一个布尔值。页面第一次加载时，这个属性是false；当页面从缓存加载时，这个属性是true</p>
<p><strong>pagehide事件</strong></p>
<p><code>pagehide</code>事件与pageshow事件类似，当用户通过“前进/后退”按钮，离开当前页面时触发。它与unload事件的区别在于，如果在window对象上定义unload事件的监听函数之后，页面不会保存在缓存中，而使用pagehide事件，页面会保存在缓存中</p>
<p>pagehide事件的event对象有一个persisted属性，将这个属性设为true，就表示页面要保存在缓存中；设为false，表示网页不保存在缓存中，这时如果设置了unload事件的监听函数，该函数将在pagehide事件后立即运行</p>
<p><strong>DOMContentLoaded事件</strong></p>
<p>当HTML文档下载并解析完成以后，就会在document对象上触发<code>DOMContentLoaded</code>事件</p>
<p><strong>readystatechange事件</strong></p>
<p><code>readystatechange</code>事件发生在Document对象和XMLHttpRequest对象，当它们的readyState属性发生变化时触发</p>
<p><strong>scroll事件</strong></p>
<p><code>scroll</code>事件在文档或文档元素滚动时触发，主要出现在用户拖动滚动条</p>
<p><strong>resize事件</strong></p>
<p><code>resize</code>事件在改变浏览器窗口大小时触发，发生在window、body、frameset对象上面</p>
<p><strong>hashchange事件</strong></p>
<p><code>hashchange</code>事件在URL的hash部分（即#号后面的部分，包括#号）发生变化时触发</p>
<p><strong>popstate事件</strong></p>
<p><code>popstate</code>事件在浏览器的history对象的当前记录发生显式切换时触发。注意，调用history.pushState()或history.replaceState()，并不会触发popstate事件。该事件只在用户在history记录之间显式切换时触发，比如鼠标点击“后退/前进”按钮，或者在脚本中调用history.back()、history.forward()、history.go()时触发</p>
<p>该事件对象有一个state属性，保存history.pushState方法和history.replaceState方法为当前记录添加的state对象</p>
<p><strong>cut事件，copy事件，paste事件</strong></p>
<blockquote>
<ul>
<li>cut事件：在将选中的内容从文档中移除，加入剪贴板后触发</li>
<li>copy事件：在选中的内容加入剪贴板后触发</li>
<li>paste事件：在剪贴板内容被粘贴到文档后触发</li>
</ul>
</blockquote>
<p><strong>focus事件，blur事件，focusin事件，focusout事件</strong></p>
<blockquote>
<ul>
<li>focus事件：Element节点获得焦点后触发，该事件不会冒泡</li>
<li>blur事件：Element节点失去焦点后触发，该事件不会冒泡</li>
<li>focusin事件：Element节点将要获得焦点时触发，发生在focus事件之前。该事件会冒泡。Firefox不支持该事件</li>
<li>focusout事件：Element节点将要失去焦点时触发，发生在blur事件之前。该事件会冒泡。Firefox不支持该事件</li>
</ul>
</blockquote>
<p>这四个事件的事件对象，带有target属性（返回事件的目标节点）和relatedTarget属性（返回一个Element节点）。对于focusin事件，relatedTarget属性表示失去焦点的节点；对于focusout事件，表示将要接受焦点的节点；对于focus和blur事件，该属性返回null</p>
<h4 id="储存事件"><a href="#储存事件" class="headerlink" title="储存事件"></a>储存事件</h4><p><strong>storage事件</strong></p>
<p>当储存的数据发生变化时，会触发storage事件</p>
<p><strong>storage事件对象属性：</strong></p>
<blockquote>
<ul>
<li>key：值的键名</li>
<li>oldValue：更新前的值。如果该键为新增加，则这个属性为null</li>
<li>newValue：更新后的值。如果该键被删除，则这个属性为null</li>
<li>url：原始触发storage事件的那个网页的网址</li>
</ul>
</blockquote>
<p>注意：该事件不在导致数据变化的当前页面触发。如果浏览器同时打开一个域名下面的多个页面，当其中的一个页面改变sessionStorage或localStorage的数据时，其他所有页面的storage事件会被触发，而原始页面并不触发storage事件。可以通过这种机制，实现多个窗口之间的通信</p>
<h4 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h4><p><strong>toggle事件，show事件</strong></p>
<p><code>toggle</code>事件在用户打开或关闭 <details> 元素时触发</p>
<p><code>show</code>事件当 <menu> 元素在上下文菜单显示时触发</p>
<p><strong>beforeprint事件，afterprint事件</strong></p>
<p><code>beforeprint</code>事件在页面即将开始打印时触发</p>
<p><code>afterprint</code>事件在页面已经开始打印，或者打印窗口已经关闭时触发</p>
<p><strong>message事件</strong></p>
<p><code>message</code>事件通过或者从对象(WebSocket, Web Worker, Event Source 或子 frame 或父窗口)接收到消息时触发</p>
<h4 id="CSSOM事件"><a href="#CSSOM事件" class="headerlink" title="CSSOM事件"></a>CSSOM事件</h4><p><strong>animationstart</strong></p>
<p><code>animationstart</code>事件在 CSS 动画开始播放时触发</p>
<p><strong>animationiteration</strong></p>
<p><code>animationiteration</code>事件在 CSS 动画重新播放时触发</p>
<p><strong>animationend</strong></p>
<p><code>animationend</code>事件在CSS动画完成后触发</p>
<p><strong>transitionend</strong></p>
<p><code>transitionend</code>事件在CSS完成过渡后触发</p>
<p>以上事件只支持事件绑定</p>
<h4 id="MEDIA事件"><a href="#MEDIA事件" class="headerlink" title="MEDIA事件"></a>MEDIA事件</h4><p><strong>abort事件，emptied事件，error事件，stalled事件，suspend事件</strong></p>
<p><code>abort</code>事件在视频/音频终止加载时触发</p>
<p><code>emptied</code>事件当期播放列表为空时触发</p>
<p><code>error</code>事件在视频/音频数据加载期间发生错误时触发</p>
<p><code>stalled</code>事件在浏览器获取媒体数据，但媒体数据不可用时触发</p>
<p><code>suspend</code>事件在浏览器读取媒体数据中止时触发</p>
<p><strong>loadstart事件，durationchange事件，loadedmetadata事件，loadeddata事件，progress事件，canplay事件，canplaythrough事件</strong></p>
<p><code>loadstart</code>事件在浏览器开始寻找指定视频/音频触发</p>
<p><code>durationchange</code>事件在视频/音频的时长发生变化时触发</p>
<p><code>loadedmetadata</code>事件在指定视频/音频的元数据加载后触发</p>
<p><code>loadeddata</code>事件在浏览器加载视频/音频当前帧时触发触发</p>
<p><code>progress</code>事件在浏览器下载指定的视频/音频时触发</p>
<p><code>canplay</code>事件在用户可以开始播放视频/音频时触发</p>
<p><code>canplaythrough</code>事件在视频/音频可以正常播放且无需停顿和缓冲时触发</p>
<p><strong>play事件，pause事件，playing事件，waiting事件，ended事件</strong></p>
<p><code>play</code>事件在视频/音频开始播放时触发</p>
<p><code>pause</code>事件在视频/音频暂停时触发</p>
<p><code>playing</code>事件在视频/音频暂停或者在缓冲后准备重新开始播放时触发</p>
<p><code>waiting</code>事件在视频由于要播放下一帧而需要缓冲时触发</p>
<p><code>ended</code>事件在视频/音频播放结束时触发</p>
<p><strong>ratechange事件，timeupdate事件，volumechange事件</strong></p>
<p><code>ratechange</code>事件在视频/音频的播放速度发生改变时触发</p>
<p><code>timeupdate</code>事件在当前的播放位置发送改变时触发</p>
<p><code>volumechange</code>事件在视频/音频的音量发生改变时触发</p>
<p><strong>seeking事件，seeked事件</strong></p>
<p><code>seeking</code>事件在用户开始重新定位视频/音频时触发</p>
<p><code>seeked</code>事件在用户重新定位视频/音频的播放位置后触发</p>
<h3 id="Event-Model"><a href="#Event-Model" class="headerlink" title="Event Model"></a>Event Model</h3><h4 id="EventTarget接口"><a href="#EventTarget接口" class="headerlink" title="EventTarget接口"></a>EventTarget接口</h4><p>DOM的事件操作（监听和触发），都定义在<code>EventTarget</code>接口。<code>Element</code>节点、<code>document</code>节点和<code>window</code>对象，都部署了这个接口。此外，<code>XMLHttpRequest</code>、<code>AudioNode</code>、<code>AudioContext</code>等浏览器内置对象，也部署了这个接口。该接口就是三个方法：</p>
<blockquote>
<ul>
<li><code>addEventListener</code>：绑定事件的监听函数</li>
<li><code>removeEventListener</code>：移除事件的监听函数</li>
<li><code>dispatchEvent</code>：触发事件</li>
</ul>
</blockquote>
<p><strong>addEventListener()</strong></p>
<p><code>addEventListener</code>方法用于在当前节点或对象上，定义一个特定事件的监听函数：</p>
<p><code>target.addEventListener(type, listener[, useCapture])</code></p>
<p><code>addEventListener</code>方法接受三个参数：</p>
<blockquote>
<ul>
<li><code>type</code>：事件名称，大小写敏感</li>
<li><code>listener</code>：监听函数。事件发生时，会调用该监听函数</li>
<li><code>useCapture</code>：布尔值，表示监听函数是否在捕获阶段（capture）触发，默认为<code>false</code>（监听函数只在冒泡阶段被触发）。老式浏览器规定该参数必写，较新版本的浏览器允许该参数可选</li>
</ul>
</blockquote>
<p><strong>removeEventListener()</strong></p>
<p><code>removeEventListener</code>方法用来移除<code>addEventListener</code>方法添加的事件监听函数</p>
<p><code>removeEventListener</code>方法的参数，与<code>addEventListener</code>方法完全一致</p>
<p>注意，<code>removeEventListener</code>方法移除的监听函数，必须与对应的<code>addEventListener</code>方法的参数完全一致，而且必须在同一个元素节点，否则无效</p>
<p><strong>dispatchEvent()</strong></p>
<p><code>dispatchEvent</code>方法在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值。<code>dispatchEvent</code>方法的参数是一个<code>Event</code>对象的实例</p>
<p>如果<code>dispatchEvent</code>方法的参数为空，或者不是一个有效的事件对象，将报错</p>
<h4 id="监听函数"><a href="#监听函数" class="headerlink" title="监听函数"></a>监听函数</h4><p><strong>HTML标签的on-属性</strong></p>
<p>使用这个方法指定的监听函数，只会在冒泡阶段触发</p>
<p>注意，使用这种方法时，<code>on-</code>属性的值是将会执行的代码，而不是一个函数。一旦指定的事件发生，<code>on-</code>属性的值是原样传入JavaScript引擎执行。因此如果要执行函数，不要忘记加上一对圆括号</p>
<p><strong>Element节点的事件属性</strong></p>
<p>Element节点对象有事件属性，同样可以指定监听函数。使用这个方法指定的监听函数，只会在冒泡阶段触发</p>
<p><strong>addEventListener方法</strong></p>
<p>通过<code>Element</code>节点、<code>document</code>节点、<code>window</code>对象的<code>addEventListener</code>方法，也可以定义事件的监听函数</p>
<blockquote>
<p>第一种“HTML标签的on-属性”，违反了HTML与JavaScript代码相分离的原则；第二种“Element节点的事件属性”的缺点是，同一个事件只能定义一个监听函数，也就是说，如果定义两次onclick属性，后一次定义会覆盖前一次。因此，这两种方法都不推荐使用，除非是为了程序的兼容问题，因为所有浏览器都支持这两种方法</p>
</blockquote>
<p><strong>this的指向</strong></p>
<p><code>addEventListener</code>方法指定的监听函数，内部的<code>this</code>对象总是指向触发事件的那个节点</p>
<p>监听函数部署在Element节点的<code>on-</code>属性上面，<code>this</code>不会指向触发事件的元素节点</p>
<h4 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播"></a>事件的传播</h4><p><strong>传播的三分阶段：</strong></p>
<blockquote>
<ul>
<li><strong>第一阶段</strong>：从window对象传导到目标节点，称为“捕获阶段”（capture phase）</li>
<li><strong>第二阶段</strong>：在目标节点上触发，称为“目标阶段”（target phase）</li>
<li><strong>第三阶段</strong>：从目标节点传导回window对象，称为“冒泡阶段”（bubbling phase）</li>
</ul>
</blockquote>
<p><strong>事件代理/委托</strong></p>
<blockquote>
<p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件</p>
</blockquote>
<h4 id="Event对象"><a href="#Event对象" class="headerlink" title="Event对象"></a>Event对象</h4><p>事件发生以后，会生成一个事件对象，作为参数传给监听函数。浏览器原生提供一个<code>Event</code>对象，所有的事件都是这个对象的实例，或者说继承了<code>Event.prototype</code>对象</p>
<p><code>Event</code>对象本身就是一个构造函数，可以用来生成新的实例<code>event = new Event(typeArg, eventInit);</code></p>
<p>Event构造函数接受两个参数。第一个参数是字符串，表示事件的名称；第二个参数是一个对象，表示事件对象的配置。该参数可以有以下两个属性：</p>
<blockquote>
<ul>
<li><code>bubbles</code>：布尔值，可选，默认为<code>false</code>，表示事件对象是否冒泡</li>
<li><code>cancelable</code>：布尔值，可选，默认为<code>false</code>，表示事件是否可以被取消</li>
</ul>
</blockquote>
<p>Event构造函数创建的对象可以使用<code>dispatchEvent</code>方法触发该事件</p>
<p>IE8及以下版本，事件对象不作为参数传递，而是通过<code>window</code>对象的<code>event</code>属性读取，并且事件对象的<code>target</code>属性叫做<code>srcElement</code>属性</p>
<p><strong>Event对象的属性：</strong></p>
<blockquote>
<p>以下属性与事件的阶段有关：</p>
</blockquote>
<p><strong>event.bubbles</strong></p>
<p><code>bubbles</code>属性返回一个布尔值，表示当前事件是否会冒泡。该属性为只读属性，只能在新建事件时改变。除非显式声明，Event构造函数生成的事件，默认是不冒泡的</p>
<p><strong>event.eventPhase</strong></p>
<p><code>eventPhase</code>属性返回一个整数值，表示事件目前所处的节点</p>
<blockquote>
<p>以下属性与事件的默认行为有关：</p>
</blockquote>
<p><strong>event.cancelable</strong></p>
<p><code>cancelable</code>属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性，只能在新建事件时改变。除非显式声明，Event构造函数生成的事件，默认是不可以取消的</p>
<p><strong>event.defaultPrevented</strong></p>
<p><code>defaultPrevented</code>属性返回一个布尔值，表示该事件是否调用过preventDefault方法</p>
<blockquote>
<p>以下属性与阻止事件行为有关：</p>
</blockquote>
<p><strong>event.preventDefault()</strong></p>
<p><code>preventDefault</code>方法取消浏览器对当前事件的默认行为，比如点击链接后，浏览器跳转到指定页面，或者按一下空格键，页面向下滚动一段距离。该方法生效的前提是，事件的cancelable属性为true，如果为false，则调用该方法没有任何效果</p>
<p>如果监听函数最后返回布尔值false（即return false），浏览器也不会触发默认行为，但是与<code>event.preventDefault()</code>有区别，调用<code>return false</code>时会执行以下行为：</p>
<blockquote>
<ul>
<li>event.preventDefault()</li>
<li>event.stopPropagation()</li>
<li>停止回调函数执行并立即返回</li>
</ul>
</blockquote>
<p><strong>event.stopPropagation()</strong></p>
<p><code>stopPropagation</code>方法阻止事件在DOM中继续传播，防止再触发定义在别的节点上的监听函数（即阻止事件冒泡），但是不包括在当前节点上新定义的事件监听函数</p>
<p><strong>event.stopImmediatePropagation()</strong></p>
<p><code>stopImmediatePropagation</code>方法阻止同一个事件的其他监听函数被调用</p>
<p>如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序依次调用。只要其中有一个监听函数调用了stopImmediatePropagation方法，其他的监听函数就不会再执行了</p>
<blockquote>
<p>以下属性与事件的目标节点有关：</p>
</blockquote>
<p><strong>event.currentTarget</strong></p>
<p><code>currentTarget</code>属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点</p>
<p>在监听函数中，currentTarget属性实际上等同于this对象</p>
<p><strong>event.target</strong></p>
<p><code>target</code>属性返回触发事件的那个节点，即事件最初发生的节点</p>
<p>在IE6—IE8之中，该属性的名字不是target，而是<code>srcElement</code></p>
<blockquote>
<p>以下属性与事件对象的其他信息相关：</p>
</blockquote>
<p><strong>event.type</strong></p>
<p><code>type</code>属性返回一个字符串，表示事件类型，大小写敏感</p>
<p><strong>event.detail</strong></p>
<p><code>detail</code>属性返回一个数值，表示事件的某种信息。具体含义与事件类型有关，对于鼠标事件，表示鼠标按键在某个位置按下的次数，比如对于dblclick事件，detail属性的值总是2</p>
<p><strong>event.timeStamp</strong></p>
<p><code>timeStamp</code>属性返回一个毫秒时间戳，表示事件发生的时间</p>
<p><strong>event.isTrusted</strong></p>
<p><code>isTrusted</code>属性返回一个布尔值，表示该事件是否为真实用户触发</p>
<h4 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h4><blockquote>
<p>除了浏览器预定义的那些事件，用户还可以自定义事件，然后手动触发</p>
</blockquote>
<p><strong>CustomEvent()</strong></p>
<p>Event构造函数只能指定事件名，不能在事件上绑定数据。如果需要在触发事件的同时，传入指定的数据，需要使用CustomEvent构造函数生成自定义的事件对象：</p>
<p><code>var event = new CustomEvent(&#39;build&#39;, { &#39;detail&#39;: &#39;hello&#39; });</code></p>
<p>CustomEvent构造函数的第一个参数是事件名称，第二个参数是一个对象，该对象的detail属性会绑定在事件对象之上</p>
<p><strong>自定义事件的老式写法</strong></p>
<p>老式浏览器不一定支持各种类型事件的构造函数。因此，有时为了兼容，会用到一些非标准的方法。这些方法未来会被逐步淘汰，但是目前浏览器还广泛支持。除非是为了兼容老式浏览器，尽量不要使用</p>
<p><strong>document.createEvent()</strong></p>
<p>document.createEvent方法用来新建指定类型的事件。它所生成的Event实例，可以传入dispatchEvent方法</p>
<p>createEvent方法接受一个字符串作为参数，可能的值参见下表“数据类型”一栏。使用了某一种“事件类型”，就必须使用对应的事件初始化方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">事件类型</th>
<th style="text-align:center">事件初始化方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">UIEvents</td>
<td style="text-align:center">event.initUIEvent</td>
</tr>
<tr>
<td style="text-align:center">MouseEvents</td>
<td style="text-align:center">event.initMouseEvent</td>
</tr>
<tr>
<td style="text-align:center">MutationEvents</td>
<td style="text-align:center">event.initMutationEvent</td>
</tr>
<tr>
<td style="text-align:center">HTMLEvents</td>
<td style="text-align:center">event.initEvent</td>
</tr>
<tr>
<td style="text-align:center">Event</td>
<td style="text-align:center">event.initEvent</td>
</tr>
<tr>
<td style="text-align:center">CustomEvent</td>
<td style="text-align:center">event.initCustomEvent</td>
</tr>
<tr>
<td style="text-align:center">KeyboardEvent</td>
<td style="text-align:center">event.initKeyEvent</td>
</tr>
</tbody>
</table>
<p><strong>event.initEvent()</strong></p>
<p>事件对象的initEvent方法，用来初始化事件对象，还能向事件对象添加属性。该方法的参数必须是一个使用<code>Document.createEvent()</code>生成的Event实例，而且必须在dispatchEvent方法之前调用</p>
<p>initEvent方法可以接受四个参数：</p>
<blockquote>
<ul>
<li>type：事件名称，格式为字符串</li>
<li>bubbles：事件是否应该冒泡，格式为布尔值。可以使用event.bubbles属性读取它的值</li>
<li>cancelable：事件是否能被取消，格式为布尔值。可以使用event.cancelable属性读取它的值</li>
<li>option：为事件对象指定额外的属性</li>
</ul>
</blockquote>
</style></video></audio></p>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">JavaScript</a>
        		</li>
      		
		</ul>
	</div>

      

      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-JavaScript RegExp" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/12/JavaScript RegExp/">JavaScript RegExp</a>
    </h1>
  

        
        <a href="/2018/08/12/JavaScript RegExp/" class="archive-article-date">
  	<time datetime="2018-08-11T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-08-12</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JavaScript-RegExp"><a href="#JavaScript-RegExp" class="headerlink" title="JavaScript RegExp"></a>JavaScript RegExp</h2><h3 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h3><p>字面量：<strong>/pattern/attributes</strong>；如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /\bis\b/g;</span><br></pre></td></tr></table></figure>
<p>构造函数：<strong>new RegExp(pattern[, flags])</strong>；如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\bis\\b'</span>,<span class="string">'g'</span>);  <span class="comment">// 字符串需要添加反斜杠\来取消转义</span></span><br></pre></td></tr></table></figure>
<p>参数 <em>pattern</em> 是一个字符串, 指定了正则表达式字符串或其他的正则表达式对象.</p>
<p>参数 <em>flags</em> 是一个可选的字符串, 包含属性 “g”、”i” 和 “m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配。如果<em>pattern</em> 是正则表达式, 而不是字符串, 则必须省略该参数</p>
<h4 id="RegExp实例属性"><a href="#RegExp实例属性" class="headerlink" title="RegExp实例属性"></a>RegExp实例属性</h4><table>
<thead>
<tr>
<th style="text-align:center">实例属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">global</td>
<td style="text-align:center">是否包含全局标志(true/false)</td>
</tr>
<tr>
<td style="text-align:center">ignoreCase</td>
<td style="text-align:center">是否包含区分大小写标志(true/false)</td>
</tr>
<tr>
<td style="text-align:center">multiline</td>
<td style="text-align:center">是否包含多行标志(true/false)</td>
</tr>
<tr>
<td style="text-align:center">source</td>
<td style="text-align:center">返回创建RegExp对象实例时指定的表达式文本字符串形式</td>
</tr>
<tr>
<td style="text-align:center">lastIndex</td>
<td style="text-align:center">表示原字符串中匹配的字符串末尾的后一个位置, 默认为0</td>
</tr>
<tr>
<td style="text-align:center">flags(ES6)</td>
<td style="text-align:center">返回正则表达式的修饰符</td>
</tr>
<tr>
<td style="text-align:center">sticky(ES6)</td>
<td style="text-align:center">是否设置了y(粘连)修饰符(true/false)</td>
</tr>
</tbody>
</table>
<h4 id="RegExp实例方法"><a href="#RegExp实例方法" class="headerlink" title="RegExp实例方法"></a>RegExp实例方法</h4><p><strong>compile</strong></p>
<p>compile 方法用于在执行过程中改变和重新编译正则表达式</p>
<p>语法: compile(pattern[, flags])</p>
<p>参数介绍请参考上述 RegExp 构造器. 用法如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"abc"</span>, <span class="string">"gi"</span>); </span><br><span class="line"><span class="keyword">var</span> reg2 = reg.compile(<span class="string">"new abc"</span>, <span class="string">"g"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(reg);<span class="comment">// /new abc/g</span></span><br><span class="line"><span class="built_in">console</span>.log(reg2);<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>可见compile方法会改变原正则表达式对象，并重新编译，而且它的返回值为空</p>
<p><strong>test</strong></p>
<p>test 方法用于检测一个字符串是否匹配某个正则规则，只要是字符串中含有与正则规则匹配的文本，该方法就返回true, 否则返回 false</p>
<p>语法: test(string), 用法如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[0-9]+/</span>.test(<span class="string">"abc123"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[0-9]+/</span>.test(<span class="string">"abc"</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>以上，字符串”abc123” 包含数字，故 test 方法返回 true；而 字符串”abc” 不包含数字，故返回 false</p>
<p>如果需要使用 test 方法测试字符串是否完成匹配某个正则规则，那么可以在正则表达式里增加开始(^)和结束($)元字符。如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^[0-9]+$/</span>.test(<span class="string">"abc123"</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>以上，由于字符串”abc123” 并非以数字开始, 也并非以数字结束, 故 test 方法返回false</p>
<p>实际上，如果正则表达式带有全局标志(带有参数g)时，test 方法还受正则对象的lastIndex属性影响,如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-z]+/</span>;<span class="comment">//正则不带全局标志</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">"abc"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">"de"</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-z]+/g</span>;<span class="comment">//正则带有全局标志g</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">"abc"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//3, 下次运行test时,将从索引为3的位置开始查找</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">"de"</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>该影响将在exec 方法讲解中予以分析</p>
<p><strong>exec</strong></p>
<p>exec 方法用于检测字符串对正则表达式的匹配，如果找到了匹配的文本，则返回一个结果数组，否则返回null</p>
<p>语法: exec(string)</p>
<p>exec 方法返回的数组中包含两个额外的属性, index 和 input。并且该数组具有如下特点：</p>
<ul>
<li>第 0 个项表示正则表达式捕获的文本</li>
<li>第 1~n 项表示第 1~n 个反向引用, 依次指向第 1~n 个分组捕获的文本, 可以使用RegExp.$ + “编号1~n” 依次获取分组中的文本</li>
<li>index 表示匹配字符串的初始位置</li>
<li>input 表示正在检索的字符串</li>
</ul>
<p>无论正则表达式有无全局标示”g”, exec 的表现都相同。但正则表达式对象的表现却有些不同</p>
<p>假设正则表达式对象为 reg ，检测的字符为 string ，reg.exec(string) 返回值为 array</p>
<p>若 reg 包含全局标示”g”，那么 reg.lastIndex 属性表示原字符串中匹配的字符串末尾的后一个位置，即下次匹配开始的位置, 此时 reg.lastIndex == array.index(匹配开始的位置) + array[0].length(匹配字符串的长度)。如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/([a-z]+)/gi</span>,</span><br><span class="line">    string = <span class="string">"World Internet Conference"</span>;</span><br><span class="line"><span class="keyword">var</span> array = reg.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["World", "World", index: 0, input: "World Internet Conference"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);<span class="comment">//World</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//5, 刚好等于 array.index + array[0].length</span></span><br></pre></td></tr></table></figure>
<p>随着检索继续，array.index 的值将往后递增，也就是说，reg.lastIndex 的值也会同步往后递增。因此，也可以通过反复调用 exec 方法来遍历字符串中所有的匹配文本。直到 exec 方法再也匹配不到文本时，它将返回 null，并把 reg.lastIndex 属性重置为 0</p>
<p>接着上述例子，继续执行代码，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">array = reg.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["Internet", "Internet", index: 6, input: "World Internet Conference"]</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//14</span></span><br><span class="line"></span><br><span class="line">array = reg.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//["Conference", "Conference", index: 15, input: "World Internet Conference"]</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//25</span></span><br><span class="line"></span><br><span class="line">array = reg.exec(string);</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//null</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex);<span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>以上代码中，随着反复调用 exec 方法，reg.lastIndex 属性最终被重置为 0</p>
<h4 id="字符串对象方法"><a href="#字符串对象方法" class="headerlink" title="字符串对象方法"></a>字符串对象方法</h4><p>字符串对象的方法之中，有4种与正则对象有关：</p>
<ul>
<li><code>match()</code>：返回一个数组，成员是所有匹配的子字符串</li>
<li><code>search()</code>：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置</li>
<li><code>replace()</code>：按照给定的正则表达式进行替换，返回替换后的字符串</li>
<li><code>split()</code>：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员</li>
</ul>
<p><strong>String.prototype.match()</strong></p>
<p>字符串对象的<code>match</code>方法对字符串进行正则匹配，返回匹配结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'_x_x'</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/x/</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/y/</span>;</span><br><span class="line"></span><br><span class="line">s.match(r1) <span class="comment">// ["x"]</span></span><br><span class="line">s.match(r2) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>从上面代码可以看到，字符串的<code>match</code>方法与正则对象的<code>exec</code>方法非常类似：匹配成功返回一个数组，匹配失败返回<code>null</code></p>
<p>如果正则表达式带有<code>g</code>修饰符，则该方法与正则对象的<code>exec</code>方法行为不同，会一次性返回所有匹配成功的结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'abba'</span>;</span><br><span class="line"><span class="keyword">var</span> r = <span class="regexp">/a/g</span>;</span><br><span class="line"></span><br><span class="line">s.match(r) <span class="comment">// ["a", "a"]</span></span><br><span class="line">r.exec(s) <span class="comment">// ["a"]</span></span><br></pre></td></tr></table></figure>
<p>设置正则表达式的<code>lastIndex</code>属性，对<code>match</code>方法无效，匹配总是从字符串的第一个字符开始</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/a|b/g</span>;</span><br><span class="line">r.lastIndex = <span class="number">7</span>;</span><br><span class="line"><span class="string">'xaxb'</span>.match(r) <span class="comment">// ['a', 'b']</span></span><br><span class="line">r.lastIndex <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，设置<code>lastIndex</code>属性是无效的</p>
<p><strong>String.prototype.search()</strong></p>
<p>字符串对象的<code>search</code>方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回<code>-1</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'_x_x'</span>.search(<span class="regexp">/x/</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个匹配结果出现在字符串的<code>1</code>号位置</p>
<p>该方法会忽略<code>g</code>修饰符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/x/g</span>;</span><br><span class="line">r.lastIndex = <span class="number">2</span>; <span class="comment">// 无效</span></span><br><span class="line"><span class="string">'_x_x'</span>.search(r) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，正则表达式使用<code>g</code>修饰符之后，使用<code>lastIndex</code>属性指定开始匹配的位置，结果无效，还是从字符串的第一个字符开始匹配</p>
<p><strong>String.prototype.replace()</strong></p>
<p>字符串对象的<code>replace</code>方法可以替换匹配的值。它接受两个参数，第一个是搜索模式，第二个是替换的内容</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.replace(search, replacement)</span><br></pre></td></tr></table></figure>
<p>搜索模式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'aaa'</span>.replace(<span class="string">'a'</span>, <span class="string">'b'</span>) <span class="comment">// "baa"</span></span><br><span class="line"><span class="string">'aaa'</span>.replace(<span class="regexp">/a/</span>, <span class="string">'b'</span>) <span class="comment">// "baa"</span></span><br><span class="line"><span class="string">'aaa'</span>.replace(<span class="regexp">/a/g</span>, <span class="string">'b'</span>) <span class="comment">// "bbb"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，最后一个正则表达式使用了<code>g</code>修饰符，导致所有的<code>b</code>都被替换掉了</p>
<p><code>replace</code>方法的一个应用，就是消除字符串首尾两端的空格</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'  #id div.class  '</span>;</span><br><span class="line"></span><br><span class="line">str.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">''</span>)</span><br><span class="line"><span class="comment">// "#id div.class"</span></span><br></pre></td></tr></table></figure>
<p>replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容：</p>
<ul>
<li><code>$&amp;</code> 指代匹配的子字符串</li>
<li><code>$`</code> 指代匹配结果前面的文本</li>
<li><code>$&#39;</code> 指代匹配结果后面的文本</li>
<li><code>$n</code> 指代匹配成功的第<code>n</code>组内容，<code>n</code>是从1开始的自然数</li>
<li><code>$$</code> 指代美元符号<code>$</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello world'</span>.replace(<span class="regexp">/(\w+)\s(\w+)/</span>, <span class="string">'$2 $1'</span>)</span><br><span class="line"><span class="comment">// "world hello"</span></span><br><span class="line"></span><br><span class="line"><span class="string">'abc'</span>.replace(<span class="string">'b'</span>, <span class="string">'[$`-$&amp;-$\']'</span>)</span><br><span class="line"><span class="comment">// "a[a-b-c]c"</span></span><br></pre></td></tr></table></figure>
<p><code>replace</code>方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'3 and 5'</span>.replace(<span class="regexp">/[0-9]+/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * match;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// "6 and 10"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'The quick brown fox jumped over the lazy dog.'</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/quick|brown|lazy/ig</span>;</span><br><span class="line"></span><br><span class="line">a.replace(pattern, <span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">match</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> match.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// The QUICK BROWN fox jumped over the LAZY dog.</span></span><br></pre></td></tr></table></figure>
<p>作为<code>replace</code>方法第二个参数的替换函数，可以接受多个参数。第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。下面是一个网页模板替换的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prices = &#123;</span><br><span class="line">  <span class="string">'pr_1'</span>: <span class="string">'$1.99'</span>,</span><br><span class="line">  <span class="string">'pr_2'</span>: <span class="string">'$9.99'</span>,</span><br><span class="line">  <span class="string">'pr_3'</span>: <span class="string">'$5.00'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> template = <span class="string">'/* ... */'</span>; <span class="comment">// 这里可以放网页模块字符串</span></span><br><span class="line"></span><br><span class="line">template.replace(</span><br><span class="line">  /(<span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">")(.*?)("</span>&gt;</span>)(<span class="tag">&lt;<span class="name">\</span>/<span class="attr">span</span>&gt;</span></span>)/g,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">match, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>, $<span class="number">4</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $<span class="number">1</span> + $<span class="number">2</span> + $<span class="number">3</span> + prices[$<span class="number">2</span>] + $<span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面代码的捕捉模式中，有四个括号，所以会产生四个组匹配，在匹配函数中用<code>$1</code>到<code>$4</code>表示。匹配函数的作用是将价格插入模板中。</p>
<p><strong>String.prototype.split()</strong></p>
<p>字符串对象的<code>split</code>方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.split(separator, [limit])</span><br></pre></td></tr></table></figure>
<p>该方法接受两个参数，第一个参数是分隔规则，第二个参数是返回数组的最大成员数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非正则分隔</span></span><br><span class="line"><span class="string">'a,  b,c, d'</span>.split(<span class="string">','</span>)</span><br><span class="line"><span class="comment">// [ 'a', '  b', 'c', ' d' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则分隔，去除多余的空格</span></span><br><span class="line"><span class="string">'a,  b,c, d'</span>.split(<span class="regexp">/, */</span>)</span><br><span class="line"><span class="comment">// [ 'a', 'b', 'c', 'd' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定返回数组的最大成员</span></span><br><span class="line"><span class="string">'a,  b,c, d'</span>.split(<span class="regexp">/, */</span>, <span class="number">2</span>)</span><br><span class="line">[ <span class="string">'a'</span>, <span class="string">'b'</span> ]</span><br></pre></td></tr></table></figure>
<p>上面代码使用正则表达式，去除了子字符串的逗号后面的空格</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="string">'aaa*a*'</span>.split(<span class="regexp">/a*/</span>)</span><br><span class="line"><span class="comment">// [ '', '*', '*' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="string">'aaa**a*'</span>.split(<span class="regexp">/a*/</span>)</span><br><span class="line"><span class="comment">// ["", "*", "*", "*"]</span></span><br></pre></td></tr></table></figure>
<p>上面代码的分割规则是0次或多次的<code>a</code>，由于正则默认是贪婪匹配，所以例一的第一个分隔符是<code>aaa</code>，第二个分割符是<code>a</code>，将字符串分成三个部分，包含开始处的空字符串。例二的第一个分隔符是<code>aaa</code>，第二个分隔符是0个<code>a</code>（即空字符），第三个分隔符是<code>a</code>，所以将字符串分成四个部分</p>
<p>如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'aaa*a*'</span>.split(<span class="regexp">/(a*)/</span>)</span><br><span class="line"><span class="comment">// [ '', 'aaa', '*', 'a', '*' ]</span></span><br></pre></td></tr></table></figure>
<p>上面代码的正则表达式使用了括号，第一个组匹配是“aaa”，第二个组匹配是“a”，它们都作为数组成员返回</p>
<h4 id="ES6对正则的扩展"><a href="#ES6对正则的扩展" class="headerlink" title="ES6对正则的扩展"></a>ES6对正则的扩展</h4><p>ES6对正则扩展了又两种修饰符(其他语言可能不支持):</p>
<ul>
<li>y (粘连sticky修饰符), 与g类似, 也是全局匹配, 并且下一次匹配都是从上一次匹配成功的下一个位置开始, 不同之处在于, g修饰符只要剩余位置中存在匹配即可, 而y修饰符确保匹配必须从剩余的第一个位置开始.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"abc_ab_a"</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/[a-z]+/g</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/[a-z]+/y</span>;</span><br><span class="line"><span class="built_in">console</span>.log(r1.exec(s),r1.lastIndex); <span class="comment">// ["abc", index: 0, input: "abc_ab_a"] 3</span></span><br><span class="line"><span class="built_in">console</span>.log(r2.exec(s),r2.lastIndex); <span class="comment">// ["abc", index: 0, input: "abc_ab_a"] 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(r1.exec(s),r1.lastIndex); <span class="comment">// ["ab", index: 4, input: "abc_ab_a"] 6</span></span><br><span class="line"><span class="built_in">console</span>.log(r2.exec(s),r2.lastIndex); <span class="comment">// null 0</span></span><br></pre></td></tr></table></figure>
<p>如上, 由于第二次匹配的开始位置是下标3, 对应的字符串是 “_”, 而使用y修饰符的正则对象r2, 需要从剩余的第一个位置开始, 所以匹配失败, 返回null.</p>
<p>正则对象的 sticky 属性, 表示是否设置了y修饰符. 这点将会在后面讲到.</p>
<ul>
<li>u 修饰符, 提供了对正则表达式添加4字节码点的支持. 比如 “𝌆” 字符是一个4字节字符, 直接使用正则匹配将会失败, 而使用u修饰符后, 将会等到正确的结果.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"𝌆"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/</span>.test(s));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/u</span>.test(s));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><strong>UCS-2字节码</strong></p>
<p>有关字节码点， javaScript 只能处理UCS-2编码(js于1995年5月被Brendan Eich花费10天设计出来，比1996年7月发布的编码规范UTF-16早了一年多, 当时只有UCS-2可选). 由于UCS-2先天不足, 造成了所有字符在js中都是2个字节. 如果是4个字节的字符, 将会默认被当作两个双字节字符处理. 因此 js 的字符处理函数都会受到限制, 无法返回正确结果. 如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"𝌆"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s == <span class="string">"\uD834\uDF06"</span>);<span class="comment">//true 𝌆相当于UTF-16中的0xD834DF06</span></span><br><span class="line"><span class="built_in">console</span>.log(s.length);<span class="comment">//2 长度为2, 表示这是4字节字符</span></span><br></pre></td></tr></table></figure>
<p>ES6可以自动识别4字节的字符。因此遍历字符串可以直接使用for of循环。同时, js中如果直接使用码点表示Unicode字符, 对于4字节字符, ES5里是没办法识别的。为此ES6修复了这个问题, 只需将码点放在大括号内即可.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(s === <span class="string">"\u1D306"</span>);<span class="comment">//false   ES5无法识别𝌆</span></span><br><span class="line"><span class="built_in">console</span>.log(s === <span class="string">"\u&#123;1D306&#125;"</span>);<span class="comment">//true  ES6可以借助大括号识别𝌆</span></span><br></pre></td></tr></table></figure>
<p><strong>附: ES6新增的处理4字节码的函数</strong></p>
<ul>
<li><strong>String.fromCodePoint()</strong>：从Unicode码点返回对应字符</li>
<li><strong>String.prototype.codePointAt()</strong>：从字符返回对应的码点</li>
<li><strong>String.prototype.at()</strong>：返回字符串给定位置的字符</li>
</ul>
<h3 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h3><h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">查找单个字符，除了换行和行结束符。</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td style="text-align:center">查找单词字符。</td>
</tr>
<tr>
<td style="text-align:center">\W</td>
<td style="text-align:center">查找非单词字符。</td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td style="text-align:center">查找数字。</td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td style="text-align:center">查找非数字字符。</td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td style="text-align:center">查找空白字符。</td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td style="text-align:center">查找非空白字符。</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:center">匹配单词边界。</td>
</tr>
<tr>
<td style="text-align:center">\B</td>
<td style="text-align:center">匹配非单词边界。</td>
</tr>
<tr>
<td style="text-align:center">\0</td>
<td style="text-align:center">查找 NULL 字符。</td>
</tr>
<tr>
<td style="text-align:center">\n</td>
<td style="text-align:center">查找换行符。</td>
</tr>
<tr>
<td style="text-align:center">\f</td>
<td style="text-align:center">查找换页符。</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td style="text-align:center">查找回车符。</td>
</tr>
<tr>
<td style="text-align:center">\t</td>
<td style="text-align:center">查找制表符。</td>
</tr>
<tr>
<td style="text-align:center">\v</td>
<td style="text-align:center">查找垂直制表符。</td>
</tr>
<tr>
<td style="text-align:center">\xxx</td>
<td style="text-align:center">查找以八进制数 xxx 规定的字符。</td>
</tr>
<tr>
<td style="text-align:center">\xdd</td>
<td style="text-align:center">查找以十六进制数 dd 规定的字符。</td>
</tr>
<tr>
<td style="text-align:center">\uxxxx</td>
<td style="text-align:center">查找以十六进制数 xxxx 规定的 Unicode 字符。</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">匹配行首</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:center">匹配行尾</td>
</tr>
<tr>
<td style="text-align:center">[^x]</td>
<td style="text-align:center">匹配除x以外的任意字符</td>
</tr>
</tbody>
</table>
<h4 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a>方括号</h4><table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[abc]</td>
<td style="text-align:center">查找方括号之间的任何字符。</td>
</tr>
<tr>
<td style="text-align:center">[^abc]</td>
<td style="text-align:center">查找任何不在方括号之间的字符。</td>
</tr>
<tr>
<td style="text-align:center">[0-9]</td>
<td style="text-align:center">查找任何从 0 至 9 的数字。</td>
</tr>
<tr>
<td style="text-align:center">[a-z]</td>
<td style="text-align:center">查找任何从小写 a 到小写 z 的字符。</td>
</tr>
<tr>
<td style="text-align:center">[A-Z]</td>
<td style="text-align:center">查找任何从大写 A 到大写 Z 的字符。</td>
</tr>
<tr>
<td style="text-align:center">[A-z]</td>
<td style="text-align:center">查找任何从大写 A 到小写 z 的字符。</td>
</tr>
<tr>
<td style="text-align:center">[adgk]</td>
<td style="text-align:center">查找给定集合内的任何字符。</td>
</tr>
<tr>
<td style="text-align:center">[^adgk]</td>
<td style="text-align:center">查找给定集合外的任何字符。</td>
</tr>
<tr>
<td style="text-align:center">(red\</td>
<td style="text-align:center">blue\</td>
<td>green)</td>
<td>查找任何指定的选项。</td>
</tr>
</tbody>
</table>
<h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><table>
<thead>
<tr>
<th style="text-align:center">量词</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">n+</td>
<td style="text-align:center">匹配任何包含至少一个 n 的字符串。例如，/a+/ 匹配 “candy” 中的 “a”，”caaaaaaandy” 中所有的 “a”。</td>
</tr>
<tr>
<td style="text-align:center">n*</td>
<td style="text-align:center">匹配任何包含零个或多个 n 的字符串。例如，/bo*/ 匹配 “A ghost booooed” 中的 “boooo”，”A bird warbled” 中的 “b”，但是不匹配 “A goat grunted”。</td>
</tr>
<tr>
<td style="text-align:center">n?</td>
<td style="text-align:center">匹配任何包含零个或一个 n 的字符串。例如，/e?le?/ 匹配 “angel” 中的 “el”，”angle” 中的 “le”。</td>
</tr>
<tr>
<td style="text-align:center">n{X}</td>
<td style="text-align:center">匹配包含 X 个 n 的序列的字符串。例如，/a{2}/ 不匹配 “candy,” 中的 “a”，但是匹配 “caandy,” 中的两个 “a”，且匹配 “caaandy.” 中的前两个 “a”。</td>
</tr>
<tr>
<td style="text-align:center">n{X,}</td>
<td style="text-align:center">X 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配。例如，/a{2,}/ 不匹配 “candy” 中的 “a”，但是匹配 “caandy” 和 “caaaaaaandy.” 中所有的 “a”。</td>
</tr>
<tr>
<td style="text-align:center">n{X,Y}</td>
<td style="text-align:center">X 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。例如，/a{1,3}/ 不匹配 “cndy”，匹配 “candy,” 中的 “a”，”caandy,” 中的两个 “a”，匹配 “caaaaaaandy” 中的前面三个 “a”。注意，当匹配 “caaaaaaandy” 时，即使原始字符串拥有更多的 “a”，匹配项也是 “aaa”。</td>
</tr>
<tr>
<td style="text-align:center">n{X,}</td>
<td style="text-align:center">匹配包含至少 X 个 n 的序列的字符串。</td>
</tr>
<tr>
<td style="text-align:center">n$</td>
<td style="text-align:center">匹配任何结尾为 n 的字符串。</td>
</tr>
<tr>
<td style="text-align:center">^n</td>
<td style="text-align:center">匹配任何开头为 n 的字符串。</td>
</tr>
<tr>
<td style="text-align:center">?=n</td>
<td style="text-align:center">匹配任何其后紧接指定字符串 n 的字符串。</td>
</tr>
<tr>
<td style="text-align:center">?!n</td>
<td style="text-align:center">匹配任何其后没有紧接指定字符串 n 的字符串。</td>
</tr>
</tbody>
</table>
<h4 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h4><p>[…] 匹配中括号内字符之一。如：[xyz] 匹配字符 x，y 或 z。如果中括号中包含元字符，则元字符降级为普通字符，不再具有元字符的功能，如 [+.?] 匹配 加号，点号或问号</p>
<h4 id="排除性字符组"><a href="#排除性字符组" class="headerlink" title="排除性字符组"></a>排除性字符组</h4><p>[^…] 匹配任何未列出的字符，如: [ ^x ]匹配除x以外的任意字符</p>
<h4 id="多选结构"><a href="#多选结构" class="headerlink" title="多选结构"></a>多选结构</h4><p>| 就是或的意思，表示两者中的一个。 如: a|b 匹配a或者b字符</p>
<h4 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h4><p>括号 常用来界定重复限定符的范围，以及将字符<strong>分组</strong>。 如： (ab)+ 可以匹配abab..等，其中 ab 便是一个分组</p>
<h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p>\ 即转义字符，通常 <strong>\ * + ? | { [ ( ) ] }^ $ . # 和 空白</strong> 这些字符都需要转义</p>
<h4 id="操作符的运算优先级"><a href="#操作符的运算优先级" class="headerlink" title="操作符的运算优先级"></a>操作符的运算优先级</h4><ol>
<li>\ 转义符</li>
<li>(), (?:), (?=), [] 圆括号或方括号</li>
<li>*, +, ?, {n}, {n,}, {n,m} 限定符</li>
<li>^, $ 位置</li>
<li>| “或” 操作</li>
</ol>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>javaScript中正则表达式默认有如下五种修饰符：</p>
<ul>
<li>g (全文查找),</li>
<li>i (忽略大小写查找)</li>
<li>m (多行查找)</li>
<li>y (ES6新增的粘连修饰符)</li>
<li>u (ES6新增)</li>
</ul>
<h3 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h3><ol>
<li>汉字: ^[\u4e00-\u9fa5]{0,}$</li>
<li>Email: ^\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*$</li>
<li>URL: ^https?://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$</li>
<li>手机号码: ^1\d{10}$</li>
<li>身份证号: ^(\d{15}|\d{17}(\d|X))$</li>
<li>中国邮政编码: [1-9]\d{5}(?!\d) (邮政编码为6位数字)</li>
</ol>
<p><strong>密码验证</strong></p>
<p>密码验证是常见的需求，一般来说, 常规密码大致会满足规律： 6-16位, 数字, 字母, 字符至少包含两种, 同时不能包含中文和空格. 如下便是常规密码验证的正则描述：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(?!^[0-9]+$)(?!^[A-z]+$)(?!^[^A-z0-9]+$)^[^\s\u4e00-\u9fa5]&#123;6,16&#125;$/</span>;</span><br></pre></td></tr></table></figure>
<p><strong>正则表达式在H5中的应用</strong></p>
<p>H5中新增了 pattern 属性, 规定了用于验证输入字段的模式, pattern的模式匹配支持正则表达式的书写方式. 默认 pattern 属性是全部匹配, 即无论正则表达式中有无 “^”, “$” 元字符, 它都是匹配所有文本</p>
<p>注：pattern 适用于以下 input 类型：text, search, url, telephone, email 以及 password。如果需要取消表单验证，在form标签上增加 novalidate 属性即可</p>
<h3 id="正则表达式初阶技能"><a href="#正则表达式初阶技能" class="headerlink" title="正则表达式初阶技能"></a>正则表达式初阶技能</h3><h4 id="贪婪与非贪婪模式"><a href="#贪婪与非贪婪模式" class="headerlink" title="贪婪与非贪婪模式"></a>贪婪与非贪婪模式</h4><p>默认情况下，所有的限定词都是贪婪模式，表示尽可能多的去捕获字符：而在限定词后增加？则是非贪婪模式，表示尽可能少的去捕获字符。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"aaab"</span>,</span><br><span class="line">    reg1 = <span class="regexp">/a+/</span>, <span class="comment">//贪婪模式</span></span><br><span class="line">    reg2 = <span class="regexp">/a+?/</span>;<span class="comment">//非贪婪模式</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg1)); <span class="comment">//["aaa"], 由于是贪婪模式, 捕获了所有的a</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg2)); <span class="comment">//["a"], 由于是非贪婪模式, 只捕获到第一个a</span></span><br></pre></td></tr></table></figure>
<p>实际上，非贪婪模式非常有效，特别是当匹配html标签时。比如匹配一个配对出现的div，方案一可能会匹配到很多的div标签对，而方案二则只会匹配一个div标签对</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"&lt;div class='v1'&gt;&lt;div class='v2'&gt;test&lt;/div&gt;&lt;input type='text'/&gt;&lt;/div&gt;"</span>;</span><br><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/&lt;div.*&lt;\/div&gt;/</span>; <span class="comment">//方案一,贪婪匹配</span></span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/&lt;div.*?&lt;\/div&gt;/</span>;<span class="comment">//方案二,非贪婪匹配</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg1));<span class="comment">//"&lt;div class='v1'&gt;&lt;div class='v2'&gt;test&lt;/div&gt;&lt;input type='text'/&gt;&lt;/div&gt;"</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg2));<span class="comment">//"&lt;div class='v1'&gt;&lt;div class='v2'&gt;test&lt;/div&gt;"</span></span><br></pre></td></tr></table></figure>
<p><strong>区间量词的非贪婪模式</strong></p>
<p>一般情况下，非贪婪模式，使用的是”*?”，或 “+?” 这种形式，还有一种是 “{n,m}?”</p>
<p>区间量词”{n,m}” 也是匹配优先，虽有匹配次数上限，但是在到达上限之前，它依然是尽可能多的匹配，而”{n,m}?” 则表示在区间范围内，尽可能少的匹配</p>
<p><strong>需要注意的是</strong>：</p>
<ul>
<li>能达到同样匹配结果的贪婪与非贪婪模式，通常是贪婪模式的匹配效率较高</li>
<li>所有的非贪婪模式，都可以通过修改量词修饰的子表达式，转换为贪婪模式</li>
<li>贪婪模式可以与<code>固化分组</code>(后面会讲到)结合，提升匹配效率，而非贪婪模式却不可以</li>
</ul>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>正则的分组主要通过小括号来实现，括号包裹的子表达式作为一个分组，括号后可以紧跟限定词表示重复次数。如下, 小括号内包裹的abc便是一个分组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/(abc)+<span class="regexp">/.test("abc123") == true</span></span><br></pre></td></tr></table></figure>
<p>那么分组有什么用呢？一般来说，分组是为了方便的表示重复次数，除此之外，还有一个作用就是用于捕获</p>
<h4 id="捕获性分组"><a href="#捕获性分组" class="headerlink" title="捕获性分组"></a>捕获性分组</h4><p>捕获性分组，通常由一对小括号加上子表达式组成。 捕获性分组会创建反向引用，每个反向引用都由一个编号或名称来标识。js中主要是通过 <code>$+编号</code> 或者 <code>\+编号</code> 表示法进行引用。如下便是一个捕获性分组的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"#808080"</span>;</span><br><span class="line"><span class="keyword">var</span> output = color.replace(<span class="regexp">/#(\d+)/</span>,<span class="string">"$1"</span>+<span class="string">"~~"</span>);<span class="comment">//自然也可以写成 "$1~~"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);<span class="comment">//808080</span></span><br><span class="line"><span class="built_in">console</span>.log(output);<span class="comment">//808080~~</span></span><br></pre></td></tr></table></figure>
<p>以上， (\d+) 表示一个捕获性分组， <code>RegExp.$1</code> 指向该分组捕获的内容。 <code>$+编号</code> 只能在正则表达式之外使用</p>
<p>实际上，捕获性分组捕获到的内容不仅可以在正则表达式外部引用，还可以在正则表达式内部引用</p>
<h4 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h4><p>能在正则表达式内部使用的引用只有『反向引用』，其格式为<code>\+数字</code> ，通常用于匹配不同位置相同部分的子串。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">"www.google.google.com"</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/([a-z]+)\.\1/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(url.replace(re,<span class="string">"$1"</span>));<span class="comment">//"www.google.com"</span></span><br></pre></td></tr></table></figure>
<p>以上，相同部分的”google”字符串只被替换一次</p>
<p>实例之后，来看看反向引用的原理</p>
<blockquote>
<p>正则表达式匹配时，各个捕获性分组匹配到的内容，会依次保存在内存中一个特定的组里，通过<code>\+数字</code>的方式可以在正则中引用组里的内容，这种引用称作<strong>反向引用</strong>。捕获性分组匹配成功之前，它的内容的是不确定的，一旦匹配成功，组里的内容也就确定了。</p>
</blockquote>
<p>打个比方就是，假如有字符串<code>abcaabcabbcabcc</code>，对于正则表达式<code>/([abc])\1/</code>，捕获性分组中的子表达式<code>[abc]</code>，虽然可以匹配”a”、”b” 或 “c”，但是一旦匹配成功了，反向引用的内容也就是确定了，那么相对的，反向引用的子表达式<code>\1</code>将依次匹配”a”、”b” 或 “c”。因此实际上，捕获性分组<code>[abc]</code>和反向引用<code>\1</code>将同时捕获”a”、”b” 或 “c”中的同一个字符，即有三种可能捕获的结果：”aa”，”bb” 或 “cc”。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"abcaabcabbcabcc"</span>.match(<span class="regexp">/([abc])\1/g</span>); <span class="comment">// ["aa", "bb", "cc"]</span></span><br></pre></td></tr></table></figure>
<p>反向引用中<code>\n</code>指向正则表达式前面第n个捕获性分组匹配到的内容，这里面有一个问题，对于子表达式<code>\12</code>，有下面两种可能：</p>
<ul>
<li>指向第1个捕获性分组匹配到的内容，同时匹配普通字符2，目前IE浏览器按照这种方式解析正则</li>
<li>指向第12个捕获性分组匹配到的内容，目前非IE等现代浏览器都是这样解析正则的</li>
</ul>
<p>为避免各语言或者浏览器解析不一致，因此建议<strong>反向引用不要索引大于9的捕获性分组</strong>。不仅如此，反向引用如果不存在，正则将会匹配失败。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"abcaabcabbcabcc"</span>.match(<span class="regexp">/([abc])\2/g</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>由于不存在第二个捕获性分组，因此反向引用子表达式<code>\2</code>匹配失败，进而整个表达式匹配失败</p>
<p><strong>反向引用常用来匹配重复出现的字符串，而不是重复出现的子表达式，这点要尤为注意。</strong>因此如果想要匹配4个或2个数字的话，使用如下正则表达式是万万不行的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"1234567890"</span>.match(<span class="regexp">/(\d)&#123;4&#125;|\1&#123;2&#125;/g</span>); <span class="comment">// ["1234", "5678", "", "", ""]</span></span><br></pre></td></tr></table></figure>
<p>以上正则表达式，想用反向引用<code>\1</code>代替前面的捕获性分组<code>\d</code>，这是不可行的。修饰符g表示全文查找，因此前两次匹配到了 “1234” 和 “5678”，此时正则引擎的指针处于数字8的后面，再往后匹配显然子表达式<code>(\d){4}</code>无法匹配了，此时第一个捕获组匹配到空字符串，那么反向引用<code>\1</code>将指向空字符串，也就是一个位置（有些类似后面将要讲到的零宽断言），对于”890”子字符串，8、9或0后面共有3个位置可供反向引用匹配，故最终又匹配到三个空字符串。正确的正则表达式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"1234567890"</span>.match(<span class="regexp">/\d&#123;4&#125;|\d&#123;2&#125;/g</span>); <span class="comment">// ["1234", "5678", "90"]</span></span><br></pre></td></tr></table></figure>
<p>只能重复写一次子表达式<code>\d</code></p>
<h4 id="非捕获性分组"><a href="#非捕获性分组" class="headerlink" title="非捕获性分组"></a>非捕获性分组</h4><p>非捕获性分组，通常由一对括号加上”?:”加上子表达式组成，非捕获性分组不会创建反向引用，就好像没有括号一样。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"#808080"</span>;</span><br><span class="line"><span class="keyword">var</span> output = color.replace(<span class="regexp">/#(?:\d+)/</span>,<span class="string">"$1"</span>+<span class="string">"~~"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);<span class="comment">//""</span></span><br><span class="line"><span class="built_in">console</span>.log(output);<span class="comment">//$1~~</span></span><br></pre></td></tr></table></figure>
<p>以上，(?:\d+) 表示一个非捕获性分组，由于分组不捕获任何内容，所以， <code>RegExp.$1</code> 就指向了空字符串</p>
<p>同时，由于<code>$1</code> 的反向引用不存在，因此最终它被当成了普通字符串进行替换</p>
<p>实际上，捕获性分组和无捕获性分组在搜索效率方面也没什么不同，没有哪一个比另一个更快</p>
<h3 id="正则表达式高阶技能"><a href="#正则表达式高阶技能" class="headerlink" title="正则表达式高阶技能"></a>正则表达式高阶技能</h3><p>合理地使用零宽断言，能够能分组之不能，极大地增强正则匹配能力，它甚至可以帮助你在匹配条件非常模糊的情况下快速地定位文本</p>
<p>零宽断言，又叫环视。环视只进行子表达式的匹配，匹配到的内容不保存到最终的匹配结果，由于匹配是零宽度的，故最终匹配到的只是一个位置</p>
<p>环视按照方向划分，有顺序和逆序两种(也叫前瞻和后瞻)，按照是否匹配有肯定和否定两种，组合之，便有4种环视。4种环视并不复杂，如下便是它们的描述：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>字符</strong></th>
<th style="text-align:center"><strong>描述</strong></th>
<th style="text-align:center"><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(?:<em>pattern</em>)</td>
<td style="text-align:center">非捕获性分组, 匹配pattern的位置, 但不捕获匹配结果.也就是说不创建反向引用, 就好像没有括号一样.</td>
<td style="text-align:center">‘abcd(?:e)匹配’abcde</td>
</tr>
<tr>
<td style="text-align:center">(?=<em>pattern</em>)</td>
<td style="text-align:center"><strong>顺序肯定环视</strong>, 匹配后面是pattern 的位置, 不捕获匹配结果.</td>
<td style="text-align:center">‘Windows (?=2000)’匹配 “Windows2000” 中的 “Windows”; 不匹配 “Windows3.1” 中的 “Windows”</td>
</tr>
<tr>
<td style="text-align:center">(?!<em>pattern</em>)</td>
<td style="text-align:center"><strong>顺序否定环视</strong>, 匹配后面不是 pattern 的位置, 不捕获匹配结果.</td>
<td style="text-align:center">‘Windows (?!2000)’匹配 “Windows3.1” 中的 “Windows”; 不匹配 “Windows2000” 中的 “Windows”</td>
</tr>
<tr>
<td style="text-align:center">(?&lt;=<em>pattern</em>)</td>
<td style="text-align:center"><strong>逆序肯定环视</strong>, 匹配前面是 pattern 的位置, 不捕获匹配结果.</td>
<td style="text-align:center">‘(?&lt;=Office)2000’匹配 “ Office2000” 中的 “2000”; 不匹配 “Windows2000” 中的 “2000”</td>
</tr>
<tr>
<td style="text-align:center">(?&lt;!<em>pattern</em>)</td>
<td style="text-align:center"><strong>逆序否定环视</strong>, 匹配前面不是 pattern 的位置, 不捕获匹配结果.</td>
<td style="text-align:center">‘(?&lt;!Office)2000’匹配 “ Windows2000” 中的 “2000”; 不匹配 “ Office2000” 中的 “2000”</td>
</tr>
</tbody>
</table>
<p>非捕获性分组由于结构与环视相似，故列在表中，以做对比。以上4种环视中，目前 javaScript 中只支持前两种，也就是只支持 <strong>顺序肯定环视</strong> 和 <strong>顺序否定环视</strong>。通过实例来帮助理解：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"123abc789"</span>,s;</span><br><span class="line"><span class="comment">//没有使用环视,abc直接被替换</span></span><br><span class="line">s = str.replace(<span class="regexp">/abc/</span>,<span class="number">456</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">//123456789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用了顺序肯定环视,捕获到了a前面的位置,所以abc没有被替换,只是将3替换成了3456</span></span><br><span class="line">s = str.replace(<span class="regexp">/3(?=abc)/</span>,<span class="number">3456</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">//123456abc789</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用了顺序否定环视,由于3后面跟着abc,不满意条件,故捕获失败,所以原字符串没有被替换</span></span><br><span class="line">s = str.replace(<span class="regexp">/3(?!abc)/</span>,<span class="number">3456</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">//123abc789</span></span><br></pre></td></tr></table></figure>
<h4 id="获取html片段"><a href="#获取html片段" class="headerlink" title="获取html片段"></a>获取html片段</h4><p>假如现在，js 通过 ajax 获取到一段 html 代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> responseText = <span class="string">"&lt;div data='dev.xxx.txt'&gt;&lt;/div&gt;&lt;img src='dev.xxx.png' /&gt;"</span>;</span><br></pre></td></tr></table></figure>
<p>现需要替换img标签的src 属性中的 “dev”字符串 为 “test” 字符串</p>
<p>① 由于上述 responseText 字符串中包含至少两个子字符串 “dev”，显然不能直接 replace 字符串 “dev”为 “test”</p>
<p>② 同时由于 js 中不支持逆序环视，也不能在正则中判断前缀为 “src=“，然后再替换”dev”</p>
<p>③ 注意到 img 标签的 src 属性以 “.png” 结尾，基于此，就可以使用顺序肯定环视。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/dev(?=[^']*png)/</span>; <span class="comment">//为了防止匹配到第一个dev, 通配符前面需要排除单引号或者是尖括号</span></span><br><span class="line"><span class="keyword">var</span> str = responseText.replace(reg,<span class="string">"test"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//&lt;div data='dev.xxx'&gt;&lt;/div&gt;&lt;img src='test.xxx.png' /&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然，以上不止顺序肯定环视一种解法，捕获性分组同样可以做到。那么环视高级在哪里呢? 环视高级的地方就在于它通过一次捕获就可以定位到一个位置，对于复杂的文本替换场景， 常有奇效, 而分组则需要更多的操作</p>
<h4 id="千位分割符"><a href="#千位分割符" class="headerlink" title="千位分割符"></a>千位分割符</h4><blockquote>
<p>千位分隔符，顾名思义，就是数字中的逗号。 参考西方的习惯，数字之中加入一个符号， 避免因数字太长难以直观的看出它的值。故而数字之中，每隔三位添加一个逗号，即千位分隔符</p>
</blockquote>
<p>那么怎么将一串数字转化为千位分隔符形式呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"1234567890"</span>;</span><br><span class="line">(+str).toLocaleString();<span class="comment">//"1,234,567,890"</span></span><br></pre></td></tr></table></figure>
<p>如上， <code>toLocaleString()</code> 返回当前对象的”本地化”字符串形式</p>
<ul>
<li>如果该对象是Number类型, 那么将返回该数值的按照特定符号分割的字符串形式</li>
<li>如果该对象是Array类型, 那么先将数组中的每项转化为字符串, 然后将这些字符串以指定分隔符连接起来并返回</li>
</ul>
<p><code>toLocaleString</code> 方法特殊, 有本地化特性, 对于天朝, 默认的分隔符是英文逗号. 因此使用它恰好可以将数值转化为千位分隔符形式的字符串. 如果考虑到国际化, 以上方法就有可能会失效了</p>
<p>尝试使用环视来处理下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thousand</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/(?!^)(?=([0-9]&#123;3&#125;)+$)/g</span>,<span class="string">','</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(thousand(str));<span class="comment">//"1,234,567,890"</span></span><br><span class="line"><span class="built_in">console</span>.log(thousand(<span class="string">"123456"</span>));<span class="comment">//"123,456"</span></span><br><span class="line"><span class="built_in">console</span>.log(thousand(<span class="string">"1234567879876543210"</span>));<span class="comment">//"1,234,567,879,876,543,210"</span></span><br></pre></td></tr></table></figure>
<p>上述使用到的正则分为两块。 <code>(?!^)</code> 和 <code>(?=([0-9]{3})+$)</code>。分析：</p>
<ol>
<li>“[0-9]{3}” 表示连续3位数字</li>
<li>“([0-9]{3})+” 表示连续3位数字至少出现一次或更多次</li>
<li>“([0-9]{3})+$” 表示连续3的正整数倍的数字, 直到字符串末尾</li>
<li>那么 <code>(?=([0-9]{3})+$)</code> 就表示匹配一个零宽度的位置,，并且从这个位置到字符串末尾，中间拥有3的正整数倍的数字</li>
<li>正则表达式使用全局匹配g，表示匹配到一个位置后，它会继续匹配，直至匹配不到</li>
<li>将这个位置替换为逗号，实际上就是每3位数字添加一个逗号</li>
<li>当然对于字符串”123456”这种刚好拥有3的正整数倍的数字的，当然不能在1前面添加逗号。那么使用 <code>(?!^)</code> 就指定了这个替换的位置不能为起始位置</li>
</ol>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">JavaScript</a>
        		</li>
      		
		</ul>
	</div>

      

      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-JavaScript DOM" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/12/JavaScript DOM/">JavaScript DOM</a>
    </h1>
  

        
        <a href="/2018/08/12/JavaScript DOM/" class="archive-article-date">
  	<time datetime="2018-08-11T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-08-12</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JavaScript-DOM"><a href="#JavaScript-DOM" class="headerlink" title="JavaScript DOM"></a>JavaScript DOM</h2><h3 id="DOM概述"><a href="#DOM概述" class="headerlink" title="DOM概述"></a>DOM概述</h3><p>DOM的最小组成单位叫做节点（node）。文档的树形结构（DOM树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子</p>
<blockquote>
<ul>
<li><code>Document</code>：整个文档树的顶层节点</li>
<li><code>DocumentType</code>：<code>doctype</code>标签（比如<code>&lt;!DOCTYPE html&gt;</code>）</li>
<li><code>Element</code>：网页的各种HTML标签（比如<code>&lt;body&gt;</code>、<code>&lt;a&gt;</code>等）</li>
<li><code>Attribute</code>：网页元素的属性（比如<code>class=&quot;right&quot;</code>）</li>
<li><code>Text</code>：标签之间或标签包含的文本</li>
<li><code>Comment</code>：注释</li>
<li><code>DocumentFragment</code>：文档的片段</li>
</ul>
<p>这七种节点都属于浏览器原生提供的节点对象的派生对象，具有一些共同的属性和方法</p>
</blockquote>
<h4 id="特征相关属性"><a href="#特征相关属性" class="headerlink" title="特征相关属性"></a>特征相关属性</h4><p><strong>Node.nodeName，Node.nodeType，Node.nodeValue</strong></p>
<p><code>Node.nodeName</code>属性返回节点的名称，<code>Node.nodeType</code>属性返回节点类型的常数值，<code>Node.nodeValue</code>属性返回一个字符串，表示当前节点本身的文本值，该属性可读写</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">nodeName</th>
<th style="text-align:center">nodeType</th>
<th style="text-align:center">nodeValue</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ELEMENT_NODE</td>
<td style="text-align:center">大写的HTML元素名</td>
<td style="text-align:center">1</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">ATTRIBUTE_NODE</td>
<td style="text-align:center">等同于Attr.name</td>
<td style="text-align:center">2</td>
<td style="text-align:center">属性的值</td>
</tr>
<tr>
<td style="text-align:center">TEXT_NODE</td>
<td style="text-align:center">#text</td>
<td style="text-align:center">3</td>
<td style="text-align:center">节点的内容</td>
</tr>
<tr>
<td style="text-align:center">COMMENT_NODE</td>
<td style="text-align:center">#comment</td>
<td style="text-align:center">8</td>
<td style="text-align:center">节点的内容</td>
</tr>
<tr>
<td style="text-align:center">DOCUMENT_NODE</td>
<td style="text-align:center">document</td>
<td style="text-align:center">9</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">DOCUMENT_TYPE_NODE</td>
<td style="text-align:center">等同于DocumentType.name</td>
<td style="text-align:center">10</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">DOCUMENT_FRAGMENT_NODE</td>
<td style="text-align:center">#document-fragment</td>
<td style="text-align:center">11</td>
<td style="text-align:center">null</td>
</tr>
</tbody>
</table>
<p><strong>Node.textContent</strong></p>
<p><code>Node.textContent</code>属性自动忽略当前节点内部的HTML标签，返回当前节点和它的所有后代节点的文本内容；该属性是可读写的，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点</p>
<p><strong>Node.innerText，Node.outerText</strong></p>
<p><code>Node.innerText</code>属性属性自动忽略当前节点内部的HTML标签，返回当前节点和它的所有后代节点的文本内容；该属性是可读写的。</p>
<p><code>Node.outerText</code>属性与<code>Node.innerText</code>功能类似，但是它能够覆盖原有的元素</p>
<p>两者都没有被纳入HTML5规范</p>
<p><strong>Node.baseURI</strong></p>
<p><code>Node.baseURI</code>属性返回一个字符串，表示当前网页的绝对路径。如果无法取到这个值，则返回<code>null</code>。浏览器根据这个属性，计算网页上的相对路径的URL。该属性为只读。该属性的值一般由当前网址的URL（即<code>window.location</code>属性）决定，但是可以使用HTML的<code>&lt;base&gt;</code>标签，改变该属性的值</p>
<h4 id="相关节点属性"><a href="#相关节点属性" class="headerlink" title="相关节点属性"></a>相关节点属性</h4><p><strong>Node.ownerDocument</strong></p>
<p><code>Node.ownerDocument</code>属性返回当前节点所在的顶层文档对象，即<code>document</code>对象。<code>document</code>对象本身的<code>ownerDocument</code>属性，返回<code>null</code></p>
<p><strong>Node.parentNode</strong></p>
<p><code>Node.parentNode</code>属性返回当前节点的父节点。对于document节点和documentfragment节点，它们的父节点都是null。另外，对于那些生成后还没插入DOM树的节点，父节点也是null</p>
<p><strong>Node.parentElement</strong></p>
<p><code>Node.parentElement</code>属性返回当前节点的父Element节点。如果当前节点没有父节点，或者父节点类型不是Element节点，则返回null</p>
<p><strong>Node.childNodes</strong></p>
<p><code>Node.childNodes</code>属性返回一个NodeList集合，成员包括当前节点的所有子节点。注意，除了HTML元素节点，该属性返回的还包括Text节点和Comment节点</p>
<p><strong>Node.firstChild，Node.lastChild</strong></p>
<p><code>Node.firstChild</code>属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回<code>null</code></p>
<p><code>Node.lastChild</code>属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回<code>null</code></p>
<p><strong>Node.nextSibling，Node.previousSibling</strong></p>
<p><code>Node.nextSibling</code>属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回<code>null</code></p>
<p><code>Node.previousSibling</code>属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回<code>null</code></p>
<h4 id="节点对象方法"><a href="#节点对象方法" class="headerlink" title="节点对象方法"></a>节点对象方法</h4><p><strong>Node.appendChild()</strong></p>
<p><code>Node.appendChild</code>方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点；如果参数节点是DOM中已经存在的节点，<code>appendChild</code>方法会将其从原来的位置，移动到新位置</p>
<p><strong>Node.insertBefore()</strong></p>
<p><code>Node.insertBefore</code>方法用于将某个节点插入当前节点的指定位置。它接受两个参数，第一个参数是所要插入的节点，第二个参数是当前节点的一个子节点，新的节点将插在这个节点的前面。该方法返回被插入的新节点；如果所要插入的节点是当前DOM现有的节点，则该节点将从原有的位置移除，插入新的位置</p>
<p><strong>Node.hasChildNodes()</strong></p>
<p><code>Node.hasChildNodes</code>方法返回一个布尔值，表示当前节点是否有子节点</p>
<p><strong>Node.cloneNode()</strong></p>
<p><code>Node.cloneNode</code>方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点，默认是<code>false</code>，即不克隆子节点；克隆一个节点，会拷贝该节点的所有属性，但是会丧失<code>addEventListener</code>方法和<code>on-</code>属性（即<code>node.onclick = fn</code>）</p>
<p><strong>Node.removeChild()</strong></p>
<p><code>Node.removeChild</code>方法接受一个子节点作为参数，用于从当前节点移除该子节点。它返回被移除的子节点；被移除的节点依然存在于内存之中，但不再是DOM的一部分。所以，一个节点移除以后，依然可以使用它，比如插入到另一个节点下面</p>
<p><strong>Node.replaceChild()</strong></p>
<p><code>Node.replaceChild</code>方法用于将一个新的节点，替换当前节点的某一个子节点。它接受两个参数，第一个参数是用来替换的新节点，第二个参数将要被替换走的子节点。它返回被替换走的那个节点</p>
<p><strong>Node.contains()</strong></p>
<p><code>Node.contains</code>方法接受一个节点作为参数，返回一个布尔值，表示参数节点是否为当前节点的后代节点</p>
<p><strong>Node.compareDocumentPosition()</strong></p>
<p><code>compareDocumentPosition</code>方法的用法，与<code>contains</code>方法完全一致，返回一个7个比特位的二进制值，表示参数节点与当前节点的关系</p>
<p><strong>Node.isEqualNode()</strong></p>
<p><code>Node.isEqualNode</code>方法接受一个节点作为参数，返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同</p>
<p><strong>Node.normalize()</strong></p>
<p><code>Node.normailize</code>方法用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个</p>
<h4 id="NodeList对象"><a href="#NodeList对象" class="headerlink" title="NodeList对象"></a>NodeList对象</h4><p><code>NodeList</code>实例对象是一个类似数组的对象，它的成员是节点对象。<code>Node.childNodes</code>、<code>document.querySelectorAll()</code>返回的都是<code>NodeList</code>实例对象</p>
<h4 id="HTMLCollection对象"><a href="#HTMLCollection对象" class="headerlink" title="HTMLCollection对象"></a>HTMLCollection对象</h4><p><code>HTMLCollection</code>实例对象与<code>NodeList</code>实例对象类似，也是节点的集合，返回一个类似数组的对象。<code>document.links</code>、<code>docuement.forms</code>、<code>document.images</code>等属性，返回的都是<code>HTMLCollection</code>实例对象</p>
<p><code>HTMLCollection</code>与<code>NodeList</code>的区别有以下几点：</p>
<p>（1）<code>HTMLCollection</code>实例对象的成员只能是<code>Element</code>节点，<code>NodeList</code>实例对象的成员可以包含其他节点</p>
<p>（2）<code>HTMLCollection</code>实例对象都是动态集合，节点的变化会实时反映在集合中。<code>NodeList</code>实例对象可以是静态集合</p>
<p>（3）<code>HTMLCollection</code>实例对象可以用<code>id</code>属性或<code>name</code>属性引用节点元素，<code>NodeList</code>只能使用数字索引引用</p>
<h4 id="ParentNode接口"><a href="#ParentNode接口" class="headerlink" title="ParentNode接口"></a>ParentNode接口</h4><p>ParentNode接口用于获取Element子节点。Element节点、Document节点和DocumentFragment节点，部署了ParentNode接口。凡是这三类节点，都具有以下四个属性，用于获取Element子节点：</p>
<p><strong>（1）children</strong></p>
<p>children属性返回一个动态的HTMLCollection集合，由当前节点的所有Element子节点组成</p>
<p><strong>（2）firstElementChild</strong></p>
<p>firstElementChild属性返回当前节点的第一个Element子节点，如果不存在任何Element子节点，则返回null</p>
<p><strong>（3）lastElementChild</strong></p>
<p>lastElementChild属性返回当前节点的最后一个Element子节点，如果不存在任何Element子节点，则返回null</p>
<p><strong>（4）childElementCount</strong></p>
<p>childElementCount属性返回当前节点的所有Element子节点的数目</p>
<p>ParentNode接口方法：</p>
<p><strong>（1）append()</strong></p>
<p>append方法在 ParentNode的最后一个子节点之后插入一组 <code>Node</code>对象或 <code>DOMString</code>对象</p>
<p><strong>（2）prepend()</strong></p>
<p>prepend方法可以在父节点的第一个子节点之前插入一系列<code>Node</code>]对象或者<code>DOMString</code>对象</p>
<h4 id="ChildNode-接口"><a href="#ChildNode-接口" class="headerlink" title="ChildNode 接口"></a>ChildNode 接口</h4><p><code>ChildNode</code>接口用于处理子节点（包含但不限于<code>Element</code>子节点）。<code>Element</code>节点、<code>DocumentType</code>节点和<code>CharacterData</code>接口，部署了<code>ChildNode</code>接口。凡是这三类节点（接口），都可以使用下面四个方法：</p>
<p><strong>（1）remove()</strong></p>
<p>remove方法用于移除当前节点</p>
<p><strong>（2）before()</strong></p>
<p>before方法用于在当前节点的前面，插入一个同级节点。如果参数是节点对象，插入DOM的就是该节点对象；如果参数是文本，插入DOM的就是参数对应的文本节点</p>
<p><strong>（3）after()</strong></p>
<p>after方法用于在当前节点的后面，插入一个同级节点。如果参数是节点对象，插入DOM的就是该节点对象；如果参数是文本，插入DOM的就是参数对应的文本节点</p>
<p><strong>（4）replaceWith()</strong></p>
<p>replaceWith方法使用参数指定的节点，替换当前节点。如果参数是节点对象，替换当前节点的就是该节点对象；如果参数是文本，替换当前节点的就是参数对应的文本节点</p>
<h4 id="Mutation-Observer"><a href="#Mutation-Observer" class="headerlink" title="Mutation Observer"></a>Mutation Observer</h4><p>Mutation Observer API用来监视DOM变动。DOM的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个API都可以得到通知；它等待所有脚本任务完成后，才会运行，即采用异步方式</p>
<p><strong>构造函数</strong></p>
<p><code>var observer = new MutationObserver(callback);</code></p>
<p><strong>实例方法</strong></p>
<blockquote>
<ul>
<li>observe()：<code>observe</code>方法用来开始监听，它接受两个参数。第一个参数是所要观察的 DOM 节点，第二个参数是一个配置对象，用来指定所要观察的特定变动</li>
<li>disconnect()：<code>disconnect</code>方法用来停止观察</li>
<li>takeRecords()：<code>takeRecords</code>方法用来清除变动记录</li>
</ul>
</blockquote>
<p><strong>MutationRecord对象</strong></p>
<p><code>MutationRecord</code>对象包含了与变动相关的所有信息。Mutation Observer 处理的是一个个<code>MutationRecord</code>对象所组成的数组</p>
<h3 id="Doucment节点"><a href="#Doucment节点" class="headerlink" title="Doucment节点"></a>Doucment节点</h3><p><code>document</code>节点是文档的根节点，每张网页都有自己的<code>document</code>节点。<code>window.document</code>属性就指向这个节点。只要浏览器开始载入HTML文档，这个节点对象就存在了，可以直接调用。</p>
<p><code>document</code>节点有不同的办法可以获取。</p>
<blockquote>
<ul>
<li>对于正常的网页，直接使用<code>document</code>或<code>window.document</code></li>
<li>对于<code>iframe</code>载入的网页，使用<code>iframe</code>节点的<code>contentDocument</code>属性</li>
<li>对Ajax操作返回的文档，使用XMLHttpRequest对象的<code>responseXML</code>属性</li>
<li>对于包含某个节点的文档，使用该节点的<code>ownerDocument</code>属性</li>
</ul>
</blockquote>
<h4 id="内部节点属性"><a href="#内部节点属性" class="headerlink" title="内部节点属性"></a>内部节点属性</h4><p><strong>document.doctype，document.documentElement，document.defaultView</strong></p>
<p>对于HTML文档来说，<code>document</code>对象一般有两个子节点。</p>
<p>第一个子节点是<code>document.doctype</code>，它是一个对象，包含了当前文档类型（Document Type Declaration，简写DTD）信息。如果网页没有声明DTD，该属性返回<code>null</code></p>
<p>第二个子节点是<code>document.documentElement</code>，返回当前文档的根节点（root）。该节点紧跟在<code>document.doctype</code>节点后面。对于HTML网页，该属性返回<code>&lt;html&gt;</code>节点</p>
<p><code>document.defaultView</code>属性，在浏览器中返回<code>document</code>对象所在的<code>window</code>对象，否则返回<code>null</code></p>
<p><strong>document.body，document.head</strong></p>
<p><code>document.head</code>属性返回当前文档的<code>&lt;head&gt;</code>节点</p>
<p><code>document.body</code>属性返回当前文档的<code>&lt;body&gt;</code>节点</p>
<p><strong>document.activeElement</strong></p>
<p><code>document.activeElement</code>属性返回当前文档中获得焦点的那个元素。用户通常可以使用Tab键移动焦点，使用空格键激活焦点</p>
<h4 id="节点集合属性"><a href="#节点集合属性" class="headerlink" title="节点集合属性"></a>节点集合属性</h4><p><strong>document.links，document.forms，document.images，document.embeds</strong></p>
<p><code>document.links</code>属性返回当前文档所有设定了<code>href</code>属性的<code>a</code>及<code>area</code>元素</p>
<p><code>document.forms</code>属性返回页面中所有表单元素<code>form</code></p>
<p><code>document.images</code>属性返回页面所有图片元素，即<code>img</code>标签</p>
<p><code>document.embeds</code>属性返回网页中所有嵌入对象，即<code>embed</code>标签</p>
<p>以上四个属性返回的都是<code>HTMLCollection</code>对象实例，由于<code>HTMLCollection</code>实例可以用HTML元素的<code>id</code>或<code>name</code>属性引用，因此如果一个元素有<code>id</code>或<code>name</code>属性，就可以在上面这四个属性上引用</p>
<p><strong>document.scripts，document.styleSheets</strong></p>
<p><code>document.scripts</code>属性返回当前文档的所有脚本，即<code>script</code>标签</p>
<p><code>document.styleSheets</code>属性返回一个类似数组的对象，代表当前网页的所有样式表。每个样式表对象都有<code>cssRules</code>属性</p>
<h4 id="文档信息属性"><a href="#文档信息属性" class="headerlink" title="文档信息属性"></a>文档信息属性</h4><p><strong>document.documentURI，document.URL</strong></p>
<p><code>document.documentURI</code>属性和<code>document.URL</code>属性都返回一个字符串，表示当前文档的网址。</p>
<p>不同之处是<code>documentURI</code>属性可用于所有文档（包括 XML 文档），<code>URL</code>属性只能用于 HTML 文档</p>
<p><strong>document.domain</strong></p>
<p><code>document.domain</code>属性返回当前文档的域名，如果无法获取域名，该属性返回<code>null</code></p>
<p><strong>document.lastModified</strong></p>
<p><code>document.lastModified</code>属性返回当前文档最后修改的时间戳，格式为字符串</p>
<p><strong>document.location</strong></p>
<p><code>document.location</code>属性返回<code>location</code>对象，提供了当前文档的URL信息</p>
<p><code>document.location</code>属性与<code>window.location</code>属性等价</p>
<p><strong>document.referrer，document.title，document.characterSet</strong></p>
<p><code>document.referrer</code>属性返回一个字符串，表示当前文档的访问来源，如果是无法获取来源或是用户直接键入网址，而不是从其他网页点击，则返回一个空字符串；<code>document.referrer</code>的值，总是与HTTP头信息的<code>Referer</code>保持一致，但是它的拼写有两个<code>r</code></p>
<p><code>document.title</code>属性返回当前文档的标题，该属性是可写的</p>
<p><code>document.characterSet</code>属性返回渲染当前文档的字符集</p>
<p><strong>document.readyState</strong></p>
<p><code>document.readyState</code>属性返回当前文档的状态，共有三种可能的值：</p>
<blockquote>
<ul>
<li><code>loading</code>：加载HTML代码阶段（尚未完成解析）</li>
<li><code>interactive</code>：加载外部资源阶段时</li>
<li><code>complete</code>：加载完成时</li>
</ul>
</blockquote>
<p><strong>document.designMode</strong></p>
<p><code>document.designMode</code>属性控制当前文档是否可编辑</p>
<p><strong>document.implementation</strong></p>
<p><code>document.implementation</code>属性返回一个对象，用来甄别当前环境部署了哪些DOM相关接口</p>
<p><code>implementation</code>属性的<code>hasFeature</code>方法，可以判断当前环境是否部署了特定版本的特定接口</p>
<p><strong>document.compatMode</strong></p>
<p><code>document.compatMode</code>属性返回浏览器处理文档的模式，可能的值为<code>BackCompat</code>（向后兼容模式）和<code>CSS1Compat</code>（严格模式）</p>
<p><strong>document.cookie</strong></p>
<p><code>document.cookie</code>属性用来操作浏览器Cookie</p>
<h4 id="读写相关的方法"><a href="#读写相关的方法" class="headerlink" title="读写相关的方法"></a>读写相关的方法</h4><p><strong>document.open()，document.close()</strong></p>
<p><code>document.open</code>方法用于新建一个文档，供write方法写入内容，它实际上等于清除当前文档，重新写入内容。不要将此方法与<code>window.open()</code>混淆，后者用来打开一个新窗口，与当前文档无关</p>
<p><code>document.close</code>方法用于关闭<code>open</code>方法所新建的文档。一旦关闭，<code>write</code>方法就无法写入内容了。如果再调用<code>write</code>方法，就等同于又调用<code>open</code>方法，新建一个文档，再写入内容</p>
<p><strong>document.write()，document.writeln()</strong></p>
<p><code>document.write</code>方法用于向当前文档写入内容。注意，<code>document.write</code>会当作HTML代码解析，不会转义</p>
<p><code>document.writeln</code>方法与<code>write</code>方法完全一致，除了会在输出内容的尾部添加换行符。注意，<code>writeln</code>方法添加的是ASCII码的换行符，渲染成HTML网页时不起作用，即在网页上显示不出换行</p>
<h4 id="查找节点的方法"><a href="#查找节点的方法" class="headerlink" title="查找节点的方法"></a>查找节点的方法</h4><p><strong>document.querySelector()，document.querySelectorAll()</strong></p>
<p><code>document.querySelector</code>方法接受一个CSS选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回<code>null</code></p>
<p><code>document.querySelectorAll</code>方法与<code>querySelector</code>用法类似，区别是返回一个<code>NodeList</code>对象，包含所有匹配给定选择器的节点</p>
<p>这两个方法的参数，可以是逗号分隔的多个CSS选择器，返回匹配其中一个选择器的元素节点</p>
<p>两个方法都支持复杂的CSS选择器，但是，它们不支持CSS伪元素的选择器（比如<code>:first-line</code>和<code>:first-letter</code>）和伪类的选择器（比如<code>:link</code>和<code>:visited</code>），即无法选中伪元素和伪类</p>
<blockquote>
<p>这两个方法除了定义在<code>document</code>对象上，还定义在元素节点上，即在元素节点上也可以调用</p>
</blockquote>
<p><strong>document.getElementsByTagName()</strong></p>
<p><code>document.getElementsByTagName</code>方法返回所有指定HTML标签的元素，返回值是一个类似数组的<code>HTMLCollection</code>对象</p>
<blockquote>
<p>该方法不仅可以在<code>document</code>对象上调用，也可以在任何元素节点上调用</p>
</blockquote>
<p><strong>document.getElementsByClassName()</strong></p>
<p><code>document.getElementsByClassName</code>方法返回一个类似数组的对象（<code>HTMLCollection</code>实例对象），包括了所有<code>class</code>名字符合指定条件的元素</p>
<blockquote>
<p>该方法不仅可以在<code>document</code>对象上调用，也可以在任何元素节点上调用</p>
</blockquote>
<p><strong>document.getElementsByName()</strong></p>
<p><code>document.getElementsByName</code>方法用于选择拥有<code>name</code>属性的HTML元素（比如<code>&lt;form&gt;</code>、<code>&lt;radio&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;frame&gt;</code>、<code>&lt;embed&gt;</code>和<code>&lt;object&gt;</code>等），返回一个类似数组的的对象（<code>NodeList</code>对象的实例）</p>
<blockquote>
<p>这个方法只能在<code>document</code>对象上使用，不能在其他元素节点上使用</p>
</blockquote>
<p><strong>document.getElementById()</strong></p>
<p><code>document.getElementById()</code>方法返回匹配指定<code>id</code>属性的元素节点。如果没有发现匹配的节点，则返回<code>null</code></p>
<blockquote>
<p>这个方法只能在<code>document</code>对象上使用，不能在其他元素节点上使用</p>
</blockquote>
<p><strong>document.elementFromPoint()</strong></p>
<p><code>document.elementFromPoint</code>方法返回位于页面指定位置最上层的Element子节点</p>
<p><code>elementFromPoint</code>方法的两个参数，依次是相对于当前视口左上角的横坐标和纵坐标，单位是像素。如果位于该位置的HTML元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。如果坐标值无意义（比如负值或超过视口大小），则返回<code>null</code></p>
<h4 id="生成节点的方法"><a href="#生成节点的方法" class="headerlink" title="生成节点的方法"></a>生成节点的方法</h4><p><strong>document.createElement()</strong></p>
<p><code>document.createElement</code>方法用来生成网页元素节点。<code>createElement</code>方法的参数为元素的标签名，即元素节点的<code>tagName</code>属性</p>
<p><strong>document.createTextNode()</strong></p>
<p><code>document.createTextNode</code>方法用来生成文本节点，参数为所要生成的文本节点的内容</p>
<p>这个方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作HTML代码渲染</p>
<p><strong>document.createAttribute()</strong></p>
<p><code>document.createAttribute</code>方法生成一个新的属性对象节点，并返回它</p>
<p><strong>document.createDocumentFragment()</strong></p>
<p><code>document.createDocumentFragment</code>方法生成一个DocumentFragment对象</p>
<p>DocumentFragment对象是一个存在于内存的DOM片段，但是不属于当前文档，常常用来生成较复杂的DOM结构，然后插入当前文档</p>
<h4 id="事件相关的方法"><a href="#事件相关的方法" class="headerlink" title="事件相关的方法"></a>事件相关的方法</h4><p><strong>document.createEvent()</strong></p>
<p><code>document.createEvent</code>方法生成一个事件对象，该对象可以被<code>element.dispatchEvent</code>方法使用，触发指定事件</p>
<p>createEvent方法的参数是事件类型，比如UIEvents、MouseEvents、MutationEvents、HTMLEvents</p>
<p><strong>document.addEventListener()，document.removeEventListener()，document.dispatchEvent()</strong></p>
<p>以下三个方法与<code>document</code>节点的事件相关。这些方法都继承自EventTarget接口：</p>
<ul>
<li><code>Element.addEventListener()</code>：添加事件的回调函数</li>
<li><code>Element.removeEventListener()</code>：移除事件监听函数</li>
<li><code>Element.dispatchEvent()</code>：触发事件</li>
</ul>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p><strong>document.hasFocus()</strong></p>
<p><code>document.hasFocus</code>方法返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点</p>
<p><strong>document.createNodeIterator()，document.createTreeWalker()</strong></p>
<p><code>document.createNodeIterator</code>方法返回一个DOM的子节点遍历器</p>
<p>createNodeIterator方法的第一个参数为遍历器的根节点，第二个参数为所要遍历的节点类型</p>
<p><code>document.createTreeWalker</code>方法返回一个DOM的子树遍历器。它与createNodeIterator方法的区别在于，后者只遍历子节点，而它遍历整个子树</p>
<p>createTreeWalker方法的第一个参数，是所要遍历的根节点，第二个参数指定所要遍历的节点类型</p>
<p><strong>document.adoptNode()</strong></p>
<p><code>document.adoptNode</code>方法将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点</p>
<p><strong>document.importNode()</strong></p>
<p><code>document.importNode</code>方法从外部文档拷贝指定节点，插入当前文档</p>
<p><strong>document.getSelection()</strong></p>
<p>这个方法指向<code>window.getSelection()</code></p>
<h3 id="Element节点"><a href="#Element节点" class="headerlink" title="Element节点"></a>Element节点</h3><h4 id="特征相关属性-1"><a href="#特征相关属性-1" class="headerlink" title="特征相关属性"></a>特征相关属性</h4><p><strong>Element.attributes</strong></p>
<p><code>Element.attributes</code>属性返回一个类似数组的对象，成员是当前元素节点的所有属性节点</p>
<p><strong>Element.id，Element.tagName</strong></p>
<p><code>Element.id</code>属性返回指定元素的<code>id</code>属性，该属性可读写</p>
<p><code>Element.tagName</code>属性返回指定元素的大写标签名，与<code>nodeName</code>属性的值相等</p>
<p><strong>Element.innerHTML</strong></p>
<p><code>Element.innerHTML</code>属性返回该元素包含的 HTML 代码。该属性可读写，常用来设置某个节点的内容。如果文本节点中包含<code>&amp;</code>、小于号（<code>&lt;</code>）和大于号（<code>&gt;</code>），<code>innerHTML</code>属性会将它们转为实体形式<code>&amp;amp;</code>、<code>&amp;lt;</code>、<code>&amp;gt;</code></p>
<p><strong>Element.outerHTML</strong></p>
<p><code>Element.outerHTML</code>属性返回一个字符串，内容为指定元素节点的所有HTML代码，包括它自身和包含的所有子元素。<code>outerHTML</code>属性是可读写的，对它进行赋值，等于替换掉当前元素</p>
<p><strong>Element.className，Element.classList</strong></p>
<p><code>className</code>属性用来读写当前元素节点的<code>class</code>属性。它的值是一个字符串，每个<code>class</code>之间用空格分割<code>classList</code>属性则返回一个类似数组的对象，当前元素节点的每个<code>class</code>就是这个对象的一个成员</p>
<p><code>classList</code>对象有下列方法：</p>
<blockquote>
<ul>
<li>add()：增加一个class</li>
<li>remove()：移除一个class</li>
<li>contains()：检查当前元素是否包含某个class</li>
<li>toggle()：将某个class移入或移出当前元素</li>
<li>item()：返回指定索引位置的class</li>
<li>toString()：将class的列表转为字符串</li>
</ul>
</blockquote>
<h4 id="盒状模型相关属性"><a href="#盒状模型相关属性" class="headerlink" title="盒状模型相关属性"></a>盒状模型相关属性</h4><p><strong>Element.clientHeight，Element.clientWidth</strong></p>
<p><code>Element.clientHeight</code>属性返回元素节点可见部分的高度</p>
<p><code>Element.clientWidth</code>属性返回元素节点可见部分的宽度</p>
<p>所谓“可见部分”，指的是不包括溢出（overflow）的大小，只返回该元素在容器中占据的大小，对于有滚动条的元素来说，它们等于滚动条围起来的区域大小。这两个属性的值包括Padding、但不包括滚动条、边框和Margin，单位为像素</p>
<p><strong>Element.clientLeft，Element.clientTop</strong></p>
<p><code>Element.clientLeft</code>属性等于元素节点左边框的宽度</p>
<p><code>Element.clientTop</code>属性等于网页元素顶部边框的宽度</p>
<p>这两个属性包括滚动条的宽度，但不包括Margin和Padding，单位为像素</p>
<p><strong>Element.scrollHeight，Element.scrollWidth</strong></p>
<p><code>Element.scrollHeight</code>属性返回某个网页元素的总高度</p>
<p><code>Element.scrollWidth</code>属性返回总宽度</p>
<p>它们都包括由于溢出容器而无法显示在网页上的那部分高度或宽度。这两个属性是只读属性</p>
<p>它们返回的是整个元素的高度或宽度，包括由于存在滚动条而不可见的部分。默认情况下，它们包括Padding，但不包括Border和Margin</p>
<p><strong>Element.scrollLeft，Element.scrollTop</strong></p>
<p><code>Element.scrollLeft</code>属性表示网页元素的水平滚动条向右侧滚动的像素数量</p>
<p><code>Element.scrollTop</code>属性表示网页元素的垂直滚动条向下滚动的像素数量</p>
<p>这两个属性都可读写，设置该属性的值，会导致浏览器将指定元素自动滚动到相应的位置</p>
<p><strong>Element.offsetHeight，Element.offsetWidth</strong></p>
<p><code>Element.offsetHeight</code>属性返回元素的垂直高度</p>
<p><code>Element.offsetWidth</code>属性返回水平宽度</p>
<p>这两个属性值包括<code>Padding</code>和<code>Border</code>、以及滚动条。它们的单位为像素，都是只读</p>
<p><strong>Element.offsetLeft，Element.offsetTop</strong></p>
<p><code>Element.offsetLeft</code>返回当前元素左上角相对于<code>Element.offsetParent</code>节点的水平位移</p>
<p><code>Element.offsetTop</code>返回垂直位移，单位为像素。通常，这两个值是指相对于父节点的位移</p>
<p>它们的单位为像素，都是只读</p>
<p><strong>Element.style</strong></p>
<p>每个元素节点都有<code>style</code>用来读写该元素的行内样式信息</p>
<h4 id="相关节点属性-1"><a href="#相关节点属性-1" class="headerlink" title="相关节点属性"></a>相关节点属性</h4><p><strong>Element.children，Element.childElementCount</strong></p>
<p><code>Element.children</code>属性返回一个<code>HTMLCollection</code>对象，包括当前元素节点的所有子元素</p>
<p>这个属性与<code>Node.childNodes</code>属性的区别是，它只包括HTML元素类型的子节点，不包括其他类型的子节点</p>
<p><code>Element.childElementCount</code>属性返回当前元素节点包含的子HTML元素节点的个数，与<code>Element.children.length</code>的值相同</p>
<p><strong>Element.firstElementChild，Element.lastElementChild</strong></p>
<p><code>Element.firstElementChild</code>属性返回第一个HTML元素类型的子节点</p>
<p><code>Element.lastElementChild</code>返回最后一个HTML元素类型的子节点</p>
<p>如果没有HTML类型的子节点，这两个属性返回<code>null</code></p>
<p><strong>Element.nextElementSibling，Element.previousElementSibling</strong></p>
<p><code>Element.nextElementSibling</code>属性返回当前HTML元素节点的后一个同级HTML元素节点，如果没有则返回<code>null</code></p>
<p><code>Element.previousElementSibling</code>属性返回当前HTML元素节点的前一个同级HTML元素节点，如果没有则返回<code>null</code></p>
<p><strong>Element.offsetParent</strong></p>
<p><code>Element.offsetParent</code>属性返回当前 HTML 元素的最靠近的、并且 CSS 的<code>position</code>属性不等于<code>static</code>的上层元素</p>
<h4 id="属性相关方法"><a href="#属性相关方法" class="headerlink" title="属性相关方法"></a>属性相关方法</h4><p>元素节点提供以下四个方法，用来操作HTML标签的属性：</p>
<blockquote>
<ul>
<li><code>Element.getAttribute()</code>：读取指定属性</li>
<li><code>Element.setAttribute()</code>：设置指定属性</li>
<li><code>Element.hasAttribute()</code>：返回一个布尔值，表示当前元素节点是否有指定的属性</li>
<li><code>Element.removeAttribute()</code>：移除指定属性</li>
</ul>
</blockquote>
<h4 id="查找相关方法"><a href="#查找相关方法" class="headerlink" title="查找相关方法"></a>查找相关方法</h4><p>以下四个方法用来查找与当前元素节点相关的节点。这四个方法也部署在<code>document</code>对象上，用法完全一致：</p>
<blockquote>
<ul>
<li><code>Element.querySelector()</code></li>
<li><code>Element.querySelectorAll()</code></li>
<li><code>Element.getElementsByTagName()</code></li>
<li><code>Element.getElementsByClassName()</code></li>
</ul>
</blockquote>
<p><strong>Element.closest()</strong></p>
<p><code>Element.closest</code>方法返回当前元素节点的最接近的父元素（或者当前节点本身），条件是必须匹配给定的CSS选择器。如果不满足匹配，则返回null</p>
<p><strong>Element.match()</strong></p>
<p><code>Element.match</code>方法返回一个布尔值，表示当前元素是否匹配给定的CSS选择器</p>
<h4 id="事件相关方法"><a href="#事件相关方法" class="headerlink" title="事件相关方法"></a>事件相关方法</h4><p>以下三个方法与<code>Element</code>节点的事件相关。这些方法都继承自<code>EventTarget</code>接口：</p>
<blockquote>
<ul>
<li><code>Element.addEventListener()</code>：添加事件的回调函数</li>
<li><code>Element.removeEventListener()</code>：移除事件监听函数</li>
<li><code>Element.dispatchEvent()</code>：触发事件</li>
</ul>
</blockquote>
<h4 id="其他方法-1"><a href="#其他方法-1" class="headerlink" title="其他方法"></a>其他方法</h4><p><strong>Element.scrollIntoView()</strong></p>
<p><code>Element.scrollIntoView</code>方法滚动当前元素</p>
<p>该方法可以接受一个布尔值作为参数。如果为<code>true</code>，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为<code>false</code>，表示元素的底部与当前区域的可见部分的尾部对齐（前提是当前区域可滚动）。如果没有提供该参数，默认为<code>true</code></p>
<p><strong>Element.getBoundingClientRect()</strong></p>
<p><code>Element.getBoundingClientRect</code>方法返回一个对象，该对象提供当前元素节点的大小、位置等信息，基本上就是CSS盒状模型提供的所有信息</p>
<p>返回的对象具有以下属性：（全部为只读）</p>
<blockquote>
<ul>
<li><code>x</code>：元素左上角相对于视口的横坐标</li>
<li><code>left</code>：元素左上角相对于视口的横坐标，与<code>x</code>属性相等</li>
<li><code>right</code>：元素右边界相对于视口的横坐标（等于<code>x</code>加上<code>width</code>）</li>
<li><code>width</code>：元素宽度（等于<code>right</code>减去<code>left</code>）</li>
<li><code>y</code>：元素顶部相对于视口的纵坐标</li>
<li><code>top</code>：元素顶部相对于视口的纵坐标，与<code>y</code>属性相等</li>
<li><code>bottom</code>：元素底部相对于视口的纵坐标</li>
<li><code>height</code>：元素高度（等于<code>y</code>加上<code>height</code>）</li>
</ul>
</blockquote>
<p><strong>Element.getClientRects()</strong></p>
<p><code>Element.getClientRects</code>方法返回一个类似数组的对象，里面是当前元素在页面上形成的所有矩形。每个矩形都有<code>bottom</code>、<code>height</code>、<code>left</code>、<code>right</code>、<code>top</code>和<code>width</code>六个属性，表示它们相对于视口的四个坐标，以及本身的高度和宽度</p>
<p><strong>Element.insertAdjacentHTML()</strong></p>
<p><code>Element.insertAdjacentHTML</code>方法解析HTML字符串，然后将生成的节点插入DOM树的指定位置</p>
<p>该方法接受两个参数，第一个是指定位置，第二个是待解析的字符串</p>
<p>指定位置共有四个：</p>
<blockquote>
<ul>
<li><code>beforebegin</code>：在当前元素节点的前面</li>
<li><code>afterbegin</code>：在当前元素节点的里面，插在它的第一个子元素之前</li>
<li><code>beforeend</code>：在当前元素节点的里面，插在它的最后一个子元素之后</li>
<li><code>afterend</code>：在当前元素节点的后面</li>
</ul>
</blockquote>
<p><strong>Element.remove()</strong></p>
<p><code>Element.remove</code>方法用于将当前元素节点从DOM树删除</p>
<p><strong>Element.focus()</strong></p>
<p><code>Element.focus</code>方法用于将当前页面的焦点，转移到指定元素上</p>
<h3 id="Attribute节点"><a href="#Attribute节点" class="headerlink" title="Attribute节点"></a>Attribute节点</h3><h4 id="Element-attributes属性"><a href="#Element-attributes属性" class="headerlink" title="Element.attributes属性"></a>Element.attributes属性</h4><p>HTML元素对象有一个<code>attributes</code>属性，返回一个类似数组的动态对象，成员是该元素标签的所有属性节点对象，属性的实时变化都会反映在这个节点对象上。其他类型的节点对象，虽然也有<code>attributes</code>属性，但是返回的都是<code>null</code>，因此可以把这个属性视为元素对象独有的</p>
<p>属性节点对象有<code>name</code>和<code>value</code>属性，对应该属性的属性名和属性值，等同于<code>nodeName</code>属性和<code>nodeValue</code>属性</p>
<h4 id="元素节点对象的属性"><a href="#元素节点对象的属性" class="headerlink" title="元素节点对象的属性"></a>元素节点对象的属性</h4><p>HTML元素节点的标准属性（即在标准中定义的属性），会自动成为元素节点对象的属性</p>
<p>注意，这种用法虽然可以读写HTML属性，但是无法删除属性，<code>delete</code>运算符在这里不会生效</p>
<p>有些HTML属性名是JavaScript的保留字，转为JavaScript属性时，必须改名。主要是以下两个：</p>
<ul>
<li><code>for</code>属性改为<code>htmlFor</code></li>
<li><code>class</code>属性改为<code>className</code></li>
</ul>
<p>另外，HTML属性值一般都是字符串，但是JavaScript属性会自动转换类型。比如，将字符串<code>true</code>转为布尔值，将<code>onClick</code>的值转为一个函数，将<code>style</code>属性的值转为一个<code>CSSStyleDeclaration</code>对象</p>
<h4 id="属性操作的标准方法"><a href="#属性操作的标准方法" class="headerlink" title="属性操作的标准方法"></a>属性操作的标准方法</h4><p>元素节点提供四个方法，用来操作属性：</p>
<blockquote>
<ul>
<li><code>getAttribute()</code></li>
<li><code>setAttribute()</code></li>
<li><code>hasAttribute()</code></li>
<li><code>removeAttribute()</code></li>
</ul>
</blockquote>
<p>其中，前两个读写属性的方法，与前一部分HTML标签对象的属性读写，有三点差异：</p>
<p>（1）适用性</p>
<p><code>getAttribute()</code>和<code>setAttribute()</code>对所有属性（包括用户自定义的属性）都适用；HTML标签对象的属性，只适用于标准属性</p>
<p>（2）返回值</p>
<p><code>getAttribute()</code>只返回字符串，不会返回其他类型的值。HTML标签对象的属性会返回各种类型的值，包括字符串、数值、布尔值或对象</p>
<p>（3）属性名</p>
<p>这些方法只接受属性的标准名称，不用改写保留字，比如<code>for</code>和<code>class</code>都可以直接使用。另外，这些方法对于属性名是大小写不敏感的</p>
<p><strong>Element.getAttribute()</strong></p>
<p><code>Element.getAttribute</code>方法返回当前元素节点的指定属性。如果指定属性不存在，则返回<code>null</code></p>
<p><strong>Element.setAttribute()</strong></p>
<p><code>Element.setAttribute</code>方法用于为当前元素节点新增属性。如果同名属性已存在，则相当于编辑已存在的属性</p>
<p><strong>Element.hasAttribute()</strong></p>
<p><code>Element.hasAttribute</code>方法返回一个布尔值，表示当前元素节点是否包含指定属性</p>
<p><strong>Element.removeAttribute()</strong></p>
<p><code>Element.removeAttribute</code>方法用于从当前元素节点移除属性</p>
<h4 id="dataset属性"><a href="#dataset属性" class="headerlink" title="dataset属性"></a>dataset属性</h4><p>有时，需要在HTML元素上附加数据，供JavaScript脚本使用。一种解决方法是自定义属性，然后可以用<code>getAttribute()</code>和<code>setAttribute()</code>读写这个属性。通常的自定义属性方法虽然可以达到目的，但是会使得HTML元素的属性不符合标准，导致网页的HTML代码通不过校验。更好的解决方法是，使用标准提供的<code>data-*</code>属性</p>
<blockquote>
<p>然后，使用元素节点对象的<code>dataset</code>属性，它指向一个对象，可以用来操作HTML元素标签的<code>data-*</code>属性</p>
</blockquote>
<p><code>data-</code>后面的属性名有限制，只能包含字母、数字、连词线（<code>-</code>）、点（<code>.</code>）、冒号（<code>:</code>）和下划线（<code>_</code>)。而且，属性名不应该使用<code>A</code>到<code>Z</code>的大写字母</p>
<h3 id="Text节点"><a href="#Text节点" class="headerlink" title="Text节点"></a>Text节点</h3><h4 id="Text节点的概念"><a href="#Text节点的概念" class="headerlink" title="Text节点的概念"></a>Text节点的概念</h4><p><code>Text</code>节点代表<code>Element</code>节点和<code>Attribute</code>节点的文本内容。如果一个节点只包含一段文本，那么它就有一个<code>Text</code>子节点，代表该节点的文本内容</p>
<p>通常使用<code>Node</code>节点的<code>firstChild</code>、<code>nextSibling</code>等属性获取<code>Text</code>节点，或者使用<code>Document</code>节点的<code>createTextNode</code>方法创造一个<code>Text</code>节点</p>
<p>浏览器原生提供一个Text构造函数。它返回一个Text节点。它的参数就是该Text节点的文本内容：<code>new Text();</code></p>
<h4 id="Text节点的属性"><a href="#Text节点的属性" class="headerlink" title="Text节点的属性"></a>Text节点的属性</h4><p><strong>data</strong></p>
<p><code>data</code>属性等同于<code>nodeValue</code>属性，用来设置或读取Text节点的内容</p>
<p><strong>wholeText</strong></p>
<p><code>wholeText</code>属性将当前Text节点与毗邻的Text节点，作为一个整体返回。大多数情况下，wholeText属性的返回值，与data属性和textContent属性相同</p>
<p><strong>length</strong></p>
<p><code>length</code>属性返回当前Text节点的文本长度</p>
<p><strong>nextElementSibling</strong></p>
<p><code>nextElementSibling</code>属性返回紧跟在当前Text节点后面的那个同级Element节点。如果取不到这样的节点，则返回null</p>
<p><strong>previousElementSibling</strong></p>
<p><code>previousElementSibling</code>属性返回当前Text节点前面最近的那个Element节点。如果取不到这样的节点，则返回null</p>
<h4 id="Text节点的方法"><a href="#Text节点的方法" class="headerlink" title="Text节点的方法"></a>Text节点的方法</h4><p><strong>appendData()</strong></p>
<p><code>appendData</code>方法用于在Text节点尾部追加字符串</p>
<p><strong>deleteData()</strong></p>
<p><code>deleteData</code>方法用于删除Text节点内部的子字符串，第一个参数为子字符串位置，第二个参数为子字符串长度</p>
<p><strong>insertData()</strong></p>
<p><code>insertData</code>方法用于在Text节点插入字符串，第一个参数为插入位置，第二个参数为插入的子字符串</p>
<p><strong>replaceData()</strong></p>
<p><code>replaceData</code>方法用于替换文本，第一个参数为替换开始位置，第二个参数为需要被替换掉的长度，第三个参数为新加入的字符串</p>
<p><strong>subStringData()</strong></p>
<p><code>subStringData</code>方法用于获取子字符串，第一个参数为子字符串在Text节点中的开始位置，第二个参数为子字符串长度</p>
<p><strong>remove()</strong></p>
<p><code>remove</code>方法用于移除当前Text节点</p>
<p><strong>splitText()</strong></p>
<p><code>splitText</code>方法将Text节点一分为二，变成两个毗邻的Text节点。它的参数就是分割位置（从零开始），分割到该位置的字符前结束。如果分割位置不存在，将报错</p>
<p><strong>normalize()</strong></p>
<p><code>normalize</code>方法可以将毗邻的两个Text节点合并</p>
<h3 id="DocumentFragment"><a href="#DocumentFragment" class="headerlink" title="DocumentFragment"></a>DocumentFragment</h3><p><code>DocumentFragment</code>节点代表一个文档的片段，本身就是一个完整的DOM树形结构。它没有父节点，<code>parentNode</code>返回<code>null</code>，但是可以插入任意数量的子节点。它不属于当前文档，操作<code>DocumentFragment</code>节点，要比直接操作DOM树快得多</p>
<p><code>DocumentFragment</code>节点本身不能被插入当前文档。当它作为<code>appendChild()</code>、<code>insertBefore()</code>、<code>replaceChild()</code>等方法的参数时，是它的所有子节点插入当前文档，而不是它自身。一旦<code>DocumentFragment</code>节点被添加进当前文档，它自身就变成了空节点（<code>textContent</code>属性为空字符串），可以被再次使用</p>
<h4 id="DocumentFragment属性"><a href="#DocumentFragment属性" class="headerlink" title="DocumentFragment属性"></a>DocumentFragment属性</h4><p><code>DocumentFragment</code>节点对象没有自己的属性和方法，全部继承自<code>Node</code>节点和<code>ParentNode</code>接口。也就是说，<code>DocumentFragment</code>节点比<code>Node</code>节点多出以下四个属性：</p>
<blockquote>
<ul>
<li><code>children</code>：返回一个动态的<code>HTMLCollection</code>集合对象，包括当前<code>DocumentFragment</code>对象的所有子元素节点</li>
<li><code>firstElementChild</code>：返回当前<code>DocumentFragment</code>对象的第一个子元素节点，如果没有则返回<code>null</code></li>
<li><code>lastElementChild</code>：返回当前<code>DocumentFragment</code>对象的最后一个子元素节点，如果没有则返回<code>null</code></li>
<li><code>childElementCount</code>：返回当前<code>DocumentFragment</code>对象的所有子元素数量</li>
</ul>
</blockquote>
<h3 id="Cookie对象"><a href="#Cookie对象" class="headerlink" title="Cookie对象"></a>Cookie对象</h3><p>Cookie 是服务器保存在浏览器的一小段文本信息，每个 Cookie 的大小一般不能超过4KB。浏览器每次向服务器发出请求，就会自动附上这段信息</p>
<p>Cookie 保存以下几方面的信息：</p>
<blockquote>
<ul>
<li>Cookie的名字</li>
<li>Cookie的值</li>
<li>到期时间</li>
<li>所属域名（默认是当前域名）</li>
<li>生效的路径（默认是当前网址）</li>
</ul>
</blockquote>
<h4 id="cookie注意点"><a href="#cookie注意点" class="headerlink" title="cookie注意点"></a>cookie注意点</h4><blockquote>
<p><code>document.cookie</code>属性返回当前网页的 Cookie，<code>document.cookie</code>属性是可写的，可以通过它为当前网站添加Cookie</p>
</blockquote>
<blockquote>
<p>Cookie的值必须写成<code>key=value</code>的形式。注意，等号两边不能有空格。另外，写入Cookie的时候，必须对分号、逗号和空格进行转义（它们都不允许作为Cookie的值），这可以用<code>encodeURIComponent</code>方法达到</p>
</blockquote>
<blockquote>
<p><code>document.cookie</code>一次只能写入一个Cookie，而且写入并不是覆盖，而是添加</p>
</blockquote>
<blockquote>
<p>浏览器的同源政策规定，两个网址只要域名相同和端口相同，就可以共享Cookie</p>
</blockquote>
<blockquote>
<p>设置Cookie的时候，如果服务器加上了<code>HttpOnly</code>属性，则这个Cookie无法被JavaScript读取（即<code>document.cookie</code>不会返回这个Cookie的值），只用于向服务器发送</p>
</blockquote>
<h4 id="cookie对象属性"><a href="#cookie对象属性" class="headerlink" title="cookie对象属性"></a>cookie对象属性</h4><p>除了Cookie本身的内容，还有一些可选的属性也是可以写入的，它们都必须以分号开头</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]</span><br></pre></td></tr></table></figure>
<p>上面的<code>Set-Cookie</code>字段，用分号分隔多个属性。它们的含义如下：</p>
<p><strong>（1）value属性</strong></p>
<p><code>value</code>属性是必需的，它是一个键值对，用于指定Cookie的值</p>
<p><strong>（2）expires属性</strong></p>
<p><code>expires</code>属性用于指定Cookie过期时间。它的格式采用<code>Date.toUTCString()</code>的格式</p>
<p>如果不设置该属性，或者设为<code>null</code>，Cookie只在当前会话（session）有效，浏览器窗口一旦关闭，当前Session结束，该Cookie就会被删除</p>
<p>浏览器根据本地时间，决定Cookie是否过期，由于本地时间是不精确的，所以没有办法保证Cookie一定会在服务器指定的时间过期</p>
<p><strong>（3）domain属性</strong></p>
<p><code>domain</code>属性指定Cookie所在的域名，比如<code>example.com</code>或<code>.example.com</code>（这种写法将对所有子域名生效）、<code>subdomain.example.com</code></p>
<p>如果未指定，默认为设定该Cookie的域名。所指定的域名必须是当前发送Cookie的域名的一部分，比如当前访问的域名是<code>example.com</code>，就不能将其设为<code>google.com</code>。只有访问的域名匹配domain属性，Cookie才会发送到服务器</p>
<p><strong>（4）path 属性</strong></p>
<p><code>path</code>属性用来指定路径，必须是绝对路径（比如<code>/</code>、<code>/mydir</code>），如果未指定，默认为请求该 Cookie 的网页路径</p>
<p>只有<code>path</code>属性匹配向服务器发送的路径，Cookie 才会发送。这里的匹配不是绝对匹配，而是从根路径开始，只要<code>path</code>属性匹配发送路径的一部分，就可以发送。比如，<code>path</code>属性等于<code>/blog</code>，则发送路径是<code>/blog</code>或者<code>/blog/roll</code>，Cookie都会发送。<code>path</code>属性生效的前提是<code>domain</code>属性匹配</p>
<p><strong>（5）secure 属性</strong></p>
<p><code>secure</code>属性用来指定Cookie只能在加密协议HTTPS下发送到服务器</p>
<p>该属性只是一个开关，不需要指定值。如果通信是HTTPS协议，该开关自动打开</p>
<p><strong>（6）max-age</strong></p>
<p><code>max-age</code>属性用来指定Cookie有效期，比如<code>60 * 60 * 24 * 365</code>（即一年31536e3秒）</p>
<p><strong>（7）HttpOnly</strong></p>
<p><code>HttpOnly</code>属性用于设置该Cookie不能被JavaScript读取</p>
<p>以上属性可以同时设置一个或多个，也没有次序的要求。如果服务器想改变一个早先设置的Cookie，必须同时满足四个条件：Cookie的<code>key</code>、<code>domain</code>、<code>path</code>和<code>secure</code>都匹配。也就是说，如果原始的Cookie是用如下的<code>Set-Cookie</code>设置的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: key1=value1; domain=example.com; path=<span class="regexp">/blog</span></span><br></pre></td></tr></table></figure>
<p>改变上面这个cookie的值，就必须使用同样的<code>Set-Cookie</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: key1=value2; domain=example.com; path=<span class="regexp">/blog</span></span><br></pre></td></tr></table></figure>
<p>只要有一个属性不同，就会生成一个全新的Cookie，而不是替换掉原来那个Cookie</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: key1=value2; domain=example.com; path=<span class="regexp">/</span></span><br></pre></td></tr></table></figure>
<p>上面的命令设置了一个全新的同名Cookie，但是<code>path</code>属性不一样。下一次访问<code>example.com/blog</code>的时候，浏览器将向服务器发送两个同名的Cookie。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: key1=value1; key1=value2</span><br></pre></td></tr></table></figure>
<p>上面代码的两个Cookie是同名的，匹配越精确的Cookie排在越前面。</p>
<p>浏览器设置这些属性的写法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'fontSize=14; '</span></span><br><span class="line">  + <span class="string">'expires='</span> + someDate.toGMTString() + <span class="string">'; '</span></span><br><span class="line">  + <span class="string">'path=/subdirectory; '</span></span><br><span class="line">  + <span class="string">'domain=*.example.com'</span>;</span><br></pre></td></tr></table></figure>
<p>另外，这些属性只能用来设置Cookie。一旦设置完成，就没有办法读取这些属性的值。</p>
<p>删除一个Cookie的简便方法，就是设置<code>expires</code>属性等于0，或者等于一个过去的日期。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'fontSize=;expires=Thu, 01-Jan-1970 00:00:01 GMT'</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，名为<code>fontSize</code>的Cookie的值为空，过期时间设为1970年1月1月零点，就等同于删除了这个Cookie</p>
<h4 id="cookie的限制"><a href="#cookie的限制" class="headerlink" title="cookie的限制"></a>cookie的限制</h4><p>浏览器对Cookie数量的限制，规定不一样。目前，Firefox是每个域名最多设置50个Cookie，而Safari和Chrome没有域名数量的限制</p>
<p>所有Cookie的累加长度限制为4KB。超过这个长度的Cookie，将被忽略，不会被设置</p>
<p>由于Cookie可能存在数量限制，有时为了规避限制，可以将cookie设置成下面的形式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=a=b&amp;c=d&amp;e=f&amp;g=h</span><br></pre></td></tr></table></figure>
<p>上面代码实际上是设置了一个Cookie，但是这个Cookie内部使用<code>&amp;</code>符号，设置了多部分的内容。因此，读取这个Cookie的时候，就要自行解析，得到多个键值对。这样就规避了cookie的数量限制</p>
<h3 id="Image对象"><a href="#Image对象" class="headerlink" title="Image对象"></a>Image对象</h3><p><code>Image</code>是一个浏览器的原生构造函数<code>new Image()</code>，返回一个<code>HTMLImageElement</code>对象的实例，即<code>&lt;img&gt;</code>标签的实例</p>
<p>以下方法得到的节点对象，都是<code>HTMLImageElement</code>的实例，具有同样的属性和方法：</p>
<blockquote>
<ul>
<li><code>document.images</code>的成员</li>
<li>节点选取方法得到的<code>&lt;img&gt;</code>节点</li>
<li><code>document.createElement(&#39;img&#39;)</code>生成的<code>&lt;img&gt;</code>节点</li>
</ul>
</blockquote>
<p><code>Image.src</code>属性对应<code>&lt;img&gt;</code>节点的<code>src</code>属性，即图像来源</p>
<p><code>Image</code>构造函数可以接受两个参数，分别是<code>&lt;img&gt;</code>节点的宽和高</p>
<p>注意，新生成的<code>Image</code>实例，并不属于文档的一部分。如果想让它显示在文档中，必须手动插入文档</p>
<h4 id="image对象属性"><a href="#image对象属性" class="headerlink" title="image对象属性"></a>image对象属性</h4><p><code>Image</code>实例具有以下属性：</p>
<blockquote>
<ul>
<li>alt：对应<code>&lt;img&gt;</code>的<code>alt</code>属性，表示图像的说明文字</li>
<li>complete：返回一个布尔值，表示图表是否已经加载完成</li>
<li>crossOrigin：图像跨域的<code>CORS</code>设置</li>
<li>height：图像的高度，可读写</li>
<li>isMap：图像是否为服务器端的<code>image-map</code>，可读写</li>
<li>onload：指定一个图像加载完成后的回调函数。</li>
<li>naturalHeight：图像的原始高度，只读</li>
<li>naturalWidth：图像的原始宽度，只读</li>
<li>src：<code>&lt;img&gt;</code>的<code>src</code>属性，即图像的来源，可读写</li>
<li>useMap：设置图像的<code>usemap</code>属性</li>
<li>width：图像的宽度，可读写</li>
</ul>
</blockquote>
<h3 id="CSS操作"><a href="#CSS操作" class="headerlink" title="CSS操作"></a>CSS操作</h3><h4 id="style属性"><a href="#style属性" class="headerlink" title="style属性"></a>style属性</h4><p>操作 CSS 样式最简单的方法，就是使用网页元素节点的<code>getAttribute</code>方法、<code>setAttribute</code>方法和<code>removeAttribute</code>方法，直接读写或删除网页元素的<code>style</code>属性</p>
<p><strong>Style对象</strong></p>
<p>每一个网页元素对应一个DOM节点对象。这个对象的<code>style</code>属性可以直接操作，用来读写行内CSS样式</p>
<p>这个对象所包含的属性与CSS规则一一对应，但是名字需要改写，比如<code>background-color</code>写成<code>backgroundColor</code></p>
<p>改写的规则是将横杠从CSS属性名中去除，然后将横杠后的第一个字母大写。如果CSS属性名是JavaScript保留字，则规则名之前需要加上字符串<code>css</code>，比如<code>float</code>写成<code>cssFloat</code></p>
<p>注意，<code>style</code>对象的属性值都是字符串，设置时必须包括单位，但是不含规则结尾的分号</p>
<p><strong>cssText属性</strong></p>
<p>元素节点对象的<code>style</code>对象，有一个<code>cssText</code>属性，可以读写或删除整个样式</p>
<p>注意，<code>cssText</code>的属性值不用改写CSS属性名</p>
<p><strong>setProperty()，getPropertyValue()，removeProperty()</strong></p>
<p>Style对象的以下三个方法，用来读写行内CSS规则：</p>
<ul>
<li><code>setProperty(propertyName,value)</code>：设置某个CSS属性</li>
<li><code>getPropertyValue(propertyName)</code>：读取某个CSS属性</li>
<li><code>removeProperty(propertyName)</code>：删除某个CSS属性</li>
</ul>
<p>这三个方法的第一个参数，都是CSS属性名，且不用改写连词线</p>
<h4 id="getComputedStyle"><a href="#getComputedStyle" class="headerlink" title="getComputedStyle()"></a>getComputedStyle()</h4><p>行内样式（inline style）具有最高的优先级，改变行内样式，通常会立即反映出来。但是，网页元素最终的样式是综合各种规则计算出来的。因此，如果想得到元素现有的样式，只读取行内样式是不够的，我们需要得到浏览器最终计算出来的那个样式规则</p>
<p><code>window.getComputedStyle</code>方法，就用来返回这个规则。它接受一个DOM节点对象作为参数，返回一个包含该节点最终样式信息的对象。所谓“最终样式信息”，指的是各种CSS规则叠加后的结果</p>
<p><code>getComputedStyle</code>方法还可以接受第二个参数，表示指定节点的伪元素（比如<code>:before</code>、<code>:after</code>、<code>:first-line</code>、<code>:first-letter</code>等）</p>
<h4 id="CSS伪元素"><a href="#CSS伪元素" class="headerlink" title="CSS伪元素"></a>CSS伪元素</h4><p>CSS伪元素是通过CSS向DOM添加的元素，主要方法是通过<code>:before</code>和<code>:after</code>选择器生成伪元素，然后用<code>content</code>属性指定伪元素的内容</p>
<p>DOM节点的<code>style</code>对象无法读写伪元素的样式，这时就要用到<code>window</code>对象的<code>getComputedStyle</code>方法</p>
<p>此外，也可以使用window.getComputedStyle对象的getPropertyValue方法，获取伪元素的属性</p>
<h4 id="StyleSheet对象"><a href="#StyleSheet对象" class="headerlink" title="StyleSheet对象"></a>StyleSheet对象</h4><p><strong>获取样式表</strong></p>
<p><code>StyleSheet</code>对象代表网页的一张样式表，它包括<code>&lt;link&gt;</code>节点加载的样式表和<code>&lt;style&gt;</code>节点内嵌的样式表</p>
<p><code>document</code>对象的<code>styleSheets</code>属性，可以返回当前页面的所有<code>StyleSheet</code>对象（即所有样式表）。它是一个类似数组的对象</p>
<p>此外，<code>&lt;link&gt;</code>节点和<code>&lt;style&gt;</code>节点的<code>sheet</code>属性，也可以获取<code>StyleSheet</code>对象</p>
<p><strong>属性</strong></p>
<blockquote>
<ul>
<li><strong>media属性</strong>：media属性表示这个样式表是用于屏幕（screen），还是用于打印（print），或两者都适用（all）。该属性只读，默认值是screen</li>
<li><strong>disabled属性</strong>：<code>disabled</code>属性用于打开或关闭一张样式表</li>
<li><strong>href属性</strong>：<code>href</code>属性是只读属性，返回<code>StyleSheet</code>对象连接的样式表地址。对于内嵌的<code>&lt;style&gt;</code>节点，该属性等于<code>null</code></li>
<li><strong>title属性</strong>：<code>title</code>属性返回<code>StyleSheet</code>对象的<code>title</code>值</li>
<li><strong>type属性</strong>：<code>type</code>属性返回<code>StyleSheet</code>对象的<code>type</code>值，通常是<code>text/css</code></li>
<li><strong>parentStyleSheet属性</strong>：CSS的<code>@import</code>命令允许在样式表中加载其他样式表。<code>parentStyleSheet</code>属性返回包含了当前样式表的那张样式表。如果当前样式表是顶层样式表，则该属性返回<code>null</code></li>
<li><strong>ownerNode属性</strong>：<code>ownerNode</code>属性返回<code>StyleSheet</code>对象所在的DOM节点，通常是<code>&lt;link&gt;</code>或<code>&lt;style&gt;</code></li>
<li><strong>cssRules属性</strong>：<code>cssRules</code>属性指向一个类似数组的对象，里面每一个成员就是当前样式表的一条CSS规则</li>
</ul>
</blockquote>
<p><strong>insertRule()，deleteRule()</strong></p>
<p><code>insertRule</code>方法用于在当前样式表的<code>cssRules</code>对象插入CSS规则</p>
<p><code>insertRule</code>方法的第一个参数是表示CSS规则的字符串，第二个参数是该规则在<code>cssRules</code>对象的插入位置</p>
<p><code>deleteRule</code>方法用于删除<code>cssRules</code>对象的CSS规则</p>
<p><code>deleteRule</code>方法的参数是该条规则在<code>cssRules</code>对象中的位置</p>
<p><strong>添加样式表</strong></p>
<p>添加样式表有两种方式。一种是添加一张内置样式表，即在文档中添加一个<code>&lt;style&gt;</code>节点</p>
<p>另一种是添加外部样式表，即在文档中添加一个<code>&lt;link&gt;</code>节点，然后将<code>href</code>属性指向外部样式表的URL</p>
<p><strong>CSS规则</strong></p>
<p><strong>CSSRule接口</strong></p>
<blockquote>
<ul>
<li><strong>cssText</strong>：cssText属性返回当前规则的文本</li>
<li><strong>parentStyleSheet</strong>：parentStyleSheet属性返回定义当前规则的样式表对象</li>
<li><strong>parentRule</strong>：parentRule返回包含当前规则的那条CSS规则</li>
<li><strong>type</strong>：type属性返回有一个整数值，表示当前规则的类型</li>
</ul>
</blockquote>
<p><strong>CSSStyleRule接口</strong></p>
<blockquote>
<ul>
<li><strong>selectorText属性</strong>：selectorText属性返回当前规则的选择器</li>
<li><strong>style属性</strong>：style属性返回一个对象，代表当前规则的样式声明，也就是选择器后面的大括号里面的部分</li>
</ul>
</blockquote>
<p><strong>CSSMediaRule接口</strong></p>
<p>如果一条CSS规则是@media代码块，那么它除了CSSRule接口，还部署了CSSMediaRule接口</p>
<p>该接口主要提供一个media属性，可以返回@media代码块的media规则</p>
<p><strong>CSSStyleDeclaration对象</strong></p>
<p>每一条 CSS 规则的样式声明部分（大括号内部的部分），都是一个<code>CSSStyleDeclaration</code>对象，主要包括三种情况：</p>
<blockquote>
<ul>
<li>HTML 元素的行内样式（<code>&lt;elem style=&quot;...&quot;&gt;</code>）</li>
<li><code>CSSStyleRule</code>接口的<code>style</code>属性</li>
<li><code>window.getComputedStyle()</code>的返回结果</li>
</ul>
<p>每一条CSS属性，都是<code>CSSStyleDeclaration</code>对象的属性。不过，连词号需要变成骆驼拼写法</p>
<p>除了 CSS 属性以外，<code>CSSStyleDeclaration</code>对象还包括以下属性：</p>
<ul>
<li><code>cssText</code>：当前规则的所有样式声明文本。该属性可读写，即可用来设置当前规则</li>
<li><code>length</code>：当前规则包含多少条声明</li>
<li><code>parentRule</code>：包含当前规则的那条规则，同 CSSRule 接口的<code>parentRule</code>属性</li>
</ul>
</blockquote>
<p><code>CSSStyleDeclaration</code>对象包括以下方法：</p>
<blockquote>
<ul>
<li><strong>getPropertyPriority()</strong>：<code>getPropertyPriority</code>方法返回指定声明的优先级，如果有的话，就是“important”，否则就是空字符串</li>
<li><strong>getPropertyValue()</strong>：getPropertyValue方法返回指定声明的值</li>
<li><strong>item()</strong>：item方法返回指定位置的属性名</li>
<li><strong>removeProperty()</strong>：removeProperty方法用于删除一条CSS属性，返回被删除的值</li>
<li><strong>setProperty()</strong>：setProperty方法用于设置指定的CSS属性，没有返回值</li>
</ul>
</blockquote>
<h4 id="matchMedia"><a href="#matchMedia" class="headerlink" title="matchMedia()"></a>matchMedia()</h4><p><code>window.matchMedia</code>方法用来检查CSS的<code>mediaQuery</code>语句</p>
<p><code>window.matchMedia</code>方法接受一个<code>mediaQuery</code>语句的字符串作为参数，返回一个<code>MediaQueryList</code>]对象。该对象有以下两个属性：</p>
<blockquote>
<ul>
<li><code>media</code>：返回所查询的<code>mediaQuery</code>语句字符串</li>
<li><code>matches</code>：返回一个布尔值，表示当前环境是否匹配查询语句</li>
</ul>
</blockquote>
<p><strong>监听事件</strong></p>
<p>window.matchMedia方法返回的MediaQueryList对象有两个方法，用来监听事件：addListener方法和removeListener方法。如果mediaQuery查询结果发生变化，就调用指定的回调函数</p>
<h4 id="CSS事件"><a href="#CSS事件" class="headerlink" title="CSS事件"></a>CSS事件</h4><p><strong>transitionEnd事件</strong></p>
<p>CSS的过渡效果（transition）结束后，触发<code>transitionEnd</code>事件</p>
<p><code>transitionEnd</code>的事件对象具有以下属性：</p>
<blockquote>
<ul>
<li><code>propertyName</code>：发生<code>transition</code>效果的CSS属性名</li>
<li><code>elapsedTime</code>：<code>transition</code>效果持续的秒数，不含<code>transition-delay</code>的时间</li>
<li><code>pseudoElement</code>：如果<code>transition</code>效果发生在伪元素，会返回该伪元素的名称，以“::”开头。如果不发生在伪元素上，则返回一个空字符串</li>
</ul>
</blockquote>
<p><strong>animationstart事件，animationend事件，animationiteration事件</strong></p>
<p>CSS动画有以下三个事件。</p>
<blockquote>
<ul>
<li>animationstart事件：动画开始时触发</li>
<li>animationend事件：动画结束时触发</li>
<li>animationiteration事件：开始新一轮动画循环时触发。如果animation-iteration-count属性等于1，该事件不触发，即只播放一轮的CSS动画，不会触发animationiteration事件</li>
</ul>
</blockquote>
<p>这三个事件的事件对象，都有animationName属性（返回产生过渡效果的CSS属性名）和elapsedTime属性（动画已经运行的秒数）。对于animationstart事件，elapsedTime属性等于0，除非animation-delay属性等于负值</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">JavaScript</a>
        		</li>
      		
		</ul>
	</div>

      

      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-JavaScript Object" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/12/JavaScript Object/">JavaScript Object</a>
    </h1>
  

        
        <a href="/2018/08/12/JavaScript Object/" class="archive-article-date">
  	<time datetime="2018-08-11T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-08-12</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JavaScript-Object"><a href="#JavaScript-Object" class="headerlink" title="JavaScript Object"></a>JavaScript Object</h2><h3 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h3><h4 id="Global对象属性"><a href="#Global对象属性" class="headerlink" title="Global对象属性"></a>Global对象属性</h4><p><strong>Infinity</strong></p>
<p><code>Infinity</code> 属性用于存放表示正无穷大的数值</p>
<blockquote>
<p>无法使用 for/in 循环来枚举 Infinity 属性，也不能用 delete 运算符来删除它</p>
</blockquote>
<blockquote>
<p>Infinity 不是常量，可以把它设置为其他值</p>
</blockquote>
<p><strong>NaN</strong></p>
<p><code>NaN</code>属性用于引用特殊的非数字值</p>
<blockquote>
<p>无法使用 for/in 循环来枚举 NaN 属性，也不能用 delete 运算符来删除它</p>
</blockquote>
<blockquote>
<p>NaN 不是常量，可以把它设置为其他值</p>
</blockquote>
<blockquote>
<p>应使用 isNaN() 来判断一个值是否是数字。原因是 NaN 与所有值都不相等，包括它自己</p>
</blockquote>
<p><strong>undefined</strong></p>
<p><code>undefined</code>属性用于存放 JavaScript 的 undefined 值（表示未定义）</p>
<blockquote>
<p>无法使用 for/in 循环来枚举 undefined 属性，也不能用 delete 运算符来删除它</p>
</blockquote>
<blockquote>
<p>undefined 不是常量，可以把它设置为其他值</p>
</blockquote>
<blockquote>
<p>当尝试读取不存在的对象属性时也会返回 undefined</p>
</blockquote>
<p><strong>null</strong></p>
<p><code>null</code>属性用于存放JavaScript的null值（表示空值）</p>
<blockquote>
<p>无法使用 for/in 循环来枚举 null属性，也不能用 delete 运算符来删除它</p>
</blockquote>
<blockquote>
<p>null不是常量，可以把它设置为其他值</p>
</blockquote>
<blockquote>
<p>null 表示无值，而 undefined 表示一个未声明的变量，或已声明但没有赋值的变量，或一个并不存在的对象属性</p>
</blockquote>
<blockquote>
<p>只能用 === 运算来测试某个值是否是未定义的，因为 == 运算符认为 undefined 值等价于 null</p>
</blockquote>
<h4 id="Global对象方法"><a href="#Global对象方法" class="headerlink" title="Global对象方法"></a>Global对象方法</h4><p><strong>eval()</strong></p>
<p><code>eval()</code>方法会将传入的字符串当做JavaScript代码进行执行</p>
<p>参数为一串表示JavaScript表达式，语句，或者是一系列语句的字符串。表达式可以包括变量以及已存在对象的属性</p>
<blockquote>
<p>注意不要用eval()来执行一个四则运算表达式，因为JavaScript会自动为四则运算求值并不需要eval来包裹</p>
</blockquote>
<blockquote>
<p>如果参数不是字符串，eval()将会将参数原封不动的返回</p>
</blockquote>
<blockquote>
<p>eval()是一个危险的函数，它执行代码拥有着执行者的权利；eval()的运行效率也普遍比其他的替代方案慢，因此，避免在不必要的情况下使用eval函数</p>
</blockquote>
<p><strong>isFinite()</strong></p>
<p><code>isFinite()</code>方法用来判断被传入的参数是否为一个有限数值。在必要的情况下，参数会首先转化为一个数值</p>
<p>语法：isFinite(testValue)</p>
<p>参数：testValue（要被检测的值）</p>
<p>返回值：参数是 <code>NaN</code>，正无穷大或者负无穷大，会返回<code>false</code>，其他返回 <code>true</code></p>
<p><strong>isNaN()</strong></p>
<p><code>isNaN()</code>方法用来确定一个值是否为<code>NaN</code></p>
<p>语法：isNaN(testValue)</p>
<p>参数：testValue（要被检测的值）</p>
<p>返回值：一个布尔值。给定的值为<code>NaN</code>，返回<code>true</code>，否则返回<code>false</code></p>
<blockquote>
<p>与 JavaScript 中其他的值不同，<code>NaN</code>不能通过相等操作符（== 和 ===）来判断 ，因为 <code>NaN == NaN</code> 和 <code>NaN === NaN</code> 都会返回 <code>false</code></p>
</blockquote>
<p><strong>parseFloat()</strong></p>
<p><code>parseFloat()</code>函数解析一个字符串参数并返回一个浮点数</p>
<p>语法：parseFloat(string)</p>
<p>参数：string（需要被解析成为浮点数的字符串）</p>
<p>返回值：解析后的浮点数值</p>
<blockquote>
<p><code>parseFloat</code>将它的字符串参数解析成为浮点数并返回。如果在解析过程中遇到了正负号(+或-),数字(0-9)，小数点,或者科学记数法中的指数(e或E)以外的字符，则它会忽略该字符以及之后的所有字符，返回当前已经解析到的浮点数。同时参数字符串首位的空白符会被忽略</p>
</blockquote>
<blockquote>
<p>如果参数字符串的第一个字符不能被解析成为数字,<code>则parseFloat</code>返回<code>NaN</code></p>
</blockquote>
<p><strong>parseInt()</strong></p>
<p><code>parseInt()</code>方法解析一个字符串参数，并返回一个指定基数的整数</p>
<p>语法：parseInt(string, radix)</p>
<p>参数：string（要被解析的值。如果参数不是一个字符串，则将其转换为字符串）；radix（一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的<strong>基数</strong>）</p>
<p>返回值：解析后的整数值</p>
<blockquote>
<p><code>parseInt</code> 函数将其第一个参数转换为字符串，解析它，并返回一个整数或NaN。如果不是NaN，返回的值将是作为指定基数（基数）中的数字的第一个参数的整数</p>
</blockquote>
<p><strong>encodeURI()</strong></p>
<p><code>encodeURI</code> 方法的参数是一个字符串，代表整个URL。它会将元字符和语义字符之外的字符，都进行转义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">encodeURI</span>(<span class="string">'http://www.example.com/q=春节'</span>)</span><br><span class="line"><span class="comment">// "http://www.example.com/q=%E6%98%A5%E8%8A%82"</span></span><br></pre></td></tr></table></figure>
<p><strong>encodeURIComponent()</strong></p>
<p><code>encodeURIComponent</code>只转除了语义字符之外的字符，元字符也会被转义。因此，它的参数通常是URL的路径或参数值，而不是整个URL</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">encodeURIComponent</span>(<span class="string">'春节'</span>)</span><br><span class="line"><span class="comment">// "%E6%98%A5%E8%8A%82"</span></span><br><span class="line"><span class="built_in">encodeURIComponent</span>(<span class="string">'http://www.example.com/q=春节'</span>)</span><br><span class="line"><span class="comment">// "http%3A%2F%2Fwww.example.com%2Fq%3D%E6%98%A5%E8%8A%82"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>encodeURIComponent</code>会连URL元字符一起转义，所以通常只用它转URL的片段</p>
<p><strong>decodeURI()</strong></p>
<p><code>decodeURI</code>用于还原转义后的URL。它是<code>encodeURI</code>方法的逆运算</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">decodeURI</span>(<span class="string">'http://www.example.com/q=%E6%98%A5%E8%8A%82'</span>)</span><br><span class="line"><span class="comment">// "http://www.example.com/q=春节"</span></span><br></pre></td></tr></table></figure>
<p><strong>decodeURIComponent()</strong></p>
<p><code>decodeURIComponent</code>用于还原转义后的URL片段。它是<code>encodeURIComponent</code>方法的逆运算</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">decodeURIComponent</span>(<span class="string">'%E6%98%A5%E8%8A%82'</span>)</span><br><span class="line"><span class="comment">// "春节"</span></span><br></pre></td></tr></table></figure>
<h3 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h3><p>JavaScript 原生提供<code>Object</code>对象（注意起首的<code>O</code>是大写），所有其他对象都继承自这个对象。对象可以通过 <code>new Object()</code>，<code>Object.create() 方法</code>， 或者使用字面标记 (初始化标记)初始化</p>
<p>访问属性是通过<code>.</code>操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用<code>&#39;&#39;</code>括起来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaohong = &#123;</span><br><span class="line">    name: <span class="string">'小红'</span>,</span><br><span class="line">    <span class="string">'middle-school'</span>: <span class="string">'No.1 Middle School'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>xiaohong</code>的属性名<code>middle-school</code>不是一个有效的变量，就需要用<code>&#39;&#39;</code>括起来。访问这个属性也无法使用<code>.</code>操作符，必须用<code>[&#39;xxx&#39;]</code>来访问：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xiaohong[<span class="string">'middle-school'</span>]; <span class="comment">// 'No.1 Middle School'</span></span><br><span class="line">xiaohong[<span class="string">'name'</span>]; <span class="comment">// '小红'</span></span><br><span class="line">xiaohong.name; <span class="comment">// '小红'</span></span><br></pre></td></tr></table></figure>
<p><code>Object</code>本身也是一个构造函数，可以直接通过它来生成新对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<p><code>Object</code>作为构造函数使用时，可以接受一个参数。如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>(o1);</span><br><span class="line">o1 === o2 <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Object</span>(<span class="number">123</span>) <span class="keyword">instanceof</span> <span class="built_in">Number</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，通过<code>new Object()</code>的写法生成新对象，与字面量的写法<code>o = {}</code>是等价的</p>
</blockquote>
<p>与其他构造函数一样，如果要在<code>Object</code>对象上面部署一个方法，有两种做法：</p>
<ul>
<li>部署在Object对象自身</li>
<li>部署在Object.prototype</li>
</ul>
<blockquote>
<p>凡是部署在Object.prototype对象上的属性和方法，将被所有实例对象共享</p>
</blockquote>
<p><strong>Object()</strong></p>
<p><code>Object</code>本身当工具方法使用时，可以将任意值转化为对象。如果是原始类型的值，<code>Object</code>方法返回对应的包装对象的实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>() <span class="comment">// 返回一个空对象</span></span><br><span class="line"><span class="built_in">Object</span>() <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>(<span class="literal">undefined</span>) <span class="comment">// 返回一个空对象</span></span><br><span class="line"><span class="built_in">Object</span>(<span class="literal">undefined</span>) <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>(<span class="literal">null</span>) <span class="comment">// 返回一个空对象</span></span><br><span class="line"><span class="built_in">Object</span>(<span class="literal">null</span>) <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>(<span class="number">1</span>) <span class="comment">// 等同于 new Number(1)</span></span><br><span class="line"><span class="built_in">Object</span>(<span class="number">1</span>) <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>(<span class="number">1</span>) <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>(<span class="string">'foo'</span>) <span class="comment">// 等同于 new String('foo')</span></span><br><span class="line"><span class="built_in">Object</span>(<span class="string">'foo'</span>) <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>(<span class="string">'foo'</span>) <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>(<span class="literal">true</span>) <span class="comment">// 等同于 new Boolean(true)</span></span><br><span class="line"><span class="built_in">Object</span>(<span class="literal">true</span>) <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>(<span class="literal">true</span>) <span class="keyword">instanceof</span> <span class="built_in">Boolean</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>利用这一点可以判断一个变量是否为对象</p>
</blockquote>
<h4 id="属性描述对象"><a href="#属性描述对象" class="headerlink" title="属性描述对象"></a>属性描述对象</h4><p>JavaScript提供了一个内部数据结构，用来描述一个对象的属性的行为，控制它的行为。这被称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息属性描述对象提供6个元属性。</p>
<p>（1）<code>value</code></p>
<p><code>value</code>存放该属性的属性值，默认为<code>undefined</code>。</p>
<p>（2）<code>writable</code></p>
<p><code>writable</code>存放一个布尔值，表示属性值（value）是否可改变，默认为<code>true</code>。</p>
<p>（3）<code>enumerable</code></p>
<p><code>enumerable</code>存放一个布尔值，表示该属性是否可枚举，默认为<code>true</code>。如果设为<code>false</code>，会使得某些操作（比如<code>for...in</code>循环、<code>Object.keys()</code>）跳过该属性。</p>
<p>（4）<code>configurable</code></p>
<p><code>configurable</code>存放一个布尔值，表示“可配置性”，默认为<code>true</code>。如果设为<code>false</code>，将阻止某些操作改写该属性，比如，无法删除该属性，也不得改变该属性的属性描述对象（<code>value</code>属性除外）。也就是说，<code>configurable</code>属性控制了属性描述对象的可写性。</p>
<p>（5）<code>get</code></p>
<p><code>get</code>存放一个函数，表示该属性的取值函数（getter），默认为<code>undefined</code>。</p>
<p>（6）<code>set</code></p>
<p><code>set</code>存放一个函数，表示该属性的存值函数（setter），默认为<code>undefined</code></p>
<p><strong>可枚举性（enumerable）</strong></p>
<p>可枚举性（enumerable）用来控制所描述的属性，是否将被包括在<code>for...in</code>循环之中。具体来说，如果一个属性的<code>enumerable</code>为<code>false</code>，下面三个操作不会取到该属性：</p>
<ul>
<li><code>for..in</code>循环</li>
<li><code>Object.keys</code>方法</li>
<li><code>JSON.stringify</code>方法</li>
</ul>
<p><strong>可配置性（configurable）</strong></p>
<p>可配置性（configurable）决定了是否可以修改属性描述对象。也就是说，当<code>configurable</code>为<code>false</code>的时候，value、writable、enumerable和configurable都不能被修改了</p>
<blockquote>
<p><code>writable</code>只有在从<code>false</code>改为<code>true</code>会报错，从<code>true</code>改为<code>false</code>则是允许的</p>
</blockquote>
<blockquote>
<p>对于<code>value</code>，只要<code>writable</code>和<code>configurable</code>有一个为<code>true</code>，就允许改动</p>
</blockquote>
<p><strong>可写性（writable）</strong></p>
<p>可写性（writable）决定了属性的值（value）是否可以被改变</p>
<blockquote>
<p>正常模式下，对可写性为<code>false</code>的属性赋值不会报错，只会默默失败。但是，严格模式下会报错，即使是对<code>a</code>属性重新赋予一个同样的值</p>
</blockquote>
<blockquote>
<p>如果原型对象的某个属性的可写性为<code>false</code>，那么派生对象将无法自定义这个属性</p>
</blockquote>
<p><strong>存取器（accessor）</strong></p>
<p>属性可以用存取器（accessor）定义。其中，存值函数称为<code>setter</code>，使用<code>set</code>命令；取值函数称为<code>getter</code>，使用<code>get</code>命令</p>
<blockquote>
<p>存取器提供的是虚拟属性，即该属性的值不是实际存在的，而是每次读取时计算生成的。利用这个功能，可以实现许多高级特性，比如每个属性禁止赋值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  get p() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'getter'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  set p(value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setter: '</span> + value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，取值函数Getter不能接受参数，存值函数Setter只能接受一个参数（即属性的值）。另外，对象也不能有与取值函数同名的属性</p>
</blockquote>
<h4 id="Object静态方法"><a href="#Object静态方法" class="headerlink" title="Object静态方法"></a>Object静态方法</h4><h5 id="对象属性模型方法"><a href="#对象属性模型方法" class="headerlink" title="对象属性模型方法"></a><strong>对象属性模型方法</strong></h5><p><strong>Object.getOwnPropertyDescriptor()</strong></p>
<p><code>Object.getOwnPropertyDescriptor()</code>方法返回指定对象上一个自有属性对应的属性描述符</p>
<p>语法：Object.getOwnPropertyDescriptor(obj, prop)</p>
<p>参数：obj（需要查找的对象）；prop（目标对象内属性名称）</p>
<p>返回值：如果指定的属性存在于对象上，则返回其属性描述符对象（property descriptor），否则返回 <code>undefined</code></p>
<p><strong>Object.getOwnPropertyDescriptors()</strong>（ES2017新增）</p>
<p><code>Object.getOwnPropertyDescriptors()</code> 方法用来获取一个对象的所有自身属性的描述符</p>
<p>语法：Object.getOwnPropertyDescriptors(obj)</p>
<p>参数：obj（任意对象）</p>
<p>返回值：所指定对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象</p>
<p><strong>Object.getOwnPropertyNames()</strong></p>
<p><code>Object.getOwnPropertyNames()</code>方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组</p>
<p>语法：Object.getOwnPropertyNames(obj)</p>
<p>参数：obj（任意对象）</p>
<p>返回值：在给定对象上找到的属性对应的字符串数组</p>
<p><strong>Object.getOwnPropertySymbols()</strong>（ES2015新增）</p>
<p><code>Object.getOwnPropertySymbols()</code> 方法会返回一个数组，该数组包含了指定对象自身的（非继承的）所有 symbol 属性键</p>
<p>语法：Object.getOwnPropertySymbols(obj)</p>
<p>参数：obj（任意对象）</p>
<p>返回值：在给定对象上找到的symbol 属性键对应的字符串数组</p>
<p><strong>Object.defineProperty()</strong></p>
<p><code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象</p>
<p>语法：Object.defineProperty(obj, prop, descriptor)</p>
<p>参数：obj（需要被操作的对象）；prop（目标对象需要定义或修改的属性名称）；descriptor（属性描述对象）</p>
<p>返回值：被传递给函数的对象</p>
<blockquote>
<p>需要注意的是，一旦定义了取值函数<code>get</code>（或存值函数<code>set</code>），就不能将<code>writable</code>设为<code>true</code>，或者同时定义<code>value</code>属性，会报错</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'p'</span>, &#123;</span><br><span class="line">  value: <span class="number">123</span>,</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">456</span>; &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// TypeError: Invalid property.</span></span><br><span class="line"><span class="comment">// A property cannot both have accessors and be writable or have a value</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Object.defineProperty的属性描述对象的<code>writable</code>、<code>configurable</code>、<code>enumerable</code>三个属性的默认值都为<code>false</code>；<code>value</code>、<code>get</code>、<code>set</code>三个属性默认值为<code>undefined</code></p>
</blockquote>
<p><strong>Object.defineProperties() </strong></p>
<p><code>Object.defineProperties()</code>方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象</p>
<p>语法：Object.defineProperties(obj, props)</p>
<p>参数：obj（需要被操作的对象）；props（该对象的一个或多个键值对定义的属性描述对象）</p>
<p>返回值：被传递给函数的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">  <span class="string">"property1"</span>: &#123;</span><br><span class="line">    value: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"property2"</span>: &#123;</span><br><span class="line">    value: <span class="string">"Hello"</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他属性描述对象</span></span><br><span class="line">&#125;);</span><br><span class="line">alert(obj.property2) <span class="comment">//弹出"Hello"</span></span><br></pre></td></tr></table></figure>
<h5 id="原型链相关方法"><a href="#原型链相关方法" class="headerlink" title="原型链相关方法"></a><strong>原型链相关方法</strong></h5><p><strong>Object.create()</strong></p>
<p><code>Object.create()</code> 方法会使用指定的原型对象及其属性去创建一个新的对象</p>
<p>语法：Object.create(proto, [ propertiesObject ])</p>
<p>参数：proto（一个对象，应该是新创建的对象的原型）；propertiesObject（可选，该对象的一个或多个键值对定义的属性描述对象）</p>
<p>返回值：返回一个新对象。在指定原型对象上添加新属性后的新对象</p>
<p><strong>Object.getPrototypeOf()</strong></p>
<p><code>Object.getPrototypeOf()</code> 方法返回指定对象的原型（即, 内部<code>[[Prototype]]</code>属性的值）</p>
<p>语法：Object.getPrototypeOf(object)</p>
<p>参数：object（要返回其原型的对象）</p>
<p>返回值：给定对象的原型，如果没有继承属性，则返回<code>null</code></p>
<p><strong>Object.setPrototypeOf()</strong>（ES2015新增）</p>
<p><code>Object.setPrototypeOf()</code> 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或  <code>null</code></p>
<p>语法：Object.setPrototypeOf(obj, prototype)</p>
<p>参数：obj（要设置其原型的对象）；prototype（该对象的新原型，一个对象或者null）</p>
<p>返回值：修改了新原型的对象</p>
<blockquote>
<p>如果prototype参数不是一个对象或者null，则什么都不做。否则，该方法将<code>obj</code>的<code>[[Prototype]]</code>修改为新的值</p>
</blockquote>
<h5 id="控制对象状态方法"><a href="#控制对象状态方法" class="headerlink" title="控制对象状态方法"></a><strong>控制对象状态方法</strong></h5><p><strong>Object.preventExtensions()</strong></p>
<p><code>Object.preventExtensions()</code> 方法让一个对象变的不可扩展（对象变的不可扩展，也就是不能再有新的属性）</p>
<p>语法：Object.preventExtensions(obj)</p>
<p>参数：obj（将要变得不可扩展的对象)</p>
<p>返回值：一个不可扩展的对象</p>
<blockquote>
<p><code>Object.preventExtensions</code> 只能阻止一个对象不能再添加新的自身属性，仍然可以为该对象的原型添加属性。然而Object.preventExtensions会阻止一个对象将<code>__proto__</code>属性重新指向另一个对象</p>
</blockquote>
<p><strong>Object.isExtensible()</strong></p>
<p><code>Object.isExtensible()</code> 方法判断一个对象是否是可扩展的</p>
<p>语法：Object.isExtensible(obj)</p>
<p>参数：obj（要被检测的对象）</p>
<p>返回值：一个布尔值，<code>true</code>为该对象可扩展，否则为不可扩展</p>
<p><strong>Object.freeze()</strong></p>
<p><code>Object.freeze()</code>方法可以冻结一个对象（冻结对象指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性）</p>
<p>语法：Object.freeze(obj)</p>
<p>参数：obj（要被冻结的对象）</p>
<p>返回值：一个被冻结的对象</p>
<p><strong>Object.isFrozen()</strong></p>
<p><code>Object.isFrozen()</code> 方法判断一个对象是否被冻结</p>
<p>语法：Object.isFrozen(obj)</p>
<p>参数：obj（要被检测的对象）</p>
<p>返回值：一个布尔值，<code>true</code>为该对象被冻结，否则为非冻结</p>
<p><strong>Object.seal()</strong></p>
<p><code>Object.seal()</code> 方法可以让一个对象密封（密封对象是指那些不可 <code>扩展</code> 的，且所有自身属性都不可配置的，且属性不可删除的对象）</p>
<p>语法：Object.seal(obj)</p>
<p>参数：obj（要被密封的对象）</p>
<p>返回值：一个被密封的对象</p>
<p><strong>Object.isSealed()</strong></p>
<p><code>Object.isSealed()</code>方法判断一个对象是否被密封</p>
<p>语法：Object.isSealed(obj)</p>
<p>参数：obj（要被检测的对象）</p>
<p>返回值：一个布尔值，<code>true</code>为该对象被密封，否则为非密封</p>
<h5 id="其他新增方法"><a href="#其他新增方法" class="headerlink" title="其他新增方法"></a><strong>其他新增方法</strong></h5><p><strong>Object.assign()</strong>（ES2015新增）</p>
<p><code>Object.assign()</code> 方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象</p>
<p>语法：Object.assign(target, …sources)</p>
<p>参数：target（目标对象）；sources（多个源对象）</p>
<p>返回值：目标对象</p>
<blockquote>
<p><code>Object.assign</code> 方法只会拷贝源对象<strong>自身的</strong>并且<strong>可枚举的</strong>属性到目标对象身上</p>
</blockquote>
<blockquote>
<p><code>String</code>类型和 <code>Symbol</code>类型的属性都会被拷贝。 <code>Object.assign</code> 会跳过那些值为 <code>null</code>或 <code>undefined</code>的源对象</p>
</blockquote>
<p><strong>Object.is()</strong>（ES2015新增）</p>
<p><code>Object.is()</code> 方法确定两个值是否是相同的值</p>
<p>语法：Object.is(value1, value2)</p>
<p>参数：value1（需要比较的第一个值）；value2（需要比较的第二个值）</p>
<p>返回值：一个布尔值指示两个参数是否相等</p>
<blockquote>
<p><code>Object.is()</code>方法与严格相等类似，不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身</p>
</blockquote>
<p><strong>Object.values() </strong>（ES2017新增）</p>
<p><code>Object.values()</code>方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用<code>for...in</code>循环的顺序相同 ( 区别在于<code>for-in</code>循环枚举原型链中的属性 )</p>
<p>语法：Object.values(obj)</p>
<p>参数：obj（被返回可枚举属性值的对象）</p>
<p>返回值：一个包含对象自身的所有可枚举属性值的数组</p>
<p><strong>Object.keys()</strong>（ES2017新增）</p>
<p><code>Object.keys()</code> 方法会返回一个由一个给定<strong>对象</strong>的自身可枚举属性组成的<strong>数组</strong>，数组中属性名的排列顺序和使用 <code>for...in</code> 循环遍历该对象时返回的顺序一致  ( 区别在于<code>for-in</code>循环枚举原型链中的属性 )</p>
<p>语法：Object.keys(obj)</p>
<p>参数：obj（要返回其枚举自身属性的对象）</p>
<p>返回值：一个表示给定对象的所有可枚举属性的字符串数组</p>
<p><strong>Object.entries() </strong>（ES2017新增</p>
<p><code>Object.entries()</code> 方法返回一个给定对象自己的可枚举属性[key，value]对的数组，数组中键值对的排列顺序和使用 <code>for...in</code>循环遍历该对象时返回的顺序一致 ( 区别在于<code>for-in</code>循环枚举原型链中的属性 )</p>
<p>语法：Object.entries(obj)</p>
<p>参数：obj（返回该对象由可枚举属性名和对应属性值组成的的键值对）</p>
<p>返回值：一个给定对象自己的枚举属性[key，value]对的数组</p>
<h4 id="Object实例方法"><a href="#Object实例方法" class="headerlink" title="Object实例方法"></a>Object实例方法</h4><p><strong>hasOwnProperty()</strong></p>
<p><code>hasOwnProperty()</code>方法会返回一个布尔值，指示对象是否具有指定的属性作为自身（不继承）属性</p>
<p>语法：obj.hasOwnProperty(prop)</p>
<p>参数：prop（要检测的属性，字符串名称或者Symbol）</p>
<p>返回值：用来判断某个对象是否含有指定的属性的<code>Boolean</code></p>
<p><strong>isPrototypeOf()</strong></p>
<p><code>isPrototypeOf()</code>方法用于检测一个对象是否存在于另一个对象的原型链上</p>
<p>语法：prototypeObj.isPrototypeOf(object)</p>
<p>参数：object（被搜寻原型的对象）</p>
<p>返回值：<code>Boolean</code>，表示调用对象是否在另一个对象的原型链上</p>
<p><strong>propertyIsEnumerable()</strong></p>
<p><code>propertyIsEnumerable()</code> 方法返回一个布尔值，表明指定的属性名是否是当前对象可枚举的自身属性</p>
<p>语法：obj.propertyIsEnumerable(prop)</p>
<p>参数：prop（被检测的属性名）</p>
<p>返回值：一个 <code>Boolean</code> 用来表明指定的属性名是否可枚举</p>
<p><strong>toLocaleString()</strong></p>
<p><code>toLocaleString()</code> 方法返回一个该对象的字符串表示。该方法主要用于被本地化相关对象覆盖</p>
<p>语法：obj.toLocaleString()</p>
<p>返回值：一个该对象的字符串表示</p>
<p><strong>toSource()</strong>（非标准）</p>
<p><code>toSource()</code>方法返回一个表示对象源代码的字符串</p>
<p>语法：obj.toSource()</p>
<p>返回值：一个表示对象的源代码的字符串</p>
<p><strong>toString()</strong></p>
<p><code>toString()</code> 方法返回一个表示该对象的字符串</p>
<p>语法：object.toString()</p>
<p>返回值：一个表示该对象的字符串</p>
<blockquote>
<p>可以通过<code>toString()</code> 来获取每个对象的类型。为了每个对象都能通过 <code>Object.prototype.toString()</code> 来检测，需要以 <code>Function.prototype.call()</code> 或者 <code>Function.prototype.apply()</code> 的形式来调用，把需要检测的对象作为第一个参数传入</p>
</blockquote>
<p><strong>valueOf()</strong></p>
<p><code>valueOf()</code> 方法返回指定对象的原始值</p>
<p>语法：object.valueOf()</p>
<p>返回值：该对象的原始值</p>
<h3 id="Function对象"><a href="#Function对象" class="headerlink" title="Function对象"></a>Function对象</h3><p><strong>Function 构造函数</strong> 创建一个新的Function对象。 在 JavaScript 中, 每个函数实际上都是一个<code>Function对象</code></p>
<p>句法：new Function ([arg1[, arg2[, …argN]],] functionBody)</p>
<p>参数：arg1, arg2, … arg<em>N</em>（被函数使用的参数）；functionBody（一个含有包括函数定义的JavaScript语句的<strong>字符串</strong>）</p>
<blockquote>
<p>这种声明函数的方式非常不直观，几乎无人使用。应使用函数声明或者函数表达式替代</p>
</blockquote>
<h4 id="Function对象属性"><a href="#Function对象属性" class="headerlink" title="Function对象属性"></a>Function对象属性</h4><p><strong>Function.length</strong></p>
<p><code>length</code>属性返回函数预期传入的参数个数</p>
<p><strong>Function.name</strong></p>
<p><code>name</code>属性返回函数实例的名称</p>
<p><strong>Function.caller</strong>（非标准）</p>
<p><code>caller</code>属性返回调用指定函数的函数</p>
<h4 id="Function实例方法"><a href="#Function实例方法" class="headerlink" title="Function实例方法"></a>Function实例方法</h4><p><strong>apply()</strong></p>
<p><code>apply()</code>方法调用一个函数, 其具有一个指定的<code>this</code>值，以及作为一个数组（或类似数组的对象）提供的参数</p>
<p>语法：fun.apply(thisArg, [argsArray])</p>
<p>参数：thisArg（ <em>fun</em> 函数运行时指定的 <code>this</code> <code>值</code>）；argsArray（一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 <code>fun</code> 函数）</p>
<p><strong>bind()</strong></p>
<p><code>bind()</code>方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列</p>
<p>语法：fun.bind(thisArg[, arg1[, arg2[, …]]])</p>
<p>参数：thisArg（当绑定函数被调用时，该参数会作为原函数运行时的 this 指向）；arg1, arg2, …（当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法）</p>
<p>返回值：由指定的this值和初始化参数改造的原函数拷贝</p>
<p><strong>call()</strong></p>
<p><code>call()</code> 方法调用一个函数, 其具有一个指定的<code>this</code>值和分别地提供的参数</p>
<p>语法：fun.call(thisArg[, arg1[, arg2[, …]]])</p>
<p>参数：thisArg（在<em>fun</em>函数运行时指定的<code>this</code>值）；arg1, arg2, …（指定的参数列表）</p>
<p><strong>isGenerator()</strong>（非标准）</p>
<p><code>isGenerator()</code>方法判断一个函数是否是一个生成器</p>
<p>语法：fun.isGenerator()</p>
<p>返回值：一个布尔值用于判断指定函数是否为一个生成器</p>
<p><strong>toSource()</strong>（非标准）</p>
<p><code>toSource()</code>方法返回函数的源代码的字符串表示</p>
<p>语法：fun.toSource()</p>
<p>返回值：一个表示函数的源代码的字符串</p>
<p><strong>toString()</strong></p>
<p><code>toString()</code>方法返回一个表示当前函数源代码的字符串</p>
<p>语法：fun.toString()</p>
<p>返回值：个表示当前函数源代码的字符串</p>
<h4 id="Arguments对象"><a href="#Arguments对象" class="headerlink" title="Arguments对象"></a>Arguments对象</h4><p><strong>arguments</strong> 是一个类似数组的对象, 对应于传递给函数的参数</p>
<p><code>arguments</code>对象包含了函数运行时的所有参数，<code>arguments[0]</code>就是第一个参数，<code>arguments[1]</code>就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">one</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p><code>arguments</code>对象除了可以读取参数，还可以为参数赋值（严格模式不允许这种用法）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>可以通过<code>arguments</code>对象的<code>length</code>属性，判断函数调用时到底带几个参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">arguments</span>.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 3</span></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">f() <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p><strong>arguments对象属性</strong></p>
<p><strong>arguments.callee</strong></p>
<p><code>arguments.callee</code>属性包含当前正在执行的函数</p>
<blockquote>
<p>在严格模式禁止使用 <code>arguments.callee()</code></p>
</blockquote>
<p><strong>arguments.length</strong></p>
<p><code>arguments.length</code>属性表示实际上向函数传入参数的个数</p>
<h3 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h3><p><strong>见JavaScript Array篇</strong></p>
<h3 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h3><p><strong>见JavaScript String篇</strong></p>
<h3 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h3><p><code>Number</code>对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用</p>
<p>作为构造函数时，它用于生成值为数值的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">typeof</span> n <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Number</code>对象作为构造函数使用，返回一个值为<code>1</code>的对象</p>
<p>作为工具函数时，它可以将任何类型的值转为数值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码将布尔值<code>true</code>转为数值<code>1</code>。<code>Number</code>作为工具函数的用法</p>
<h4 id="Number对象属性"><a href="#Number对象属性" class="headerlink" title="Number对象属性"></a>Number对象属性</h4><p><code>Number</code>对象拥有以下一些属性：</p>
<ul>
<li><code>Number.POSITIVE_INFINITY</code>：正的无限，指向<code>Infinity</code></li>
<li><code>Number.NEGATIVE_INFINITY</code>：负的无限，指向<code>-Infinity</code></li>
<li><code>Number.NaN</code>：表示非数值，指向<code>NaN</code></li>
<li><code>Number.MAX_VALUE</code>：表示最大的正数，相应的，最小的负数为<code>-Number.MAX_VALUE</code></li>
<li><code>Number.MIN_VALUE</code>：表示最小的正数（即最接近0的正数，在64位浮点数体系中为<code>5e-324</code>），相应的，最接近0的负数为<code>-Number.MIN_VALUE</code></li>
<li><code>Number.MAX_SAFE_INTEGER</code>：表示能够精确表示的最大整数，即<code>9007199254740991</code><strong>（ES6新增）</strong></li>
<li><code>Number.MIN_SAFE_INTEGER</code>：表示能够精确表示的最小整数，即<code>-9007199254740991</code><strong>（ES6新增）</strong></li>
<li><code>Number.EPSILON</code>：表示一个表示 1 和大于 1 的最小值，即极小差值常量。值接近于 <code>2.2204460492503130808472633361816E-16</code><strong>（ES6新增）</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.POSITIVE_INFINITY <span class="comment">// Infinity</span></span><br><span class="line"><span class="built_in">Number</span>.NEGATIVE_INFINITY <span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">Number</span>.NaN <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MAX_VALUE</span><br><span class="line"><span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="built_in">Number</span>.MAX_VALUE &lt; <span class="literal">Infinity</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MIN_VALUE</span><br><span class="line"><span class="comment">// 5e-324</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_VALUE &gt; <span class="number">0</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER <span class="comment">// 9007199254740991</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER <span class="comment">// -9007199254740991</span></span><br><span class="line"><span class="built_in">Number</span>.EPSILON <span class="comment">//2.220446049250313e-16</span></span><br></pre></td></tr></table></figure>
<h4 id="Number实例方法"><a href="#Number实例方法" class="headerlink" title="Number实例方法"></a>Number实例方法</h4><p><code>Number</code>对象有4个实例方法，都跟将数值转换成指定格式有关：</p>
<p><strong>Number.prototype.toString()</strong></p>
<p><code>Number</code>对象部署了自己的<code>toString</code>方法，用来将一个数值转为字符串形式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">10</span>).toString() <span class="comment">// "10"</span></span><br></pre></td></tr></table></figure>
<p><code>toString</code>方法可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">10</span>).toString(<span class="number">2</span>) <span class="comment">// "1010"</span></span><br><span class="line">(<span class="number">10</span>).toString(<span class="number">8</span>) <span class="comment">// "12"</span></span><br><span class="line">(<span class="number">10</span>).toString(<span class="number">16</span>) <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，之所以要把10放在括号里，是为了表明10是一个单独的数值，后面的点表示调用对象属性。如果不加括号，这个点会被JavaScript引擎解释成小数点，从而报错</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10.</span>toString(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token ILLEGAL</span></span><br></pre></td></tr></table></figure>
<p>只要能够让JavaScript引擎不混淆小数点和对象的点运算符，各种写法都能用。除了为<code>10</code>加上括号，还可以在<code>10</code>后面加两个点，JavaScript会把第一个点理解成小数点（即<code>10.0</code>），把第二个点理解成调用对象属性，从而得到正确结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10.</span>.toString(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// "1010"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他方法还包括</span></span><br><span class="line"><span class="number">10</span> .toString(<span class="number">2</span>) <span class="comment">// "1010"</span></span><br><span class="line"><span class="number">10.0</span>.toString(<span class="number">2</span>) <span class="comment">// "1010"</span></span><br></pre></td></tr></table></figure>
<p>这实际上意味着，可以直接对一个小数使用<code>toString</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10.5</span>.toString() <span class="comment">// "10.5"</span></span><br><span class="line"><span class="number">10.5</span>.toString(<span class="number">2</span>) <span class="comment">// "1010.1"</span></span><br><span class="line"><span class="number">10.5</span>.toString(<span class="number">8</span>) <span class="comment">// "12.4"</span></span><br><span class="line"><span class="number">10.5</span>.toString(<span class="number">16</span>) <span class="comment">// "a.8"</span></span><br></pre></td></tr></table></figure>
<p>通过方括号运算符也可以调用<code>toString</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>[<span class="string">'toString'</span>](<span class="number">2</span>) <span class="comment">// "1010"</span></span><br></pre></td></tr></table></figure>
<p>将其他进制的数，转回十进制，需要使用<code>parseInt</code>方法</p>
<p><strong>Number.prototype.toFixed()</strong></p>
<p><code>toFixed</code>方法用于将一个数转为指定位数的小数，返回这个小数对应的字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">10</span>).toFixed(<span class="number">2</span>) <span class="comment">// "10.00"</span></span><br><span class="line"><span class="number">10.005</span>.toFixed(<span class="number">2</span>) <span class="comment">// "10.01"</span></span><br></pre></td></tr></table></figure>
<p>上面代码分别将<code>10</code>和<code>10.005</code>转成2位小数的格式。其中，<code>10</code>必须放在括号里，否则后面的点运算符会被处理小数点，而不是表示调用对象的方法；而<code>10.005</code>就不用放在括号里，因为第一个点被解释为小数点，第二个点就只能解释为点运算符。</p>
<p><code>toFixed</code>方法的参数为指定的小数位数，有效范围为0到20，超出这个范围将抛出RangeError错误。</p>
<p><strong>Number.prototype.toExponential()</strong></p>
<p><code>toExponential</code>方法用于将一个数转为科学计数法形式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">10</span>).toExponential()  <span class="comment">// "1e+1"</span></span><br><span class="line">(<span class="number">10</span>).toExponential(<span class="number">1</span>) <span class="comment">// "1.0e+1"</span></span><br><span class="line">(<span class="number">10</span>).toExponential(<span class="number">2</span>) <span class="comment">// "1.00e+1"</span></span><br><span class="line"></span><br><span class="line">(<span class="number">1234</span>).toExponential()  <span class="comment">// "1.234e+3"</span></span><br><span class="line">(<span class="number">1234</span>).toExponential(<span class="number">1</span>) <span class="comment">// "1.2e+3"</span></span><br><span class="line">(<span class="number">1234</span>).toExponential(<span class="number">2</span>) <span class="comment">// "1.23e+3"</span></span><br></pre></td></tr></table></figure>
<p><code>toExponential</code>方法的参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError</p>
<p><strong>Number.prototype.toPrecision()</strong></p>
<p><code>toPrecision</code>方法用于将一个数转为指定位数的有效数字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">12.34</span>).toPrecision(<span class="number">1</span>) <span class="comment">// "1e+1"</span></span><br><span class="line">(<span class="number">12.34</span>).toPrecision(<span class="number">2</span>) <span class="comment">// "12"</span></span><br><span class="line">(<span class="number">12.34</span>).toPrecision(<span class="number">3</span>) <span class="comment">// "12.3"</span></span><br><span class="line">(<span class="number">12.34</span>).toPrecision(<span class="number">4</span>) <span class="comment">// "12.34"</span></span><br><span class="line">(<span class="number">12.34</span>).toPrecision(<span class="number">5</span>) <span class="comment">// "12.340"</span></span><br></pre></td></tr></table></figure>
<p><code>toPrecision</code>方法的参数为有效数字的位数，范围是1到21，超出这个范围会抛出RangeError错误</p>
<p><code>toPrecision</code>方法用于四舍五入时不太可靠，跟浮点数不是精确储存有关</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">12.35</span>).toPrecision(<span class="number">3</span>) <span class="comment">// "12.3"</span></span><br><span class="line">(<span class="number">12.25</span>).toPrecision(<span class="number">3</span>) <span class="comment">// "12.3"</span></span><br><span class="line">(<span class="number">12.15</span>).toPrecision(<span class="number">3</span>) <span class="comment">// "12.2"</span></span><br><span class="line">(<span class="number">12.45</span>).toPrecision(<span class="number">3</span>) <span class="comment">// "12.4"</span></span><br></pre></td></tr></table></figure>
<p><strong>自定义方法</strong></p>
<p>与其他对象一样，<code>Number.prototype</code>对象上面可以自定义方法，被<code>Number</code>的实例继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span> + x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码为<code>Number</code>对象实例定义了一个<code>add</code>方法</p>
<p>在数值上调用某个方法，数值会自动转为<code>Number</code>的实例对象，所以就得到了下面的结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span>[<span class="string">'add'</span>](<span class="number">2</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，调用方法之所以写成<code>8[&#39;add&#39;]</code>，而不是<code>8.add</code>，是因为数值后面的点，会被解释为小数点，而不是点运算符。将数值放在圆括号中，就可以使用点运算符调用方法了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">8</span>).add(<span class="number">2</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>由于add方法返回的还是数值，所以可以链式运算</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.subtract = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span> - x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="number">8</span>).add(<span class="number">2</span>).subtract(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>上面代码在<code>Number</code>对象的实例上部署了<code>subtract</code>方法，它可以与<code>add</code>方法链式调用</p>
<p>我们还可以部署更复杂的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.iterate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="keyword">this</span>; i++) &#123;</span><br><span class="line">    result.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="number">8</span>).iterate()</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>
<p>上面代码在<code>Number</code>对象的原型上部署了<code>iterate</code>方法，可以将一个数值自动遍历为一个数组</p>
<p>需要注意的是，数值的自定义方法，只能定义在它的原型对象<code>Number.prototype</code>上面，数值本身是无法自定义属性的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line">n.x = <span class="number">1</span>;</span><br><span class="line">n.x <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>n</code>是一个原始类型的数值。直接在它上面新增一个属性x，不会报错，但毫无作用，总是返回undefined。这是因为一旦被调用属性，n就自动转为Number的实例对象，调用结束后，该对象自动销毁。所以，下一次调用n的属性时，实际取到的是另一个对象，属性x当然就读不出来</p>
<h4 id="ES6新增实例方法"><a href="#ES6新增实例方法" class="headerlink" title="ES6新增实例方法"></a>ES6新增实例方法</h4><p><strong>Number.isFinite(), Number.isNaN()</strong></p>
<p><code>Number.isFinite()</code>用来检查一个数值是否为有限的（finite）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">15</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0.8</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(-<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'foo'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'15'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><code>Number.isNaN()</code>用来检查一个值是否为<code>NaN</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">15</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'15'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">9</span>/<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'true'</span>/<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'true'</span>/<span class="string">'true'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>它们与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，<code>Number.isFinite()</code>对于非数值一律返回<code>false</code>, <code>Number.isNaN()</code>只有对于<code>NaN</code>才返回<code>true</code>，非<code>NaN</code>一律返回<code>false</code></p>
</blockquote>
<p><strong>Number.parseInt(), Number.parseFloat()</strong> </p>
<p><code>Number.parseInt()</code>方法可以根据给定的进制数把一个字符串解析成整数。该方法与全局的 <code>parseInt()</code>函数相同</p>
<p><code>Number.parseFloat()</code>方法可以把一个字符串解析成浮点数。该方法与全局的 <code>parseFloat()</code>函数相同</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'12.34'</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'123.45#'</span>) <span class="comment">// 123.45</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt(<span class="string">'12.34'</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat(<span class="string">'123.45#'</span>) <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure>
<p><strong>Number.isInteger()</strong></p>
<p><code>Number.isInteger()</code>用来判断一个值是否为整数。需要注意的是，在 JavaScript 内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.1</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="string">"15"</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">true</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="Boolean对象"><a href="#Boolean对象" class="headerlink" title="Boolean对象"></a>Boolean对象</h3><p><code>Boolean</code>对象是 JavaScript 的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象的实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> b <span class="comment">// "object"</span></span><br><span class="line">b.valueOf() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码的变量<code>b</code>是一个<code>Boolean</code>对象的实例，它的类型是对象，值为布尔值<code>true</code>。这种写法太繁琐，几乎无人使用，直接对变量赋值更简单清晰</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>注意，<code>false</code>对应的包装对象实例，布尔运算结果也是<code>true</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'true'</span>);</span><br><span class="line">&#125; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>).valueOf()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'true'</span>);</span><br><span class="line">&#125; <span class="comment">// 无输出</span></span><br></pre></td></tr></table></figure>
<p>上面代码的第一个例子之所以得到<code>true</code>，是因为<code>false</code>对应的包装对象实例是一个对象，进行逻辑运算时，被自动转化成布尔值<code>true</code>（因为所有对象对应的布尔值都是<code>true</code>）。而实例的<code>valueOf</code>方法，则返回实例对应的原始值，本例为<code>false</code></p>
<h4 id="Boolean-函数"><a href="#Boolean-函数" class="headerlink" title="Boolean 函数"></a>Boolean 函数</h4><p><code>Boolean</code>对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时<code>Boolean</code>就是一个单纯的工具方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">''</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">'false'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>([]) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="regexp">/foo/</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中几种得到<code>true</code>的情况，都值得认真记住</p>
<p>使用双重的否运算符（<code>!</code>）也可以将任意值转为对应的布尔值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">!!<span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="literal">null</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="number">0</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="string">''</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="number">1</span> <span class="comment">// true</span></span><br><span class="line">!!<span class="string">'false'</span> <span class="comment">// true</span></span><br><span class="line">!![] <span class="comment">// true</span></span><br><span class="line">!!&#123;&#125; <span class="comment">// true</span></span><br><span class="line">!!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// true</span></span><br><span class="line">!!<span class="regexp">/foo/</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>最后，对于一些特殊值，<code>Boolean</code>对象前面加不加<code>new</code>，会得到完全相反的结果，必须小心</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Boolean</span>(<span class="literal">false</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'true'</span>);</span><br><span class="line">&#125; <span class="comment">// 无输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'true'</span>);</span><br><span class="line">&#125; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Boolean</span>(<span class="literal">null</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'true'</span>);</span><br><span class="line">&#125; <span class="comment">// 无输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">null</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'true'</span>);</span><br><span class="line">&#125; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h3><p>所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的<code>Number</code>、<code>String</code>、<code>Boolean</code>三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">var</span> v2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'abc'</span>);</span><br><span class="line"><span class="keyword">var</span> v3 = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码根据原始类型的值，生成了三个对象，与原始值的类型不同。这用<code>typeof</code>运算符就可以看出来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> v1 <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> v2 <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> v3 <span class="comment">// "object"</span></span><br><span class="line"></span><br><span class="line">v1 === <span class="number">123</span> <span class="comment">// false</span></span><br><span class="line">v2 === <span class="string">'abc'</span> <span class="comment">// false</span></span><br><span class="line">v3 === <span class="literal">true</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>JavaScript设计包装对象的最大目的，首先是使得JavaScript的“对象”涵盖所有的值。其次，使得原始类型的值可以方便地调用特定方法。</p>
<p><code>Number</code>、<code>String</code>和<code>Boolean</code>如果不作为构造函数调用（即调用时不加<code>new</code>），常常用于将任意类型的值转为数值、字符串和布尔值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="number">123</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">String</span>(<span class="string">'abc'</span>) <span class="comment">// "abc"</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">true</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="包装对象实例方法"><a href="#包装对象实例方法" class="headerlink" title="包装对象实例方法"></a>包装对象实例方法</h4><p>包装对象实例可以使用Object对象提供的原生方法，主要是<code>valueOf</code>方法和<code>toString</code>方法。</p>
<p><strong>valueOf()</strong></p>
<p><code>valueOf</code>方法返回包装对象实例对应的原始类型的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>).valueOf()  <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>).valueOf() <span class="comment">// "abc"</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">"true"</span>).valueOf() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>toString()</strong></p>
<p><code>toString</code>方法返回实例对应的字符串形式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>).toString() <span class="comment">// "123"</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>).toString() <span class="comment">// "abc"</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">"true"</span>).toString() <span class="comment">// "true"</span></span><br></pre></td></tr></table></figure>
<h4 id="原始类型自动转换"><a href="#原始类型自动转换" class="headerlink" title="原始类型自动转换"></a>原始类型自动转换</h4><p>原始类型的值，可以自动当作对象调用，即调用各种对象的方法和参数。这时，JavaScript引擎会自动将原始类型的值转为包装对象，在使用后立刻销毁</p>
<p>比如，字符串可以调用<code>length</code>属性，返回字符串的长度</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>abc</code>是一个字符串，本身不是对象，不能调用<code>length</code>属性。JavaScript引擎自动将其转为包装对象，在这个对象上调用<code>length</code>属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型的自动转换。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'abc'</span>;</span><br><span class="line">str.length <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> strObj = <span class="keyword">new</span> <span class="built_in">String</span>(str)</span><br><span class="line"><span class="comment">// String &#123;</span></span><br><span class="line"><span class="comment">//   0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">strObj.length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串<code>abc</code>的包装对象有每个位置的值、有<code>length</code>属性、还有一个内部属性<code>[[PrimitiveValue]]</code>保存字符串的原始值。这个<code>[[PrimitiveValue]]</code>内部属性，外部是无法调用，仅供<code>ValueOf</code>或<code>toString</code>这样的方法内部调用</p>
<p>这个临时对象是只读的，无法修改。所以，字符串无法添加新属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Hello World'</span>;</span><br><span class="line">s.x = <span class="number">123</span>;</span><br><span class="line">s.x <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码为字符串<code>s</code>添加了一个<code>x</code>属性，结果无效，总是返回<code>undefined</code></p>
<p>另一方面，调用结束后，临时对象会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果想要为字符串添加属性，只有在它的原型对象<code>String.prototype</code>上定义</p>
<p>这种原始类型值可以直接调用的方法还有很多，除了<code>valueOf</code>和<code>toString</code>方法，还包括三个包装对象各自定义在原型上的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.charAt === <span class="built_in">String</span>.prototype.charAt</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，字符串<code>abc</code>的<code>charAt</code>方法，实际上就是定义在<code>String</code>对象原型上的方法</p>
<p>如果包装对象与原始类型值进行混合运算，包装对象会转化为原始类型（实际是调用自身的<code>valueOf</code>方法）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) + <span class="number">123</span> <span class="comment">// 246</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'abc'</span>) + <span class="string">'abc'</span> <span class="comment">// "abcabc"</span></span><br></pre></td></tr></table></figure>
<h4 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h4><p>三种包装对象还可以在原型上添加自定义方法和属性，供原始类型的值直接调用</p>
<p>比如，可以新增一个<code>double</code>方法，使得字符串和数字翻倍</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.double = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.valueOf() + <span class="keyword">this</span>.valueOf();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="string">'abc'</span>.double()</span><br><span class="line"><span class="comment">// abcabc</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.prototype.double = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.valueOf() + <span class="keyword">this</span>.valueOf();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="number">123</span>).double()</span><br><span class="line"><span class="comment">// 246</span></span><br></pre></td></tr></table></figure>
<p>上面代码在<code>123</code>外面必须要加上圆括号，否则后面的点运算符（<code>.</code>）会被解释成小数点</p>
<p>但是，这种自定义方法和属性的机制，只能定义在包装对象的原型上，如果直接对原始类型的变量添加属性，则无效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'abc'</span>;</span><br><span class="line"></span><br><span class="line">s.p = <span class="number">123</span>;</span><br><span class="line">s.p <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码直接对字符串<code>abc</code>添加属性，结果无效。主要原因是上面说的，这里的包装对象是自动生成的，赋值后自动销毁，所以最后一行实际上调用的是一个新的包装对象</p>
<h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><h5 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h5><p><strong>1.操作符</strong></p>
<p><strong>++ 、 – 、一元+ 、 一元- 、 ~ 、&amp; 、| 、^ 、&lt;&lt; 、&gt;&gt; 、 &gt;&gt;&gt; 、* 、 / 、%</strong> </p>
<blockquote>
<p>针对Number类型的，因此对其他类型应用这些操作符时，自动执行Number()函数进行类型转换<br>其中对于位操作符，NaN和Infinity都会当成0处理</p>
</blockquote>
<p><strong>+</strong></p>
<blockquote>
<ul>
<li>两个操作数都是数值，就是数值操作</li>
<li>有一个操作数是字符串，就执行字符串拼接</li>
<li>其他情况都先执行String()方法进行类型转换成String类型，然后进行字符串拼接</li>
</ul>
</blockquote>
<p><strong>&gt;、&lt;、&gt;=、&lt;=</strong></p>
<blockquote>
<ul>
<li>除了两个操作数都是字符串的情况，其他都转换成Number类型比较大小</li>
<li>任何操作数与NaN进行比较，结果都是false</li>
<li>对于两个操作数都是字符串，比较的是字符串的字符编码</li>
</ul>
</blockquote>
<p><strong>==、!=</strong><br>隐式类型转换，一般都是转换为数值</p>
<blockquote>
<ul>
<li>这里判断的相等只能说明值相等（对于基本类型）或引用相等（对于引用类型），并不能说明类型也一致</li>
<li>NaN和任何值都不相等</li>
<li>对象相等是指向同一对象才相等</li>
<li>undefined == null 返回true，因为ECMA262规定的</li>
</ul>
</blockquote>
<p><strong>===、！==</strong> </p>
<blockquote>
<p>不经类型转换就比较，一般用来对类型相同，值也相同的判断</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span>!==<span class="literal">undefined</span>; <span class="comment">//返回true1</span></span><br></pre></td></tr></table></figure>
<p><strong>2.if语句、条件操作符 、! 、while语句</strong></p>
<p>这种针对Boolean类型的，因此对其他类型应用这些操作符时，自动执行Boolean()函数</p>
<blockquote>
<p>由于<strong>空字符串、0、NaN、null、undefined</strong>均会转换成false，在检查一个变量是否未定义，不要用真值检测，要用typeof和===</p>
</blockquote>
<p>除了在条件语句中使用<code>==</code>、<code>!=</code>，其他情况避免使用，而应使用严格等于<code>===</code>或者严格不等于<code>!==</code></p>
<p><strong>3.逻辑运算符</strong></p>
<p><strong>&amp;&amp;</strong><br>短路操作，不一定返回布尔值</p>
<blockquote>
<ul>
<li>第一个操作数是对象，返回第二个操作数</li>
<li>第二个操作数是对象，则第一个操作数求值为true时，返回该对象</li>
<li>两个操作数都是对象，返回第二个操作数</li>
<li>有一个操作数是null，返回null</li>
<li>有一个操作数是NaN，返回NaN</li>
<li>有一个操作数是underfined，返回undefined</li>
</ul>
</blockquote>
<p><strong>不能使用未定义的值，否则报错</strong></p>
<p><strong>||</strong><br>短路操作，不一定返回布尔值</p>
<blockquote>
<ul>
<li>第一个操作数是对象，返回第一个操作数</li>
<li>第一个操作数求值为false时，返回第二个操作数</li>
<li>两个操作数都是对象，返回第一个操作数</li>
<li>有两个操作数都是null，返回null</li>
<li>有两个操作数是NaN，返回NaN</li>
<li>有两个操作数是underfined，返回undefined</li>
</ul>
</blockquote>
<p><strong>不能使用未定义的值不能使用未定义的值，否则报错</strong><br>应用：赋值操作经常采用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aObeject = firstObject || secondObject;</span><br></pre></td></tr></table></figure>
<p><strong>4. isNaN()</strong></p>
<p>将其他不是NaN的尝试转换成NaN，因此isNaN不能用来检测是不是NaN，只能用来检查是不是可用数值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="string">"str"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(&#123; <span class="attr">a</span>: <span class="string">"b"</span> &#125;); <span class="comment">// true1234</span></span><br></pre></td></tr></table></figure>
<p>可以用下面这个函数来检查是不是NaN</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isReallyNaN</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x !== x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><p><strong>转换函数</strong>：</p>
<blockquote>
<ul>
<li>parseInt()</li>
<li>parseFloat()</li>
<li>toString()</li>
</ul>
</blockquote>
<p><strong>构造函数</strong>：</p>
<blockquote>
<ul>
<li>Object()</li>
</ul>
<ul>
<li>Boolean()</li>
<li>Number()</li>
<li>String()</li>
</ul>
</blockquote>
<p><strong>有关对象的几条应该遵守的规则：</strong></p>
<ul>
<li>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象</li>
<li>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code></li>
<li>用<code>String()</code>来转换任意类型到<code>string</code>，或者直接调用某个对象的<code>toString()</code>方法</li>
<li>通常不必把任意类型转换为<code>boolean</code>再判断，因为可以直接写<code>if (myVar) {...}</code></li>
<li><code>typeof</code>操作符可以判断出<code>number</code>、<code>boolean</code>、<code>string</code>、<code>function</code> 、<code>undefined</code>、<code>object</code>和<code>symbol</code></li>
<li>判断<code>Array</code>要使用<code>Array.isArray(arr)</code></li>
<li>判断<code>null</code>请使用<code>myVar === null</code></li>
<li>判断某个全局变量是否存在用<code>typeof window.myVar === &#39;undefined&#39;</code></li>
<li>函数内部判断某个变量是否存在用<code>typeof myVar === &#39;undefined&#39;</code></li>
<li>除了<code>undefined</code>和<code>null</code>都可以使用<code>toString()</code>方法判断类型，虽然<code>null</code>还伪装成了<code>object</code>类型</li>
</ul>
<h3 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h3><p>JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式，目的是取代繁琐笨重的 XML 格式。相比 XML 格式</p>
<p>每个 JSON 对象，就是一个值。要么是简单类型的值，要么是复合类型的值，但是只能是一个值，不能是两个或更多的值。JSON 对值的类型和格式有严格的规定：</p>
<ul>
<li>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象</li>
<li>简单类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和<code>null</code>（不能使用NaN，undefined，Infinity和-Infinity）</li>
<li>字符串必须使用双引号表示，不能使用单引号</li>
<li>对象的键名必须放在双引号里面</li>
<li>数组或对象最后一个成员的后面，不能加逗号</li>
</ul>
<p>以下是合格的 JSON 值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>]</span><br><span class="line"></span><br><span class="line">&#123; <span class="string">"one"</span>: <span class="number">1</span>, <span class="string">"two"</span>: <span class="number">2</span>, <span class="string">"three"</span>: <span class="number">3</span> &#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">"names"</span>: [<span class="string">"张三"</span>, <span class="string">"李四"</span>] &#125;</span><br><span class="line"></span><br><span class="line">[ &#123; <span class="string">"name"</span>: <span class="string">"张三"</span>&#125;, &#123;<span class="string">"name"</span>: <span class="string">"李四"</span>&#125; ]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，空数组和空对象都是合格的 JSON 值，<code>null</code>本身也是一个合格的 JSON 值</p>
</blockquote>
<h4 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h4><p><strong>基本用法</strong></p>
<p><code>JSON.stringify</code>方法用于将一个值转为字符串。该字符串符合 JSON 格式，并且可以被<code>JSON.parse</code>方法还原：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'abc'</span>) <span class="comment">// ""abc""</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="number">1</span>) <span class="comment">// "1"</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="literal">false</span>) <span class="comment">// "false"</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify([]) <span class="comment">// "[]"</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123;&#125;) <span class="comment">// "&#123;&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify([<span class="number">1</span>, <span class="string">"false"</span>, <span class="literal">false</span>])</span><br><span class="line"><span class="comment">// '[1,"false",false]'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">name</span>: <span class="string">"张三"</span> &#125;)</span><br><span class="line"><span class="comment">// '&#123;"name":"张三"&#125;'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，对于原始类型的字符串，转换结果会带双引号</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'foo'</span>) === <span class="string">"foo"</span> <span class="comment">// false</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'foo'</span>) === <span class="string">"\"foo\""</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果原始对象中，有一个成员的值是<code>undefined</code>、函数或 XML 对象，这个成员会被过滤</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="literal">undefined</span>,</span><br><span class="line">  b: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj) <span class="comment">// "&#123;&#125;"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果数组的成员是<code>undefined</code>、函数或 XML 对象，则这些值被转成<code>null</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;];</span><br><span class="line"><span class="built_in">JSON</span>.stringify(arr) <span class="comment">// "[null,null]"</span></span><br></pre></td></tr></table></figure>
<p><strong>第二个参数</strong></p>
<p><code>JSON.stringify</code>方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">'prop1'</span>: <span class="string">'value1'</span>,</span><br><span class="line">  <span class="string">'prop2'</span>: <span class="string">'value2'</span>,</span><br><span class="line">  <span class="string">'prop3'</span>: <span class="string">'value3'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> selectedProperties = [<span class="string">'prop1'</span>, <span class="string">'prop2'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj, selectedProperties)</span><br><span class="line"><span class="comment">// "&#123;"prop1":"value1","prop2":"value2"&#125;"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个类似“白名单”的数组，只对对象的属性有效，对数组无效</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify([<span class="string">'a'</span>, <span class="string">'b'</span>], [<span class="string">'0'</span>])</span><br><span class="line"><span class="comment">// "["a","b"]"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>&#125;, [<span class="string">'0'</span>])</span><br><span class="line"><span class="comment">// "&#123;"0":"a"&#125;"</span></span><br></pre></td></tr></table></figure>
<p>第二个参数还可以是一个函数，它有两个参数，键(key)值(value)。用来更改<code>JSON.stringify</code>的默认行为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"["</span>+ key +<span class="string">"]:"</span> + value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(o, f)</span><br><span class="line"><span class="comment">// []:[object Object]</span></span><br><span class="line"><span class="comment">// [a]:[object Object]</span></span><br><span class="line"><span class="comment">// [b]:1</span></span><br><span class="line"><span class="comment">// '&#123;"a":&#123;"b":1&#125;&#125;'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果处理函数返回<code>undefined</code>或没有返回值，则该属性会被忽略</p>
</blockquote>
<p><strong>第三个参数</strong></p>
<p><code>JSON.stringify</code>还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">p1</span>: <span class="number">1</span>, <span class="attr">p2</span>: <span class="number">2</span> &#125;, <span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">"&#123;</span></span><br><span class="line"><span class="comment">  "p1": 1,</span></span><br><span class="line"><span class="comment">  "p2": 2</span></span><br><span class="line"><span class="comment">&#125;"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">p1</span>:<span class="number">1</span>, <span class="attr">p2</span>:<span class="number">2</span> &#125;, <span class="literal">null</span>, <span class="string">'|-'</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">"&#123;</span></span><br><span class="line"><span class="comment">|-"p1": 1,</span></span><br><span class="line"><span class="comment">|-"p2": 2</span></span><br><span class="line"><span class="comment">&#125;"</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>toJSON方法</strong></p>
<p>如果对象有自定义的<code>toJSON</code>方法，那么<code>JSON.stringify</code>会使用这个方法的返回值作为参数，而忽略原对象的其他属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">'三'</span>,</span><br><span class="line">  lastName: <span class="string">'张'</span>,</span><br><span class="line"></span><br><span class="line">  get fullName()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.lastName + <span class="keyword">this</span>.firstName;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  toJSON: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = &#123;</span><br><span class="line">      firstName: <span class="keyword">this</span>.firstName,</span><br><span class="line">      lastName: <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(user)</span><br><span class="line"><span class="comment">// "&#123;"firstName":"三","lastName":"张"&#125;"</span></span><br></pre></td></tr></table></figure>
<h4 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h4><p><code>JSON.parse</code>方法用于将JSON字符串转化成对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;&#125;'</span>) <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'true'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'"foo"'</span>) <span class="comment">// "foo"</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'[1, 5, "false"]'</span>) <span class="comment">// [1, 5, "false"]</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'null'</span>) <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"name": "张三"&#125;'</span>);</span><br><span class="line">o.name <span class="comment">// 张三</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果传入的字符串不是有效的JSON格式，<code>JSON.parse</code>方法将报错</p>
</blockquote>
<p><code>JSON.parse</code>方法可以接受一个处理函数，用法与<code>JSON.stringify</code>方法类似</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">''</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">'a'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a":1,"b":2&#125;'</span>, f);</span><br><span class="line">o.a <span class="comment">// 11</span></span><br><span class="line">o.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h3><p><strong>见JavaScript RegExp篇</strong></p>
<h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><p><strong>见JavaScript Math&amp;Date篇</strong></p>
<h3 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h3><p><strong>见JavaScript Math&amp;Date篇</strong></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">JavaScript</a>
        		</li>
      		
		</ul>
	</div>

      

      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-JavaScript Ajax" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/12/JavaScript Ajax/">JavaScript Ajax</a>
    </h1>
  

        
        <a href="/2018/08/12/JavaScript Ajax/" class="archive-article-date">
  	<time datetime="2018-08-11T16:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-08-12</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JavaScript-Ajax"><a href="#JavaScript-Ajax" class="headerlink" title="JavaScript Ajax"></a>JavaScript Ajax</h2><h3 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h3><p><code>XMLHttpRequest</code>对象用来在浏览器与服务器之间传送数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ajax = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">ajax.open(<span class="string">'GET'</span>, <span class="string">'http://www.example.com/page.php'</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>然后，AJAX指定回调函数，监听通信状态（<code>readyState</code>属性）的变化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ajax.onreadystatechange = handleStateChange;</span><br></pre></td></tr></table></figure>
<p>一旦拿到服务器返回的数据，AJAX不会刷新整个网页，而是只更新相关部分，从而不打断用户正在做的事情</p>
<p><code>XMLHttpRequest</code>可以报送各种数据，包括字符串和二进制，而且除了HTTP，它还支持通过其他协议传送（比如File和FTP）</p>
<p><code>XMLHttpRequest</code>对象的典型用法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定通信过程中状态改变时的回调函数</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 通信成功时，状态值为4</span></span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.status === <span class="number">200</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(xhr.statusText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(xhr.statusText);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// open方式用于指定HTTP动词、请求的网址、是否异步</span></span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'/endpoint'</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送HTTP请求</span></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h3 id="XMLHttpRequest实例属性"><a href="#XMLHttpRequest实例属性" class="headerlink" title="XMLHttpRequest实例属性"></a>XMLHttpRequest实例属性</h3><h4 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h4><blockquote>
<p><code>readyState</code>是一个只读属性，用一个整数和对应的常量，表示XMLHttpRequest请求当前所处的状态</p>
</blockquote>
<ul>
<li>0，对应常量<code>UNSENT</code>，表示XMLHttpRequest实例已经生成，但是<code>open()</code>方法还没有被调用</li>
<li>1，对应常量<code>OPENED</code>，表示<code>send()</code>方法还没有被调用，仍然可以使用<code>setRequestHeader()</code>，设定HTTP请求的头信息</li>
<li>2，对应常量<code>HEADERS_RECEIVED</code>，表示<code>send()</code>方法已经执行，并且头信息和状态码已经收到</li>
<li>3，对应常量<code>LOADING</code>，表示正在接收服务器传来的body部分的数据，如果<code>responseType</code>属性是<code>text</code>或者空字符串，<code>responseText</code>就会包含已经收到的部分信息</li>
<li>4，对应常量<code>DONE</code>，表示服务器数据已经完全接收，或者本次接收已经失败了</li>
</ul>
<p>在通信过程中，每当发生状态变化的时候，<code>readyState</code>属性的值就会发生改变。这个值每一次变化，都会触发<code>readyStateChange</code>事件</p>
<h4 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h4><blockquote>
<p><code>onreadystatechange</code>属性指向一个回调函数，当<code>readystatechange</code>事件发生的时候，这个回调函数就会调用，并且XMLHttpRequest实例的<code>readyState</code>属性也会发生变化</p>
</blockquote>
<p>另外，如果使用<code>abort()</code>方法，终止XMLHttpRequest请求，<code>onreadystatechange</code>回调函数也会被调用</p>
<h4 id="response"><a href="#response" class="headerlink" title="response"></a>response</h4><blockquote>
<p><code>response</code>属性为只读，返回接收到的数据体（即body部分）。它的类型可以是ArrayBuffer、Blob、Document、JSON对象、或者一个字符串，这由<code>XMLHttpRequest.responseType</code>属性的值决定</p>
</blockquote>
<p>如果本次请求没有成功或者数据不完整，该属性就会等于<code>null</code></p>
<h4 id="responseType"><a href="#responseType" class="headerlink" title="responseType"></a>responseType</h4><blockquote>
<p><code>responseType</code>属性用来指定服务器返回数据（<code>xhr.response</code>）的类型</p>
</blockquote>
<ul>
<li>”“：字符串（默认值）</li>
<li>“arraybuffer”：ArrayBuffer对象</li>
<li>“blob”：Blob对象</li>
<li>“document”：Document对象</li>
<li>“json”：JSON对象</li>
<li>“text”：字符串</li>
</ul>
<p>text类型适合大多数情况，而且直接处理文本也比较方便，document类型适合返回XML文档的情况，blob类型适合读取二进制数据，比如图片文件；如果将这个属性设为ArrayBuffer，就可以按照数组的方式处理二进制数据；如果将这个属性设为“json”，支持JSON的浏览器（Firefox&gt;9，chrome&gt;30），就会自动对返回数据调用<code>JSON.parse()</code>方法，得到一个JSON对象</p>
<h4 id="responseText"><a href="#responseText" class="headerlink" title="responseText"></a>responseText</h4><blockquote>
<p><code>responseText</code>属性返回从服务器接收到的字符串，该属性为只读。如果本次请求没有成功或者数据不完整，该属性就会等于<code>null</code></p>
</blockquote>
<p>如果服务器返回的数据格式是JSON，也可以使用<code>responseText</code>属性</p>
<h4 id="responseXML"><a href="#responseXML" class="headerlink" title="responseXML"></a>responseXML</h4><blockquote>
<p><code>responseXML</code>属性返回从服务器接收到的Document对象，该属性为只读。如果本次请求没有成功，或者数据不完整，或者不能被解析为XML或HTML，该属性等于<code>null</code></p>
</blockquote>
<p>返回的数据会被直接解析为DOM对象。如果服务器返回的数据，没有明示<code>Content-Type</code>头信息等于<code>text/xml</code>，可以使用<code>overrideMimeType()</code>方法，指定XMLHttpRequest对象将返回的数据解析为XML</p>
<h4 id="responseURL"><a href="#responseURL" class="headerlink" title="responseURL"></a>responseURL</h4><blockquote>
<p>responseURL返回ajax请求最终的URL, 如果请求中存在重定向, 那么responseURL表示重定向之后的URL.</p>
</blockquote>
<h4 id="status"><a href="#status" class="headerlink" title="status"></a>status</h4><blockquote>
<p><code>status</code>属性为只读属性，表示本次请求所得到的HTTP状态码，它是一个整数。一般来说，如果通信成功的话，这个状态码是200：</p>
</blockquote>
<ul>
<li>200, OK，访问正常</li>
<li>301, Moved Permanently，永久移动</li>
<li>302, Move temporarily，暂时移动</li>
<li>304, Not Modified，未修改</li>
<li>307, Temporary Redirect，暂时重定向</li>
<li>401, Unauthorized，未授权</li>
<li>403, Forbidden，禁止访问</li>
<li>404, Not Found，未发现指定网址</li>
<li>500, Internal Server Error，服务器发生错误</li>
</ul>
<p>基本上，只有2xx和304的状态码，表示服务器返回是正常状态</p>
<h4 id="statusText"><a href="#statusText" class="headerlink" title="statusText"></a>statusText</h4><blockquote>
<p><code>statusText</code>属性为只读属性，返回一个字符串，表示服务器发送的状态提示。不同于<code>status</code>属性，该属性包含整个状态信息，比如”200 OK“</p>
</blockquote>
<h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h4><blockquote>
<p><code>timeout</code>属性等于一个整数，表示多少毫秒后，如果请求仍然没有得到结果，就会自动终止。如果该属性等于0，就表示没有时间限制</p>
</blockquote>
<h4 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h4><p><code>upload</code>属性返回一个 <code>XMLHttpRequestUpload</code>对象，用来表示上传的进度。这个对象是不透明的，但是作为一个<code>XMLHttpRequestEventTarget</code>，可以通过对其绑定事件来追踪它的进度</p>
<p>可以被绑定在upload对象上的事件监听器如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">事件</th>
<th style="text-align:center">相应属性的信息类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>onloadstart</code></td>
<td style="text-align:center">获取开始</td>
</tr>
<tr>
<td style="text-align:center"><code>onprogress</code></td>
<td style="text-align:center">数据传输进行中</td>
</tr>
<tr>
<td style="text-align:center"><code>onabort</code></td>
<td style="text-align:center">获取操作终止</td>
</tr>
<tr>
<td style="text-align:center"><code>onerror</code></td>
<td style="text-align:center">获取失败</td>
</tr>
<tr>
<td style="text-align:center"><code>onload</code></td>
<td style="text-align:center">获取成功</td>
</tr>
<tr>
<td style="text-align:center"><code>ontimeout</code></td>
<td style="text-align:center">获取操作因用户指定的延迟时间内未完成</td>
</tr>
<tr>
<td style="text-align:center"><code>onloadend</code></td>
<td style="text-align:center">获取完成（不能成功与否））</td>
</tr>
</tbody>
</table>
<p>注意，如果发生网络错误（比如服务器无法连通），<code>onerror</code>事件无法获取报错信息，只能显示报错</p>
<h4 id="withCredentials"><a href="#withCredentials" class="headerlink" title="withCredentials"></a>withCredentials</h4><blockquote>
<p><code>withCredentials</code>属性是一个布尔值，表示跨域请求时，用户信息（比如Cookie和认证的HTTP头信息）是否会包含在请求之中，默认为<code>false</code>。即向<code>example.com</code>发出跨域请求时，不会发送<code>example.com</code>设置在本机上的Cookie（如果有的话）</p>
</blockquote>
<p>如果你需要通过跨域AJAX发送Cookie，需要打开<code>withCredentials</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>为了让这个属性生效，服务器必须显式返回<code>Access-Control-Allow-Credentials</code>这个头信息</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="XMLHttpRequest实例方法"><a href="#XMLHttpRequest实例方法" class="headerlink" title="XMLHttpRequest实例方法"></a>XMLHttpRequest实例方法</h3><h4 id="abort"><a href="#abort" class="headerlink" title="abort()"></a>abort()</h4><blockquote>
<p><code>abort</code>方法用来终止已经发出的HTTP请求</p>
</blockquote>
<h4 id="getAllResponseHeaders"><a href="#getAllResponseHeaders" class="headerlink" title="getAllResponseHeaders()"></a>getAllResponseHeaders()</h4><blockquote>
<p><code>getAllResponseHeaders</code>方法返回服务器发来的所有HTTP头信息。格式为字符串，每个头信息之间使用<code>CRLF</code>分隔，如果没有受到服务器回应，该属性返回<code>null</code></p>
</blockquote>
<h4 id="getResponseHeader"><a href="#getResponseHeader" class="headerlink" title="getResponseHeader()"></a>getResponseHeader()</h4><blockquote>
<p><code>getResponseHeader</code>方法接受一个字段作为参数，返回HTTP头信息指定字段的值，如果还没有收到服务器回应或者指定字段不存在，则该属性为<code>null</code></p>
</blockquote>
<p>如果有多个字段同名，则它们的值会被连接为一个字符串，每个字段之间使用“逗号+空格”分隔</p>
<h4 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h4><blockquote>
<p><code>XMLHttpRequest</code>对象的<code>open</code>方法用于指定发送HTTP请求的参数，它的使用格式如下：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> open(</span><br><span class="line">   string method,</span><br><span class="line">   string url,</span><br><span class="line">   optional boolean <span class="keyword">async</span>,</span><br><span class="line">   optional string user,</span><br><span class="line">   optional string password</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>一共接受五个参数：</p>
<ul>
<li><code>method</code>：表示HTTP动词，比如“GET”、“POST”、“PUT”和“DELETE”</li>
<li><code>url</code>: 表示请求发送的网址</li>
<li><code>async</code>: 格式为布尔值，默认为<code>true</code>，表示请求是否为异步。如果设为<code>false</code>，则<code>send()</code>方法只有等到收到服务器返回的结果，才会有返回值</li>
<li><code>user</code>：表示用于认证的用户名，默认为空字符串</li>
<li><code>password</code>：表示用于认证的密码，默认为空字符串</li>
</ul>
<p>如果对使用过<code>open()</code>方法的请求，再次使用这个方法，等同于调用<code>abort()</code></p>
<h4 id="send"><a href="#send" class="headerlink" title="send()"></a>send()</h4><blockquote>
<p><code>send</code>方法用于实际发出HTTP请求。如果不带参数，就表示HTTP请求只包含头信息，也就是只有一个URL，典型例子就是GET请求；如果带有参数，就表示除了头信息，还带有包含具体数据的信息体，典型例子就是POST请求</p>
</blockquote>
<p><code>GET</code>请求的参数，可以作为查询字符串附加在URL后面，也可以作为<code>send</code>方法的参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajax.open(<span class="string">'GET'</span></span><br><span class="line">  , <span class="string">'http://www.example.com/somepage.php?id='</span> + <span class="built_in">encodeURIComponent</span>(id)</span><br><span class="line">  , <span class="literal">true</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="string">'id='</span> + <span class="built_in">encodeURIComponent</span>(id));</span><br><span class="line">ajax.open(<span class="string">'GET'</span>, <span class="string">'http://www.example.com/somepage.php'</span>, <span class="literal">true</span>);</span><br><span class="line">ajax.send(data);</span><br></pre></td></tr></table></figure>
<p>发送POST请求的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="string">'email='</span></span><br><span class="line">  + <span class="built_in">encodeURIComponent</span>(email)</span><br><span class="line">  + <span class="string">'&amp;password='</span></span><br><span class="line">  + <span class="built_in">encodeURIComponent</span>(password);</span><br><span class="line">ajax.open(<span class="string">'POST'</span>, <span class="string">'http://www.example.com/somepage.php'</span>, <span class="literal">true</span>);</span><br><span class="line">ajax.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">ajax.send(data);</span><br></pre></td></tr></table></figure>
<p>注意，所有XMLHttpRequest的监听事件，都必须在<code>send()</code>方法调用之前设定</p>
<p><code>send</code>方法的参数就是发送的数据。多种格式的数据，都可以作为它的参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> send();</span><br><span class="line"><span class="keyword">void</span> send(ArrayBufferView data);</span><br><span class="line"><span class="keyword">void</span> send(Blob data);</span><br><span class="line"><span class="keyword">void</span> send(Document data);</span><br><span class="line"><span class="keyword">void</span> send(<span class="built_in">String</span> data);</span><br><span class="line"><span class="keyword">void</span> send(FormData data);</span><br></pre></td></tr></table></figure>
<h4 id="setRequestHeader"><a href="#setRequestHeader" class="headerlink" title="setRequestHeader()"></a>setRequestHeader()</h4><blockquote>
<p><code>setRequestHeader</code>方法用于设置HTTP头信息。该方法必须在<code>open()</code>之后、<code>send()</code>之前调用。如果该方法多次调用，设定同一个字段，则每一次调用的值会被合并成一个单一的值发送</p>
</blockquote>
<h4 id="overrideMimeType"><a href="#overrideMimeType" class="headerlink" title="overrideMimeType()"></a>overrideMimeType()</h4><blockquote>
<p>该方法用来指定服务器返回数据的MIME类型。该方法必须在<code>send()</code>之前调用</p>
</blockquote>
<p>这种方法很麻烦，在XMLHttpRequest版本升级以后，一般采用指定<code>responseType</code>的方法</p>
<h3 id="XMLHttpRequest实例事件"><a href="#XMLHttpRequest实例事件" class="headerlink" title="XMLHttpRequest实例事件"></a>XMLHttpRequest实例事件</h3><h4 id="abort事件"><a href="#abort事件" class="headerlink" title="abort事件"></a>abort事件</h4><blockquote>
<p>当一个资源的加载已中止时，将触发 <strong>abort</strong>事件</p>
</blockquote>
<h4 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h4><blockquote>
<p>当一个资源加载失败时会触发error事件</p>
</blockquote>
<h4 id="load事件"><a href="#load事件" class="headerlink" title="load事件"></a>load事件</h4><blockquote>
<p>当一个资源及其依赖资源已完成加载时，将触发load事件</p>
</blockquote>
<h4 id="loadend事件"><a href="#loadend事件" class="headerlink" title="loadend事件"></a>loadend事件</h4><blockquote>
<p>loadend事件总是在一个资源的加载进度停止之后被触发</p>
</blockquote>
<h4 id="progress事件"><a href="#progress事件" class="headerlink" title="progress事件"></a>progress事件</h4><blockquote>
<p>进度事件会被触发用来指示一个操作正在进行中</p>
</blockquote>
<h4 id="readystatechange事件"><a href="#readystatechange事件" class="headerlink" title="readystatechange事件"></a>readystatechange事件</h4><blockquote>
<p><code>readyState</code>属性的值发生改变，就会触发readyStateChange事件</p>
</blockquote>
<h4 id="timeout事件"><a href="#timeout事件" class="headerlink" title="timeout事件"></a>timeout事件</h4><blockquote>
<p><code>当进度由于预定时间到期而终止时，会触发timeout</code> 事件</p>
</blockquote>
<h3 id="XHR一级"><a href="#XHR一级" class="headerlink" title="XHR一级"></a>XHR一级</h3><p>XHR1 即 XMLHttpRequest Level 1。XHR1的xhr对象具有如下缺点:</p>
<ul>
<li>仅支持文本数据传输, 无法传输二进制数据</li>
<li>传输数据时, 没有进度信息提示, 只能提示是否完成</li>
<li>受浏览器 <code>同源策略</code> 限制, 只能请求同域资源</li>
<li>没有超时机制, 不方便掌控ajax请求节奏</li>
</ul>
<h3 id="XHR二级"><a href="#XHR二级" class="headerlink" title="XHR二级"></a>XHR二级</h3><p>XHR2 即 XMLHttpRequest Level 2。XHR2针对XHR1的上述缺点做了如下改进：</p>
<ul>
<li>支持二进制数据, 可以上传文件, 可以使用FormData对象管理表单</li>
<li>提供进度提示, 可通过 <code>xhr.upload.onprogress</code> 事件回调方法获取传输进度</li>
<li>依然受 <code>同源策略</code> 限制, 这个安全机制不会变. XHR2新提供 <code>Access-Control-Allow-Origin</code> 等headers, 设置为 <code>*</code> 时表示允许任何域名请求, 从而实现跨域CORS访问</li>
<li>可以设置timeout 及 ontimeout, 方便设置超时时长和超时后续处理</li>
</ul>
<p>FormData对象例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可直接创建FormData实例</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line">data.append(<span class="string">"name"</span>, <span class="string">"louis"</span>);</span><br><span class="line">xhr.send(data);</span><br><span class="line"><span class="comment">//还可以通过传入表单DOM对象来创建FormData实例</span></span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'form'</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData(form);</span><br><span class="line">data.append(<span class="string">"password"</span>, <span class="string">"123456"</span>);</span><br><span class="line">xhr.send(data);</span><br></pre></td></tr></table></figure>
<p>目前, 主流浏览器基本上都支持XHR2, 除了IE系列需要IE10及更高版本. 因此IE10以下是不支持XHR2的</p>
<h3 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h3><p>JS中的http缓存没有开关, 受制于浏览器http缓存策略. 原生xhr请求中, 可通过如下设置关闭缓存</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">"If-Modified-Since"</span>,<span class="string">"0"</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Cache-Control"</span>,<span class="string">"no-cache"</span>);</span><br><span class="line"><span class="comment">//或者 URL 参数后加上  "?timestamp=" + new Date().getTime()</span></span><br></pre></td></tr></table></figure>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>HTML网页的<code>&lt;form&gt;</code>元素能够以四种格式，向服务器发送数据</p>
<ul>
<li>使用<code>POST</code>方法，将<code>enctype</code>属性设为<code>application/x-www-form-urlencoded</code>，这是默认方法</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"register.php"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">onsubmit</span>=<span class="string">"AJAXSubmit(this); return false;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>POST</code>方法，将<code>enctype</code>属性设为<code>text/plain</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"register.php"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"text/plain"</span> <span class="attr">onsubmit</span>=<span class="string">"AJAXSubmit(this); return false;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>POST</code>方法，将<code>enctype</code>属性设为<code>multipart/form-data</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"register.php"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span> <span class="attr">onsubmit</span>=<span class="string">"AJAXSubmit(this); return false;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>GET</code>方法，<code>enctype</code>属性将被忽略</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"register.php"</span> <span class="attr">method</span>=<span class="string">"get"</span> <span class="attr">onsubmit</span>=<span class="string">"AJAXSubmit(this); return false;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>某个表单有两个字段，分别是<code>foo</code>和<code>baz</code>，其中<code>foo</code>字段的值等于<code>bar</code>，<code>baz</code>字段的值一个分为两行的字符串。上面四种方法，都可以将这个表单发送到服务器</p>
<p>第一种方法是默认方法，POST发送，Encoding type为application/x-www-form-urlencoded</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">foo=bar&amp;baz=The+first+line.&amp;#37;0D%0AThe+second+line.%0D%0A</span><br></pre></td></tr></table></figure>
<p>第二种方法是POST发送，Encoding type为text/plain</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">foo=bar</span><br><span class="line">baz=The first line.</span><br><span class="line">The second line.</span><br></pre></td></tr></table></figure>
<p>第三种方法是POST发送，Encoding type为multipart/form-data</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=---------------------------314911788813839</span><br><span class="line"></span><br><span class="line">-----------------------------314911788813839</span><br><span class="line">Content-Disposition: form-data; name=&quot;foo&quot;</span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line">-----------------------------314911788813839</span><br><span class="line">Content-Disposition: form-data; name=&quot;baz&quot;</span><br><span class="line"></span><br><span class="line">The first line.</span><br><span class="line">The second line.</span><br><span class="line"></span><br><span class="line">-----------------------------314911788813839--</span><br></pre></td></tr></table></figure>
<p>第四种方法是GET请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?foo=bar&amp;baz=The%20first%20line.%0AThe%20second%20line.</span><br></pre></td></tr></table></figure>
<p>通常，使用file控件实现文件上传</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"file-form"</span> <span class="attr">action</span>=<span class="string">"handler.php"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file-select"</span> <span class="attr">name</span>=<span class="string">"photos[]"</span> <span class="attr">multiple</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">id</span>=<span class="string">"upload-button"</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面HTML代码中，file控件的multiple属性，指定可以一次选择多个文件；如果没有这个属性，则一次只能选择一个文件</p>
<p>file对象的files属性，返回一个FileList对象，包含了用户选中的文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fileSelect = <span class="built_in">document</span>.getElementById(<span class="string">'file-select'</span>);</span><br><span class="line"><span class="keyword">var</span> files = fileSelect.files;</span><br></pre></td></tr></table></figure>
<p>然后，新建一个FormData对象的实例，用来模拟发送到服务器的表单数据，把选中的文件添加到这个对象上面</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> file = files[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!file.type.match(<span class="string">'image.*'</span>)) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  formData.append(<span class="string">'photos[]'</span>, file, file.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中的FormData对象的append方法，除了可以添加文件，还可以添加二进制对象（Blob）或者字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Files</span></span><br><span class="line">formData.append(name, file, filename);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Blobs</span></span><br><span class="line">formData.append(name, blob, filename);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Strings</span></span><br><span class="line">formData.append(name, value);</span><br></pre></td></tr></table></figure>
<p>append方法的第一个参数是表单的控件名，第二个参数是实际的值，第三个参数是可选的，通常是文件名。</p>
<p>最后，使用Ajax方法向服务器上传文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'POST'</span>, <span class="string">'handler.php'</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.status !== <span class="number">200</span>) &#123;</span><br><span class="line">    alert(<span class="string">'An error occurred!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send(formData);</span><br></pre></td></tr></table></figure>
<p>目前，各大浏览器（包括IE 10）都支持Ajax上传文件</p>
<p>除了使用FormData接口上传，也可以直接使用File API上传</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span>.getElementById(<span class="string">'test-input'</span>).files[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'POST'</span>, <span class="string">'myserver/uploads'</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>, file.type);</span><br><span class="line">xhr.send(file);</span><br></pre></td></tr></table></figure>
<p>可以看到，上面这种写法比FormData的写法，要简单很多</p>
<h3 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>Ajax操作所用的<code>XMLHttpRequest</code>对象，已经有十多年的历史，它的API设计并不是很好，输入、输出、状态都在同一个接口管理，容易写出非常混乱的代码。Fetch API是一种新规范，用来取代<code>XMLHttpRequest</code>对象。它主要有两个特点，一是接口合理化，Ajax是将所有不同性质的接口都放在XHR对象上，而Fetch是将它们分散在几个不同的对象上，设计更合理；二是Fetch操作返回<code>Promise</code>对象，避免了嵌套的回调函数</p>
<p>下面的代码检查浏览器是否部署了Fetch API</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">"fetch"</span> <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</span><br><span class="line">  <span class="comment">// 支持</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 不支持</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个Fetch API的简单例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">jsonData</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(jsonData);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码向指定的URL发出请求，得到回应后，将其转为JSON格式，输出到控制台。如果出错，则输出一条提示信息。注意，<code>fetch</code>方法返回的是一个Promise对象</p>
<p>作为比较，<code>XMLHttpRequest</code>的写法如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, url);</span><br><span class="line">xhr.responseType = <span class="string">'json'</span>;</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(xhr.response);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<h4 id="stream数据流"><a href="#stream数据流" class="headerlink" title="stream数据流"></a>stream数据流</h4><p>Fetch API最大的特点是，除了返回<code>Promise</code>对象，还有一点就是数据传送是以数据流（stream）的形式进行的。对于大文件，数据是一段一段得到的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.text().then(<span class="function"><span class="keyword">function</span> (<span class="params">responseText</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(responseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中的<code>text()</code>，其实就是一个数据流读取器，并使用指定格式解读</p>
<p>Fetch API提供以下五个数据流读取器</p>
<ul>
<li><code>.text()</code>：返回字符串</li>
<li><code>.json()</code>：返回一个JSON对象</li>
<li><code>.formData()</code>：返回一个<code>FormData</code>对象</li>
<li><code>.blob()</code>：返回一个<code>blob</code>对象</li>
<li><code>.arrayBuffer()</code>：返回一个二进制数组</li>
</ul>
<p>数据流只能读取一次，一旦读取，数据流就空了。再次读取就不会得到结果。解决方法是在读取之前，先使用<code>.clone()</code>方法，复制一份一模一样的副本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'LargeFile.txt'</span>;</span><br><span class="line"><span class="keyword">var</span> progress = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> contentLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 本次请求总的数据长度</span></span><br><span class="line">  contentLength = response.headers.get(<span class="string">'Content-Length'</span>);</span><br><span class="line">  <span class="keyword">var</span> getStream = <span class="function"><span class="keyword">function</span> (<span class="params">reader</span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> getStream(response.body.getReader());</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>response.body.getReader()</code>返回的就是数据流之中的一段。处理数据流的<code>getStream</code>函数代码如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> progress = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> contentLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getStream = <span class="function"><span class="keyword">function</span> (<span class="params">reader</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> reader.read().then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果数据已经读取完毕，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (result.done) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出本段数据（二进制格式）</span></span><br><span class="line">    <span class="keyword">var</span> chunk = result.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> text = <span class="string">''</span>;</span><br><span class="line">    <span class="comment">// 假定数据是UTF-8编码，前三字节是数据头，</span></span><br><span class="line">    <span class="comment">// 而且每个字符占据一个字节（即都为英文字符）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">3</span>; i &lt; chunk.byteLength; i++) &#123;</span><br><span class="line">      text += <span class="built_in">String</span>.fromCharCode(chunk[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将本段数据追加到网页之中</span></span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>).innerHTML += text;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算当前进度</span></span><br><span class="line">    progress += chunk.byteLength;</span><br><span class="line">    <span class="built_in">console</span>.log(((progress / contentLength) * <span class="number">100</span>) + <span class="string">'%'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归处理下一段数据</span></span><br><span class="line">    <span class="keyword">return</span> getStream(reader);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这样的数据流处理，可以提高网站性能表现，减少内存占用，对于请求大文件或者网速慢的场景相当有用。传统的<code>XMLHTTPRequest</code>对象不支持数据流，所有的数据必须放在缓存里，等到全部拿到后，再一次性吐出来</p>
<h4 id="fetch"><a href="#fetch" class="headerlink" title="fetch()"></a>fetch()</h4><p><code>fetch</code>方法的第一个参数可以是URL字符串，也可以是后文要讲到的<code>Request</code>对象实例。<code>Fetch</code>方法返回一个<code>Promise</code>对象，并将一个<code>response</code>对象传给回调函数</p>
<p><code>response</code>对象有一个<code>ok</code>属性，如果返回的状态码在200到299之间（即请求成功），这个属性为<code>true</code>，否则为<code>false</code>。因此，判断请求是否成功的代码可以写成下面这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'./api/some.json'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (response.ok) &#123;</span><br><span class="line">    response.json().then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'请求失败，状态码为'</span>, response.status);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'出错：'</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>response</code>对象除了<code>json</code>方法，还包含了服务器HTTP回应的元数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'users.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response.headers.get(<span class="string">'Content-Type'</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(response.headers.get(<span class="string">'Date'</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(response.status);</span><br><span class="line">  <span class="built_in">console</span>.log(response.statusText);</span><br><span class="line">  <span class="built_in">console</span>.log(response.type);</span><br><span class="line">  <span class="built_in">console</span>.log(response.url);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>response</code>对象有很多属性，其中的<code>response.type</code>属性比较特别，表示HTTP回应的类型，它有以下三个值</p>
<ul>
<li>basic：正常的同域请求</li>
<li>cors：CORS机制下的跨域请求</li>
<li>opaque：非CORS机制下的跨域请求，这时无法读取返回的数据，也无法判断是否请求成功</li>
</ul>
<p>如果需要在CORS机制下发出跨域请求，需要指明状态</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'http://some-site.com/cors-enabled/some.json'</span>, &#123;<span class="attr">mode</span>: <span class="string">'cors'</span>&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> response.text();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request successful'</span>, text);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    log(<span class="string">'Request failed'</span>, error)</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>除了指定模式，fetch方法的第二个参数还可以用来配置其他值，比如指定cookie连同HTTP请求一起发出</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(url, &#123;</span><br><span class="line">  credentials: <span class="string">'include'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>发出POST请求的写法如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">"http://www.example.org/submit.php"</span>, &#123;</span><br><span class="line">  method: <span class="string">"POST"</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">"Content-Type"</span>: <span class="string">"application/x-www-form-urlencoded"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="string">"firstName=Nikhil&amp;favColor=blue&amp;password=easytoguess"</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (res.ok) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Perfect! Your settings are saved."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.status == <span class="number">401</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Oops! You are not authorized."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Error submitting form!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>目前，还有一些<code>XMLHttpRequest</code>对象可以做到，但是Fetch API还没做到的地方，比如中途中断HTTP请求，以及获取HTTP请求的进度。这些不足与Fetch返回的是Promise对象有关</p>
<h4 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h4><p>Fetch API引入三个新的对象（也是构造函数）：<code>Headers</code>, <code>Request</code>和<code>Response</code>。其中，<code>Headers</code>对象用来构造/读取HTTP数据包的头信息</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> content = <span class="string">'Hello World'</span>;</span><br><span class="line"><span class="keyword">var</span> headers = <span class="keyword">new</span> Headers();</span><br><span class="line">headers.append(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">headers.append(<span class="string">"Content-Type"</span>, <span class="string">"text/plain"</span>);</span><br><span class="line">headers.append(<span class="string">"Content-Length"</span>, content.length.toString());</span><br><span class="line">headers.append(<span class="string">"X-Custom-Header"</span>, <span class="string">"ProcessThisImmediately"</span>);</span><br></pre></td></tr></table></figure>
<p><code>Headers</code>对象的实例，除了使用<code>append</code>方法添加属性，也可以直接通过构造函数一次性生成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reqHeaders = <span class="keyword">new</span> Headers(&#123;</span><br><span class="line">  <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">"Content-Length"</span>: content.length.toString(),</span><br><span class="line">  <span class="string">"X-Custom-Header"</span>: <span class="string">"ProcessThisImmediately"</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Headers对象实例还提供了一些工具方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">reqHeaders.has(<span class="string">"Content-Type"</span>) <span class="comment">// true</span></span><br><span class="line">reqHeaders.has(<span class="string">"Set-Cookie"</span>) <span class="comment">// false</span></span><br><span class="line">reqHeaders.set(<span class="string">"Content-Type"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">reqHeaders.append(<span class="string">"X-Custom-Header"</span>, <span class="string">"AnotherValue"</span>)</span><br><span class="line"></span><br><span class="line">reqHeaders.get(<span class="string">"Content-Length"</span>) <span class="comment">// 11</span></span><br><span class="line">reqHeaders.getAll(<span class="string">"X-Custom-Header"</span>) <span class="comment">// ["ProcessThisImmediately", "AnotherValue"]</span></span><br><span class="line"></span><br><span class="line">reqHeaders.delete(<span class="string">"X-Custom-Header"</span>)</span><br><span class="line">reqHeaders.getAll(<span class="string">"X-Custom-Header"</span>) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>生成Header实例以后，可以将它作为第二个参数，传入Request方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> headers = <span class="keyword">new</span> Headers();</span><br><span class="line">headers.append(<span class="string">'Accept'</span>, <span class="string">'application/json'</span>);</span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> Request(URL, &#123;<span class="attr">headers</span>: headers&#125;);</span><br><span class="line"></span><br><span class="line">fetch(request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response.headers);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>同样地，Headers实例可以用来构造Response方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> headers = <span class="keyword">new</span> Headers(&#123;</span><br><span class="line">  <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">  <span class="string">'Cache-Control'</span>: <span class="string">'max-age=3600'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">new</span> Response(</span><br><span class="line">  <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">photos</span>: &#123;<span class="attr">photo</span>: []&#125;&#125;),</span><br><span class="line">  &#123;<span class="string">'status'</span>: <span class="number">200</span>, <span class="attr">headers</span>: headers&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">response.json().then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  insertPhotos(json);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，构造了一个HTTP回应。目前，浏览器构造HTTP回应没有太大用处，但是随着Service Worker的部署，不久浏览器就可以向Service Worker发出HTTP回应</p>
<h4 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h4><p>Request对象用来构造HTTP请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> Request(<span class="string">"/index.html"</span>);</span><br><span class="line">req.method <span class="comment">// "GET"</span></span><br><span class="line">req.url <span class="comment">// "http://example.com/index.html"</span></span><br></pre></td></tr></table></figure>
<p>Request对象的第二个参数，表示配置对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uploadReq = <span class="keyword">new</span> Request(<span class="string">"/uploadImage"</span>, &#123;</span><br><span class="line">  method: <span class="string">"POST"</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">"Content-Type"</span>: <span class="string">"image/png"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="string">"image data"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码指定Request对象使用POST方法发出，并指定HTTP头信息和信息体</p>
<p>下面是另一个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> Request(URL, &#123;<span class="attr">method</span>: <span class="string">'GET'</span>, <span class="attr">cache</span>: <span class="string">'reload'</span>&#125;);</span><br><span class="line">fetch(req).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  someOperator(json);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，指定请求方法为GET，并且要求浏览器不得缓存response</p>
<p>Request对象实例有两个属性是只读的，不能手动设置。一个是referrer属性，表示请求的来源，由浏览器设置，有可能是空字符串。另一个是context属性，表示请求发出的上下文，如果是image，表示是从img标签发出，如果是worker，表示是从worker脚本发出，如果是fetch，表示是从fetch函数发出的</p>
<p>Request对象实例的mode属性，用来设置是否跨域，合法的值有以下三种：same-origin、no-cors（默认值）、cors。当设置为same-origin时，只能向同域的URL发出请求，否则会报错</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arbitraryUrl = <span class="built_in">document</span>.getElementById(<span class="string">"url-input"</span>).value;</span><br><span class="line">fetch(arbitraryUrl, &#123; <span class="attr">mode</span>: <span class="string">"same-origin"</span> &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Response succeeded?"</span>, res.ok);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Please enter a same-origin URL!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果用户输入的URL不是同域的，将会报错，否则就会发出请求</p>
<p>如果mode属性为no-cors，就与默认的浏览器行为没有不同，类似script标签加载外部脚本文件、img标签加载外部图片。如果mode属性为cors，就可以向部署了CORS机制的服务器，发出跨域请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> u = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">u.append(<span class="string">'method'</span>, <span class="string">'flickr.interestingness.getList'</span>);</span><br><span class="line">u.append(<span class="string">'api_key'</span>, <span class="string">'&lt;insert api key here&gt;'</span>);</span><br><span class="line">u.append(<span class="string">'format'</span>, <span class="string">'json'</span>);</span><br><span class="line">u.append(<span class="string">'nojsoncallback'</span>, <span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> apiCall = fetch(<span class="string">'https://api.flickr.com/services/rest?'</span> + u);</span><br><span class="line"></span><br><span class="line">apiCall.then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response.json().then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// photo is a list of photos.</span></span><br><span class="line">    <span class="keyword">return</span> json.photos.photo;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">photos</span>) </span>&#123;</span><br><span class="line">  photos.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">photo</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(photo.title);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码是向Flickr API发出图片请求的例子</p>
<p>Request对象的一个很有用的功能，是在其他Request实例的基础上，生成新的Request实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> postReq = <span class="keyword">new</span> Request(req, &#123;<span class="attr">method</span>: <span class="string">'POST'</span>&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h4><p>fetch方法返回Response对象实例，它有以下属性：</p>
<ul>
<li><code>status</code>：整数值，表示状态码（比如200）</li>
<li>statusText：字符串，表示状态信息，默认是“OK”</li>
<li>ok：布尔值，表示状态码是否在200-299的范围内</li>
<li>headers：Headers对象，表示HTTP回应的头信息</li>
<li>url：字符串，表示HTTP请求的网址</li>
<li>type：字符串，合法的值有五个basic、cors、default、error、opaque。basic表示正常的同域请求；cors表示CORS机制的跨域请求；error表示网络出错，无法取得信息，status属性为0，headers属性为空，并且导致fetch函数返回Promise对象被拒绝；opaque表示非CORS机制的跨域请求，受到严格限制</li>
</ul>
<p>Response对象还有两个静态方法：</p>
<ul>
<li>Response.error() 返回一个type属性为error的Response对象实例</li>
<li>Response.redirect(url, status) 返回的Response对象实例会重定向到另一个URL</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">"https://example.com"</span>, init)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line"><span class="comment">// Check that the response is a 200</span></span><br><span class="line">  <span class="keyword">if</span> (response.status === <span class="number">200</span>) &#123;</span><br><span class="line">    alert(<span class="string">"Content type: "</span> + response.headers.get(<span class="string">'Content-Type'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="body"><a href="#body" class="headerlink" title="body"></a>body</h4><p>Request对象和Response对象都有body属性，表示请求的内容。body属性可能是以下的数据类型</p>
<ul>
<li>ArrayBuffer</li>
<li>ArrayBufferView (Uint8Array等)</li>
<li>Blob/File</li>
<li>string</li>
<li>URLSearchParams</li>
<li>FormData</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.getElementById(<span class="string">'login-form'</span>));</span><br><span class="line">fetch(<span class="string">"/login"</span>, &#123;</span><br><span class="line">  method: <span class="string">"POST"</span>,</span><br><span class="line">  body: form</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面代码中，Request对象的body属性为表单数据</p>
<p>Request对象和Response对象都提供以下方法，用来读取body：</p>
<ul>
<li>arrayBuffer()</li>
<li>blob()</li>
<li>json()</li>
<li>text()</li>
<li>formData()</li>
</ul>
<p>注意，上面这些方法都只能使用一次，第二次使用就会报错，也就是说，body属性只能读取一次。Request对象和Response对象都有bodyUsed属性，返回一个布尔值，表示body是否被读取过</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="keyword">new</span> Response(<span class="string">"one time use"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res.bodyUsed); <span class="comment">// false</span></span><br><span class="line">res.text().then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res.bodyUsed); <span class="comment">// true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res.bodyUsed); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">res.text().catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Tried to read already consumed Response"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，第二次通过text方法读取Response对象实例的body时，就会报错</p>
<p>这是因为body属性是一个stream对象，数据只能单向传送一次。这样的设计是为了允许JavaScript处理视频、音频这样的大型文件</p>
<p>如果希望多次使用body属性，可以使用Response对象和Request对象的clone方法。它必须在body还没有读取前调用，返回一个新的body，也就是说，需要使用几次body，就要调用几次clone方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sheep = <span class="keyword">new</span> Response(<span class="string">"Dolly"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(sheep.bodyUsed); <span class="comment">// false</span></span><br><span class="line">  <span class="keyword">var</span> clone = sheep.clone();</span><br><span class="line">  <span class="built_in">console</span>.log(clone.bodyUsed); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">  clone.text();</span><br><span class="line">  <span class="built_in">console</span>.log(sheep.bodyUsed); <span class="comment">// false</span></span><br><span class="line">  <span class="built_in">console</span>.log(clone.bodyUsed); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  evt.respondWith(cache.add(sheep.clone()).then(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sheep;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象，简单理解跨域就是因为JavaScript同源策略的限制，a.com域名下的js无法操作b.com域名下的对象</p>
<ul>
<li><p>一个域名地址的组成：</p>
<p><code>http://</code>       <code>user:password@</code>       <code>www</code>    .    <code>abc.com</code>    :    <code>8080</code>     /     <code>scripts/jquery.js</code>              </p>
<p>   协议                                               子域名         主域名           端口号                请求资源地址</p>
</li>
</ul>
<p>  <code>?user=bowen&amp;password=123456</code>      <code>#hash</code></p>
<p>​                 查询字符串                                 哈希</p>
<ul>
<li><p>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域</p>
</li>
<li><p>不用域之间相互请求资源，就算作跨域</p>
<p>比如：<a href="http://www.abc.com/index.html" target="_blank" rel="noopener">http://www.abc.com/index.html</a>  请求  <a href="http://www.efg.com/service.php" target="_blank" rel="noopener">http://www.efg.com/service.php</a></p>
</li>
</ul>
<h2 id="处理跨域的方法"><a href="#处理跨域的方法" class="headerlink" title="处理跨域的方法"></a>处理跨域的方法</h2><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><ul>
<li>通过在同域名的web服务器端创建一个代理</li>
<li>如北京服务器（域名：<a href="http://www.beijing.com）" target="_blank" rel="noopener">www.beijing.com）</a><pre><code>上海服务器（域名：www.shanghai.com）
</code></pre></li>
<li>通过北京的web服务器的后台来调用上海服务器的服务，再把响应结果返回给前端，这样前端的调用北京域名的服务就和调用上海的服务效果相同了</li>
</ul>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP全称 JSON with Padding，是用于解决AJAX跨域问题的一种方案</p>
<p>由于同源策略的限制，浏览器只允许XmlHttpRequest请求当前源（域名、协议、端口）的资源。由于在页面上有三种资源是可以与页面本身不同源的。它们是：js脚本，css样式文件，图片。因此可以通过请求script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，这种跨域的数据的方式被称为JSONP</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>1.首先在客户端注册一个callback方法，放到window对象上，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">callbackFunction (json) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后把callback的名字（callbackFunction）传给服务器</p>
<p>2.服务器先生成 JSON 数据</p>
<p>3.将 JSON 数据直接以入参的方式，放置到 function 中，这样就生成了一段 js 语法的文档（如callbackFunction(JSON)），返回给客户端</p>
<p>4.客户端浏览器，将返回的JS标签插入DOM，解析script标签后，会执行callbackFunction(JSON)。</p>
<p>通过这种方式，即可实现跨域获取数据</p>
<h4 id="jsonp封装"><a href="#jsonp封装" class="headerlink" title="jsonp封装"></a>jsonp封装</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; JSONP &#125; <span class="keyword">from</span> <span class="string">'./JSONP'</span></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">JSONP(&#123;</span><br><span class="line">  url: <span class="string">'url'</span>,</span><br><span class="line">  data: &#123;  </span><br><span class="line">    key1: <span class="string">'key1'</span>  </span><br><span class="line">  &#125;,  </span><br><span class="line">  callback (data) &#123;  </span><br><span class="line">    <span class="comment">// data 是服务端返回的数据  </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// JSONP.js</span></span><br><span class="line"><span class="keyword">let</span> JSONP = <span class="function">(<span class="params">config = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; data, url, callback &#125; = config</span><br><span class="line">  <span class="comment">// 拼接请求Url</span></span><br><span class="line">  <span class="keyword">if</span> (!url) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'url is required!'</span>)</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">`id_<span class="subst">$&#123;(<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()&#125;</span>_<span class="subst">$&#123;<span class="built_in">Math</span>.random().toString().substr(<span class="number">2</span>)&#125;</span>`</span></span><br><span class="line">  <span class="keyword">let</span> srcUrl = getSrcUrl(url, &#123;</span><br><span class="line">    data,</span><br><span class="line">    callback: name</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 插入Script标签</span></span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  script.type = <span class="string">'text/javascript'</span></span><br><span class="line">  script.src = srcUrl</span><br><span class="line">  script.id = name</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CallBack 放到 window 对象，调用后销毁</span></span><br><span class="line">  <span class="built_in">window</span>[name] = <span class="function"><span class="keyword">function</span> (<span class="params">json</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 执行这个函数后，要销毁这个函数</span></span><br><span class="line">    <span class="built_in">window</span>[name] = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">// 获取这个script的元素</span></span><br><span class="line">    <span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(name)</span><br><span class="line">    <span class="comment">// 删除head里面插入的script，这三步都是为了不影响污染整个DOM啊</span></span><br><span class="line">    removeElem(elem)</span><br><span class="line">    <span class="comment">// 执行传入的的函数</span></span><br><span class="line">    callback &amp;&amp; <span class="keyword">typeof</span> callback === <span class="string">'function'</span> &amp;&amp; callback(json)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)</span><br><span class="line">  <span class="keyword">if</span> (head &amp;&amp; head[<span class="number">0</span>]) &#123;</span><br><span class="line">    head[<span class="number">0</span>].appendChild(script)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getSrcUrl = <span class="function">(<span class="params">url, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> _url = url + (url.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span> ? <span class="string">'?'</span> : <span class="string">'&amp;'</span>)</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="string">''</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">'string'</span>) &#123;</span><br><span class="line">    ret = data</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">      ret += <span class="string">'&amp;'</span> + key + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(data[key])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ret = ret.substr(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> _url + ret</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> removeElem = <span class="function">(<span class="params">elem</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> parent = elem.parentNode</span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; parent.nodeType !== <span class="number">11</span>) &#123;</span><br><span class="line">    parent.removeChild(elem)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> JSONP</span><br></pre></td></tr></table></figure>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>在 jquery 中，JSOP 被封装在 <code>$.ajax()</code> 方法中，但是他的实现原理与 <code>ajax</code> 完全不同</li>
<li>JSONP的兼容性较好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持。</li>
<li>JSONP只支持GET请求而不支持POST等其它类型的HTTP请求</li>
<li>JSONP在调用失败的时候不会返回各种HTTP状态码（解决方法：添加timeout参数，虽然JSONP请求本身的错误没有被捕获，但是最终会因为超时而执行error回调）</li>
<li>在使用JSONP的时候必须要保证使用的JSONP服务必须是安全可信的。万一提供JSONP的服务存在页面注入漏洞，它返回的javascript都将被执行，若被注入这是非常危险的</li>
</ul>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p><code>CORS</code>需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉</p>
<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信</p>
<h4 id="两种请求"><a href="#两种请求" class="headerlink" title="两种请求"></a>两种请求</h4><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）</p>
<p>只要同时满足以下两大条件，就属于简单请求</p>
<p>（1）请求方法是以下三种方法之一</p>
<blockquote>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
</blockquote>
<p>（2）HTTP的头信息不超出以下几种字段</p>
<blockquote>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
</blockquote>
<p>凡是不同时满足上面两个条件，就属于非简单请求</p>
<p>浏览器对这两种请求的处理，是不一样的</p>
<h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><h5 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h5><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段</p>
<p>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>
<p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求</p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200</p>
<p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
<p>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头</p>
<p><strong>（1）Access-Control-Allow-Origin</strong></p>
<p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求</p>
<p><strong>（2）Access-Control-Allow-Credentials</strong></p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可</p>
<p><strong>（3）Access-Control-Expose-Headers</strong></p>
<p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值</p>
<h5 id="withCredentials-属性"><a href="#withCredentials-属性" class="headerlink" title="withCredentials 属性"></a>withCredentials 属性</h5><p>上面说到，CORS请求默认不包含Cookie信息（以及HTTP认证信息等）。如果需要包含Cookie信息，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>
<p>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p>
<p>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭<code>withCredentials</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie</p>
<h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><h5 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h5><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code></p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为“预检”请求（preflight）</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错</p>
<p>下面是一段浏览器的JavaScript脚本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'http://api.alice.com/cors'</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'PUT'</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'X-Custom-Header'</span>, <span class="string">'value'</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<p>上面代码中，HTTP请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code></p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个“预检”请求，要求服务器确认可以这样请求。下面是这个“预检”请求的HTTP头信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>
<p>“预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源</p>
<p>除了<code>Origin</code>字段，“预检”请求的头信息包括两个特殊字段</p>
<p><strong>（1）Access-Control-Request-Method</strong></p>
<p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<code>PUT</code></p>
<p><strong>（2）Access-Control-Request-Headers</strong></p>
<p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</p>
<h5 id="预检请求的回应"><a href="#预检请求的回应" class="headerlink" title="预检请求的回应"></a>预检请求的回应</h5><p>服务器收到“预检”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">Server: Apache/2.0.61 (Unix)</span><br><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 0</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure>
<p>上面的HTTP回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure>
<p>如果服务器否定了“预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://api.alice.com.</span><br><span class="line">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</span><br></pre></td></tr></table></figure>
<p>服务器回应的其他CORS相关字段如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure>
<p><strong>（1）Access-Control-Allow-Methods</strong></p>
<p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次“预检”请求</p>
<p><strong>（2）Access-Control-Allow-Headers</strong></p>
<p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在“预检”中请求的字段</p>
<p><strong>（3）Access-Control-Allow-Credentials</strong></p>
<p>该字段与简单请求时的含义相同</p>
<p><strong>（4）Access-Control-Max-Age</strong></p>
<p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求</p>
<h5 id="浏览器的正常请求和回应"><a href="#浏览器的正常请求和回应" class="headerlink" title="浏览器的正常请求和回应"></a>浏览器的正常请求和回应</h5><p>一旦服务器通过了“预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段</p>
<p>下面是“预检”请求之后，浏览器的正常CORS请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">X-Custom-Header: value</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>
<p>上面头信息的<code>Origin</code>字段是浏览器自动添加的</p>
<p>下面是服务器正常的回应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
<p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的</p>
<h4 id="与JSONP的比较"><a href="#与JSONP的比较" class="headerlink" title="与JSONP的比较"></a>与JSONP的比较</h4><p>CORS与JSONP的使用目的相同，但是比JSONP更强大</p>
<p>JSONP只支持<code>GET</code>请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket 是一种网络通信协议。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。WebSocket 允许服务器端与客户端进行全双工（full-duplex）的通信。举例来说，HTTP 协议有点像发电子邮件，发出后必须等待对方回信；WebSocket 则是像打电话，服务器端和客户端可以同时向对方发送数据，它们之间存着一条持续打开的数据通道</p>
<p>其他特点包括：</p>
<p>（1）建立在 TCP 协议之上，服务器端的实现比较容易</p>
<p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器</p>
<p>（3）数据格式比较轻量，性能开销小，通信高效</p>
<p>（4）可以发送文本，也可以发送二进制数据</p>
<p>（5）没有同源限制，客户端可以与任意服务器通信，完全可以取代 Ajax</p>
<p>（6）协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>，对应 HTTPS 协议），服务器网址就是 URL</p>
<h4 id="WebSocket-握手"><a href="#WebSocket-握手" class="headerlink" title="WebSocket 握手"></a>WebSocket 握手</h4><p>浏览器发出的 WebSocket 握手请求类似于下面的样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Host: example.com</span><br><span class="line">Origin: null</span><br><span class="line">Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>
<p>上面的头信息之中，有一个 HTTP 头是<code>Upgrade</code>。HTTP1.1 协议规定，<code>Upgrade</code>表示将通信协议从<code>HTTP/1.1</code>转向该字段指定的协议。<code>Connection</code>字段表示浏览器通知服务器，如果可以的话，就升级到 WebSocket 协议。<code>Origin</code>字段用于提供请求发出的域名，供服务器验证是否许可的范围内（服务器也可以不验证）。<code>Sec-WebSocket-Key</code>则是用于握手协议的密钥，是 Base64 编码的16字节随机字符串</p>
<p>服务器的 WebSocket 回应如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=</span><br><span class="line">Sec-WebSocket-Origin: null</span><br><span class="line">Sec-WebSocket-Location: ws://example.com/</span><br></pre></td></tr></table></figure>
<p>上面代码中，服务器同样用<code>Connection</code>字段通知浏览器，需要改变协议。<code>Sec-WebSocket-Accept</code>字段是服务器在浏览器提供的<code>Sec-WebSocket-Key</code>字符串后面，添加“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”字符串，然后再取 SHA-1 的哈希值。浏览器将对这个值进行验证，以证明确实是目标服务器回应了 WebSocket 请求。<code>Sec-WebSocket-Location</code>字段表示进行通信的 WebSocket 网址</p>
<p>完成握手以后，WebSocket 协议就在 TCP 协议之上，开始传送数据</p>
<h4 id="客户端的简单示例"><a href="#客户端的简单示例" class="headerlink" title="客户端的简单示例"></a>客户端的简单示例</h4><p>WebSocket 的用法相当简单</p>
<p>下面是一个网页脚本的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'wss://echo.websocket.org'</span>);</span><br><span class="line"></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Connection open ...'</span>);</span><br><span class="line">  ws.send(<span class="string">'Hello WebSockets!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Received Message: '</span> + evt.data);</span><br><span class="line">  ws.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Connection closed.'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="客户端-API"><a href="#客户端-API" class="headerlink" title="客户端 API"></a>客户端 API</h4><p>浏览器对 WebSocket 协议的处理，无非就是三件事：</p>
<ul>
<li>建立连接和断开连接</li>
<li>发送数据和接收数据</li>
<li>处理错误</li>
</ul>
<h5 id="构造函数-WebSocket"><a href="#构造函数-WebSocket" class="headerlink" title="构造函数 WebSocket"></a>构造函数 WebSocket</h5><p><code>WebSocket</code>对象作为一个构造函数，用于新建<code>WebSocket</code>实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br></pre></td></tr></table></figure>
<p>执行上面语句之后，客户端就会与服务器进行连接。</p>
<h5 id="webSocket-readyState"><a href="#webSocket-readyState" class="headerlink" title="webSocket.readyState"></a>webSocket.readyState</h5><p><code>readyState</code>属性返回实例对象的当前状态，共有四种：</p>
<ul>
<li>CONNECTING：值为0，表示正在连接</li>
<li>OPEN：值为1，表示连接成功，可以通信了</li>
<li>CLOSING：值为2，表示连接正在关闭</li>
<li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败</li>
</ul>
<p>下面是一个示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ws.readyState) &#123;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CONNECTING:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.OPEN:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CLOSING:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CLOSED:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// this never happens</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="webSocket-onopen"><a href="#webSocket-onopen" class="headerlink" title="webSocket.onopen"></a>webSocket.onopen</h5><p>实例对象的<code>onopen</code>属性，用于指定连接成功后的回调函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要指定多个回调函数，可以使用<code>addEventListener</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.addEventListener(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="webSocket-onclose"><a href="#webSocket-onclose" class="headerlink" title="webSocket.onclose"></a>webSocket.onclose</h5><p>实例对象的<code>onclose</code>属性，用于指定连接关闭后的回调函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">"close"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="webSocket-onmessage"><a href="#webSocket-onmessage" class="headerlink" title="webSocket.onmessage"></a>webSocket.onmessage</h5><p>实例对象的<code>onmessage</code>属性，用于指定收到服务器数据后的回调函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意，服务器数据可能是文本，也可能是二进制数据（<code>blob</code>对象或<code>Arraybuffer</code>对象）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(typeOf event.data === <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received data string"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(event.data <span class="keyword">instanceof</span> <span class="built_in">ArrayBuffer</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = event.data;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received arraybuffer"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了动态判断收到的数据类型，也可以使用<code>binaryType</code>属性，显式指定收到的二进制数据类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收到的是 blob 数据</span></span><br><span class="line">ws.binaryType = <span class="string">"blob"</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到的是 ArrayBuffer 数据</span></span><br><span class="line">ws.binaryType = <span class="string">"arraybuffer"</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.byteLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="webSocket-send"><a href="#webSocket-send" class="headerlink" title="webSocket.send()"></a>webSocket.send()</h5><p>实例对象的<code>send()</code>方法用于向服务器发送数据</p>
<p>发送文本的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.send(<span class="string">'your message'</span>);</span><br></pre></td></tr></table></figure>
<p>发送 Blob 对象的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span></span><br><span class="line">  .querySelector(<span class="string">'input[type="file"]'</span>)</span><br><span class="line">  .files[<span class="number">0</span>];</span><br><span class="line">ws.send(file);</span><br></pre></td></tr></table></figure>
<p>发送 ArrayBuffer 对象的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sending canvas ImageData as ArrayBuffer</span></span><br><span class="line"><span class="keyword">var</span> img = canvas_context.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">320</span>);</span><br><span class="line"><span class="keyword">var</span> binary = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(img.data.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; img.data.length; i++) &#123;</span><br><span class="line">  binary[i] = img.data[i];</span><br><span class="line">&#125;</span><br><span class="line">ws.send(binary.buffer);</span><br></pre></td></tr></table></figure>
<h5 id="webSocket-bufferedAmount"><a href="#webSocket-bufferedAmount" class="headerlink" title="webSocket.bufferedAmount"></a>webSocket.bufferedAmount</h5><p>实例对象的<code>bufferedAmount</code>属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10000000</span>);</span><br><span class="line">socket.send(data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (socket.bufferedAmount === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 发送完毕</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 发送还没结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="webSocket-onerror"><a href="#webSocket-onerror" class="headerlink" title="webSocket.onerror"></a>webSocket.onerror</h5><p>实例对象的<code>onerror</code>属性，用于指定报错时的回调函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.addEventListener(<span class="string">"error"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="WebSocket-服务器"><a href="#WebSocket-服务器" class="headerlink" title="WebSocket 服务器"></a>WebSocket 服务器</h4><p>WebSocket 协议需要服务器支持</p>
<p>常用的 Node 实现有以下三种：</p>
<ul>
<li>µWebSockets</li>
<li>Socket.IO]</li>
<li>WebSocket-Node</li>
</ul>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">JavaScript</a>
        		</li>
      		
		</ul>
	</div>

      

      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 Bowen
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(e){if(r[e])return r[e].exports;var i=r[e]={exports:{},id:e,loaded:!1};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var r={};n.m=t,n.c=r,n.p="./",n(0)}([function(t,n,r){r(195),t.exports=r(191)},function(t,n,r){var e=r(3),i=r(52),o=r(27),u=r(28),c=r(53),f="prototype",a=function(t,n,r){var s,l,h,v,p=t&a.F,d=t&a.G,y=t&a.S,g=t&a.P,b=t&a.B,m=d?e:y?e[n]||(e[n]={}):(e[n]||{})[f],x=d?i:i[n]||(i[n]={}),w=x[f]||(x[f]={});d&&(r=n);for(s in r)l=!p&&m&&void 0!==m[s],h=(l?m:r)[s],v=b&&l?c(h,e):g&&"function"==typeof h?c(Function.call,h):h,m&&u(m,s,h,t&a.U),x[s]!=h&&o(x,s,v),g&&w[s]!=h&&(w[s]=h)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n,r){var e=r(6);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n,r){var e=r(126)("wks"),i=r(76),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(94),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(167),o=r(50),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(58),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(5).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(67),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){var e=r(46);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,r){var e=r(63),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(11),i=r(66);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(3),i=r(27),o=r(24),u=r(76)("src"),c="toString",f=Function[c],a=(""+f).split(c);r(52).inspectSource=function(t){return f.call(t)},(t.exports=function(t,n,r,c){var f="function"==typeof r;f&&(o(r,"name")||i(r,"name",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?""+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,c,function(){return"function"==typeof this&&this[u]||f.call(this)})},function(t,n,r){var e=r(1),i=r(4),o=r(46),u=function(t,n,r,e){var i=String(o(t)),u="<"+n;return""!==r&&(u+=" "+r+'="'+String(e).replace(/"/g,"&quot;")+'"'),u+">"+i+"</"+n+">"};t.exports=function(t,n){var r={};r[t]=n(u),e(e.P+e.F*i(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",r)}},function(t,n,r){var e=r(115),i=r(46);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(116),i=r(66),o=r(30),u=r(50),c=r(24),f=r(167),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(24),i=r(17),o=r(145)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(15)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(5),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(21);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(15)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var e=r(53),i=r(115),o=r(17),u=r(16),c=r(203);t.exports=function(t,n){var r=1==t,f=2==t,a=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),b=i(g),m=e(c,p,3),x=u(b.length),w=0,S=r?v(n,x):f?v(n,0):void 0;x>w;w++)if((h||w in b)&&(d=b[w],y=m(d,w,g),t))if(r)S[w]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return w;case 2:S.push(d)}else if(s)return!1;return l?-1:a||s?s:S}}},function(t,n,r){var e=r(1),i=r(52),o=r(4);t.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),"Object",u)}},function(t,n,r){var e=r(6);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(91),u=r(13),c="prototype",f=function(t,n,r){var a,s,l,h=t&f.F,v=t&f.G,p=t&f.S,d=t&f.P,y=t&f.B,g=t&f.W,b=v?i:i[n]||(i[n]={}),m=b[c],x=v?e:p?e[n]:(e[n]||{})[c];v&&(r=n);for(a in r)(s=!h&&x&&void 0!==x[a])&&a in b||(l=s?x[a]:r[a],b[a]=v&&"function"!=typeof x[a]?r[a]:y&&s?o(l,e):g&&x[a]==l?function(t){var n=function(n,r,e){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,r)}return new t(n,r,e)}return t.apply(this,arguments)};return n[c]=t[c],n}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((b.virtual||(b.virtual={}))[a]=l,t&f.R&&m&&!m[a]&&u(m,a,l)))};f.F=1,f.G=2,f.S=4,f.P=8,f.B=16,f.W=32,f.U=64,f.R=128,t.exports=f},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n,r){var e=r(26);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(183),i=r(1),o=r(126)("metadata"),u=o.store||(o.store=new(r(186))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o},f=function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},a=function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},s=function(t,n,r,e){c(r,e,!0).set(t,n)},l=function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},h=function(t){return void 0===t||"symbol"==typeof t?t:String(t)},v=function(t){i(i.S,"Reflect",t)};t.exports={store:u,map:c,has:f,get:a,set:s,keys:l,key:h,exp:v}},function(t,n,r){"use strict";if(r(10)){var e=r(69),i=r(3),o=r(4),u=r(1),c=r(127),f=r(152),a=r(53),s=r(68),l=r(66),h=r(27),v=r(73),p=r(67),d=r(16),y=r(75),g=r(50),b=r(24),m=r(180),x=r(114),w=r(6),S=r(17),_=r(137),O=r(70),E=r(32),P=r(71).f,j=r(154),F=r(76),M=r(7),A=r(48),N=r(117),T=r(146),I=r(155),k=r(80),L=r(123),R=r(74),C=r(130),D=r(160),U=r(11),W=r(31),G=U.f,B=W.f,V=i.RangeError,z=i.TypeError,q=i.Uint8Array,K="ArrayBuffer",J="Shared"+K,Y="BYTES_PER_ELEMENT",H="prototype",$=Array[H],X=f.ArrayBuffer,Q=f.DataView,Z=A(0),tt=A(2),nt=A(3),rt=A(4),et=A(5),it=A(6),ot=N(!0),ut=N(!1),ct=I.values,ft=I.keys,at=I.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,bt=M("iterator"),mt=M("toStringTag"),xt=F("typed_constructor"),wt=F("def_constructor"),St=c.CONSTR,_t=c.TYPED,Ot=c.VIEW,Et="Wrong length!",Pt=A(1,function(t,n){return Tt(T(t,t[wt]),n)}),jt=o(function(){return 1===new q(new Uint16Array([1]).buffer)[0]}),Ft=!!q&&!!q[H].set&&o(function(){new q(1).set({})}),Mt=function(t,n){if(void 0===t)throw z(Et);var r=+t,e=d(t);if(n&&!m(r,e))throw V(Et);return e},At=function(t,n){var r=p(t);if(r<0||r%n)throw V("Wrong offset!");return r},Nt=function(t){if(w(t)&&_t in t)return t;throw z(t+" is not a typed array!")},Tt=function(t,n){if(!(w(t)&&xt in t))throw z("It is not a typed array constructor!");return new t(n)},It=function(t,n){return kt(T(t,t[wt]),n)},kt=function(t,n){for(var r=0,e=n.length,i=Tt(t,e);e>r;)i[r]=n[r++];return i},Lt=function(t,n,r){G(t,n,{get:function(){return this._d[r]}})},Rt=function(t){var n,r,e,i,o,u,c=S(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=j(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=d(c.length),i=Tt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Ct=function(){for(var t=0,n=arguments.length,r=Tt(this,n);n>t;)r[t]=arguments[t++];return r},Dt=!!q&&o(function(){gt.call(new q(1))}),Ut=function(){return gt.apply(Dt?dt.call(Nt(this)):Nt(this),arguments)},Wt={copyWithin:function(t,n){return D.call(Nt(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return rt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return C.apply(Nt(this),arguments)},filter:function(t){return It(this,tt(Nt(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return et(Nt(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return it(Nt(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(Nt(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return ut(Nt(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return ot(Nt(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return vt.apply(Nt(this),arguments)},lastIndexOf:function(t){return st.apply(Nt(this),arguments)},map:function(t){return Pt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return lt.apply(Nt(this),arguments)},reduceRight:function(t){return ht.apply(Nt(this),arguments)},reverse:function(){for(var t,n=this,r=Nt(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pt.call(Nt(this),t)},subarray:function(t,n){var r=Nt(this),e=r.length,i=y(t,e);return new(T(r,r[wt]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:y(n,e))-i))}},Gt=function(t,n){return It(this,dt.call(Nt(this),t,n))},Bt=function(t){Nt(this);var n=At(arguments[1],1),r=this.length,e=S(t),i=d(e.length),o=0;if(i+n>r)throw V(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(Nt(this))},keys:function(){return ft.call(Nt(this))},values:function(){return ct.call(Nt(this))}},zt=function(t,n){return w(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return zt(t,n=g(n,!0))?l(2,t[n]):B(t,n)},Kt=function(t,n,r){return!(zt(t,n=g(n,!0))&&w(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?G(t,n,r):(t[n]=r.value,t)};St||(W.f=qt,U.f=Kt),u(u.S+u.F*!St,"Object",{getOwnPropertyDescriptor:qt,defineProperty:Kt}),o(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Jt=v({},Wt);v(Jt,Vt),h(Jt,bt,Vt.values),v(Jt,{slice:Gt,set:Bt,constructor:function(){},toString:yt,toLocaleString:Ut}),Lt(Jt,"buffer","b"),Lt(Jt,"byteOffset","o"),Lt(Jt,"byteLength","l"),Lt(Jt,"length","e"),G(Jt,mt,{get:function(){return this[_t]}}),t.exports=function(t,n,r,f){f=!!f;var a=t+(f?"Clamped":"")+"Array",l="Uint8Array"!=a,v="get"+t,p="set"+t,y=i[a],g=y||{},b=y&&E(y),m=!y||!c.ABV,S={},_=y&&y[H],j=function(t,r){var e=t._d;return e.v[v](r*n+e.o,jt)},F=function(t,r,e){var i=t._d;f&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[p](r*n+i.o,e,jt)},M=function(t,n){G(t,n,{get:function(){return j(this,n)},set:function(t){return F(this,n,t)},enumerable:!0})};m?(y=r(function(t,r,e,i){s(t,y,a,"_d");var o,u,c,f,l=0,v=0;if(w(r)){if(!(r instanceof X||(f=x(r))==K||f==J))return _t in r?kt(y,r):Rt.call(y,r);o=r,v=At(e,n);var p=r.byteLength;if(void 0===i){if(p%n)throw V(Et);if((u=p-v)<0)throw V(Et)}else if((u=d(i)*n)+v>p)throw V(Et);c=u/n}else c=Mt(r,!0),u=c*n,o=new X(u);for(h(t,"_d",{b:o,o:v,l:u,e:c,v:new Q(o)});l<c;)M(t,l++)}),_=y[H]=O(Jt),h(_,"constructor",y)):L(function(t){new y(null),new y(t)},!0)||(y=r(function(t,r,e,i){s(t,y,a);var o;return w(r)?r instanceof X||(o=x(r))==K||o==J?void 0!==i?new g(r,At(e,n),i):void 0!==e?new g(r,At(e,n)):new g(r):_t in r?kt(y,r):Rt.call(y,r):new g(Mt(r,l))}),Z(b!==Function.prototype?P(g).concat(P(b)):P(g),function(t){t in y||h(y,t,g[t])}),y[H]=_,e||(_.constructor=y));var A=_[bt],N=!!A&&("values"==A.name||void 0==A.name),T=Vt.values;h(y,xt,!0),h(_,_t,a),h(_,Ot,!0),h(_,wt,y),(f?new y(1)[mt]==a:mt in _)||G(_,mt,{get:function(){return a}}),S[a]=y,u(u.G+u.W+u.F*(y!=g),S),u(u.S,a,{BYTES_PER_ELEMENT:n,from:Rt,of:Ct}),Y in _||h(_,Y,n),u(u.P,a,Wt),R(a),u(u.P+u.F*Ft,a,{set:Bt}),u(u.P+u.F*!N,a,Vt),u(u.P+u.F*(_.toString!=yt),a,{toString:yt}),u(u.P+u.F*o(function(){new y(1).slice()}),a,{slice:Gt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new y([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),a,{toLocaleString:Ut}),k[a]=N?A:T,e||N||h(_,bt,T)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(5).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(57)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var e=r(36),i=r(51),o=r(64),u=r(13),c=r(8),f=r(35),a=r(96),s=r(38),l=r(103),h=r(15)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n,r){var e=r(20),i=r(100),o=r(34),u=r(39)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(57)("iframe"),e=o.length;for(n.style.display="none",r(93).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(63),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(8),i=r(9),o=r(90)(!1),u=r(39)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(76)("meta"),i=r(6),o=r(24),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n){t.exports=!1},function(t,n,r){var e=r(2),i=r(173),o=r(133),u=r(145)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(132)("iframe"),e=o.length;for(n.style.display="none",r(135).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(175),i=r(133).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(175),i=r(133);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(28);t.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(67),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;void 0==i[e]&&r(27)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(53),i=r(169),o=r(137),u=r(2),c=r(16),f=r(154),a={},s={},n=t.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:f(t),b=e(r,l,n?2:1),m=0;if("function"!=typeof g)throw TypeError(t+" is not iterable!");if(o(g)){for(v=c(t.length);v>m;m++)if((y=n?b(u(p=t[m])[0],p[1]):b(t[m]))===a||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,b,p.value,n))===a||y===s)return y};n.BREAK=a,n.RETURN=s},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(24),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(1),i=r(46),o=r(4),u=r(150),c="["+u+"]",f="​",a=RegExp("^"+c+c+"*"),s=RegExp(c+c+"*$"),l=function(t,n,r){var i={},c=o(function(){return!!u[t]()||f[t]()!=f}),a=i[t]=c?n(h):u[t];r&&(i[r]=a),e(e.P+e.F*c,"String",i)},h=l.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(a,"")),2&n&&(t=t.replace(s,"")),t};t.exports=l},function(t,n,r){t.exports={default:r(86),__esModule:!0}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=r(84),o=e(i),u=r(83),c=e(u),f="function"==typeof c.default&&"symbol"==typeof o.default?function(t){return typeof t}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":typeof t};n.default="function"==typeof c.default&&"symbol"===f(o.default)?function(t){return void 0===t?"undefined":f(t)}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":void 0===t?"undefined":f(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(25).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var e=r(9),i=r(106),o=r(105);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(88);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(19),i=r(62),o=r(37);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){t.exports=r(5).document&&document.documentElement},function(t,n,r){var e=r(56);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(56);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(60),i=r(22),o=r(38),u={};r(13)(u,r(15)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(19),i=r(9);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n,r){var e=r(14),i=r(20),o=r(19);t.exports=r(12)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(9),u=r(42),c=r(8),f=r(58),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(9),i=r(61).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(77),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(41),i=r(33);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(89),i=r(97),o=r(35),u=r(9);t.exports=r(59)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(59)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(5),i=r(8),o=r(12),u=r(51),c=r(64),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(15),p=r(44),d=r(43),y=r(98),g=r(92),b=r(95),m=r(20),x=r(9),w=r(42),S=r(22),_=r(60),O=r(102),E=r(101),P=r(14),j=r(19),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(61).f=O.f=Z,r(37).f=X,r(62).f=tt,o&&!r(36)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(13)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(5),i=r(13),o=r(35),u=r(15)("toStringTag"),c=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],f=0;f<5;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var e=r(45),i=r(7)("toStringTag"),o="Arguments"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=u(n=Object(t),i))?r:o?e(n):"Object"==(c=e(n))&&"function"==typeof n.callee?"Arguments":c}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(30),i=r(16),o=r(75);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){"use strict";var e=r(3),i=r(1),o=r(28),u=r(73),c=r(65),f=r(79),a=r(68),s=r(6),l=r(4),h=r(123),v=r(81),p=r(136);t.exports=function(t,n,r,d,y,g){var b=e[t],m=b,x=y?"set":"add",w=m&&m.prototype,S={},_=function(t){var n=w[t];o(w,t,"delete"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof m&&(g||w.forEach&&!l(function(){(new m).entries().next()}))){var O=new m,E=O[x](g?{}:-0,1)!=O,P=l(function(){O.has(1)}),j=h(function(t){new m(t)}),F=!g&&l(function(){for(var t=new m,n=5;n--;)t[x](n,n);return!t.has(-0)});j||(m=n(function(n,r){a(n,m,t);var e=p(new b,n,m);return void 0!=r&&f(r,y,e[x],e),e}),m.prototype=w,w.constructor=m),(P||F)&&(_("delete"),_("has"),y&&_("get")),(F||E)&&_(x),g&&w.clear&&delete w.clear}else m=d.getConstructor(n,t,y,x),u(m.prototype,r),c.NEED=!0;return v(m,t),S[t]=m,i(i.G+i.W+i.F*(m!=b),S),g||d.setStrong(m,t,y),m}},function(t,n,r){"use strict";var e=r(27),i=r(28),o=r(4),u=r(46),c=r(7);t.exports=function(t,n,r){var f=c(t),a=r(u,f,""[t]),s=a[0],l=a[1];o(function(){var n={};return n[f]=function(){return 7},7!=""[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,f,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}
},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(6),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var e=r(7)("iterator"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},function(t,n,r){t.exports=r(69)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){for(var e,i=r(3),o=r(27),u=r(76),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&-1==t.indexOf("KHTML"),mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:-1==t.indexOf("Safari"),weixin:-1==t.indexOf("MicroMessenger")}}()};t.exports=r},function(t,n,r){"use strict";var e=r(85),i=function(t){return t&&t.__esModule?t:{default:t}}(e),o=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):r[t]||t}function n(t){return e[t]}var r={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},e={};for(var u in r)e[r[u]]=u;return r["&apos;"]="'",e["'"]="&#39;",{encode:function(t){return t?(""+t).replace(/['<> "&]/g,n).replace(/\r?\n/g,"<br/>").replace(/\s/g,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(/<br\s*\/?>/gi,"\n").replace(/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,t).replace(/\u00a0/g," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;r>n;n++)t[n]=o.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,i.default)(t)))for(var e in t)t[e]=o.encodeObject(t[e]);else if("string"==typeof t)return o.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=o},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=function(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),f=u>2?arguments[2]:void 0,a=void 0===f?r:i(f,r);a>c;)n[c++]=t;return n}},function(t,n,r){"use strict";var e=r(11),i=r(66);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(6),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(r){try{return n[e]=!1,!"/./"[t](n)}catch(t){}}return!0}},function(t,n,r){t.exports=r(3).document&&document.documentElement},function(t,n,r){var e=r(6),i=r(144).set;t.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&"function"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(70),i=r(66),o=r(81),u={};r(27)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var e=r(69),i=r(1),o=r(28),u=r(27),c=r(24),f=r(80),a=r(139),s=r(81),l=r(32),h=r(7)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var e=r(3),i=r(151).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,f="process"==r(45)(u);t.exports=function(){var t,n,r,a=function(){var e,i;for(f&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(f)r=function(){u.nextTick(a)};else if(o){var s=!0,l=document.createTextNode("");new o(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(a)}}else r=function(){i.call(e,a)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},function(t,n,r){var e=r(6),i=r(2),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,e){try{e=r(53)(Function.call,r(31).f(Object.prototype,"__proto__").set,2),e(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return o(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(126)("keys"),i=r(76);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(2),i=r(26),o=r(7)("species");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},function(t,n,r){var e=r(67),i=r(46);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(122),i=r(46);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var e=r(67),i=r(46);t.exports=function(t){var n=String(i(this)),r="",o=e(t);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(53),c=r(121),f=r(135),a=r(132),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=0,y={},g="onreadystatechange",b=function(){var t=+this;if(y.hasOwnProperty(t)){var n=y[t];delete y[t],n()}},m=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return y[++d]=function(){c("function"==typeof t?t:Function(t),n)},e(d),d},v=function(t){delete y[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=g in a("script")?function(t){f.appendChild(a("script"))[g]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(69),u=r(127),c=r(27),f=r(73),a=r(4),s=r(68),l=r(67),h=r(16),v=r(71).f,p=r(11).f,d=r(130),y=r(81),g="ArrayBuffer",b="DataView",m="prototype",x="Wrong length!",w="Wrong index!",S=e[g],_=e[b],O=e.Math,E=e.RangeError,P=e.Infinity,j=S,F=O.abs,M=O.pow,A=O.floor,N=O.log,T=O.LN2,I="buffer",k="byteLength",L="byteOffset",R=i?"_b":I,C=i?"_l":k,D=i?"_o":L,U=function(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?M(2,-24)-M(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for(t=F(t),t!=t||t===P?(i=t!=t?1:0,e=f):(e=A(N(t)/T),t*(o=M(2,-e))<1&&(e--,o*=2),t+=e+a>=1?s/o:s*M(2,1-a),t*o>=2&&(e++,o/=2),e+a>=f?(i=0,e=f):e+a>=1?(i=(t*o-1)*M(2,n),e+=a):(i=t*M(2,a-1)*M(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u},W=function(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;c>0;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-P:P;e+=M(2,n),s-=u}return(a?-1:1)*e*M(2,s-n)},G=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},B=function(t){return[255&t]},V=function(t){return[255&t,t>>8&255]},z=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},q=function(t){return U(t,52,8)},K=function(t){return U(t,23,4)},J=function(t,n,r){p(t[m],n,{get:function(){return this[r]}})},Y=function(t,n,r,e){var i=+r,o=l(i);if(i!=o||o<0||o+n>t[C])throw E(w);var u=t[R]._b,c=o+t[D],f=u.slice(c,c+n);return e?f:f.reverse()},H=function(t,n,r,e,i,o){var u=+r,c=l(u);if(u!=c||c<0||c+n>t[C])throw E(w);for(var f=t[R]._b,a=c+t[D],s=e(+i),h=0;h<n;h++)f[a+h]=s[o?h:n-h-1]},$=function(t,n){s(t,S,g);var r=+n,e=h(r);if(r!=e)throw E(x);return e};if(u.ABV){if(!a(function(){new S})||!a(function(){new S(.5)})){S=function(t){return new j($(this,t))};for(var X,Q=S[m]=j[m],Z=v(j),tt=0;Z.length>tt;)(X=Z[tt++])in S||c(S,X,j[X]);o||(Q.constructor=S)}var nt=new _(new S(2)),rt=_[m].setInt8;nt.setInt8(0,2147483648),nt.setInt8(1,2147483649),!nt.getInt8(0)&&nt.getInt8(1)||f(_[m],{setInt8:function(t,n){rt.call(this,t,n<<24>>24)},setUint8:function(t,n){rt.call(this,t,n<<24>>24)}},!0)}else S=function(t){var n=$(this,t);this._b=d.call(Array(n),0),this[C]=n},_=function(t,n,r){s(this,_,b),s(t,S,b);var e=t[C],i=l(n);if(i<0||i>e)throw E("Wrong offset!");if(r=void 0===r?e-i:h(r),i+r>e)throw E(x);this[R]=t,this[D]=i,this[C]=r},i&&(J(S,k,"_l"),J(_,I,"_b"),J(_,k,"_l"),J(_,L,"_o")),f(_[m],{getInt8:function(t){return Y(this,1,t)[0]<<24>>24},getUint8:function(t){return Y(this,1,t)[0]},getInt16:function(t){var n=Y(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=Y(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return G(Y(this,4,t,arguments[1]))},getUint32:function(t){return G(Y(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return W(Y(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return W(Y(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){H(this,1,t,B,n)},setUint8:function(t,n){H(this,1,t,B,n)},setInt16:function(t,n){H(this,2,t,V,n,arguments[2])},setUint16:function(t,n){H(this,2,t,V,n,arguments[2])},setInt32:function(t,n){H(this,4,t,z,n,arguments[2])},setUint32:function(t,n){H(this,4,t,z,n,arguments[2])},setFloat32:function(t,n){H(this,4,t,K,n,arguments[2])},setFloat64:function(t,n){H(this,8,t,q,n,arguments[2])}});y(S,g),y(_,b),c(_[m],u.VIEW,!0),n[g]=S,n[b]=_},function(t,n,r){var e=r(3),i=r(52),o=r(69),u=r(182),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(52).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(78),i=r(170),o=r(80),u=r(30);t.exports=r(140)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){function r(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=r},function(t,n){function r(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}t.exports=r},function(t,n){function r(){throw new Error("setTimeout has not been defined")}function e(){throw new Error("clearTimeout has not been defined")}function i(t){if(s===setTimeout)return setTimeout(t,0);if((s===r||!s)&&setTimeout)return s=setTimeout,setTimeout(t,0);try{return s(t,0)}catch(n){try{return s.call(null,t,0)}catch(n){return s.call(this,t,0)}}}function o(t){if(l===clearTimeout)return clearTimeout(t);if((l===e||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(t);try{return l(t)}catch(n){try{return l.call(null,t)}catch(n){return l.call(this,t)}}}function u(){d&&v&&(d=!1,v.length?p=v.concat(p):y=-1,p.length&&c())}function c(){if(!d){var t=i(u);d=!0;for(var n=p.length;n;){for(v=p,p=[];++y<n;)v&&v[y].run();y=-1,n=p.length}v=null,d=!1,o(t)}}function f(t,n){this.fun=t,this.array=n}function a(){}var s,l,h=t.exports={};!function(){try{s="function"==typeof setTimeout?setTimeout:r}catch(t){s=r}try{l="function"==typeof clearTimeout?clearTimeout:e}catch(t){l=e}}();var v,p=[],d=!1,y=-1;h.nextTick=function(t){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];p.push(new f(t,n)),1!==p.length||d||i(c)},f.prototype.run=function(){this.fun.apply(null,this.array)},h.title="browser",h.browser=!0,h.env={},h.argv=[],h.version="",h.versions={},h.on=a,h.addListener=a,h.once=a,h.off=a,h.removeListener=a,h.removeAllListeners=a,h.emit=a,h.prependListener=a,h.prependOnceListener=a,h.listeners=function(t){return[]},h.binding=function(t){throw new Error("process.binding is not supported")},h.cwd=function(){return"/"},h.chdir=function(t){throw new Error("process.chdir is not supported")},h.umask=function(){return 0}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=[].copyWithin||function(t,n){var r=e(this),u=o(r.length),c=i(t,u),f=i(n,u),a=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===a?u:i(a,u))-f,u-c),l=1;for(f<c&&c<f+s&&(l=-1,f+=s-1,c+=s-1);s-- >0;)f in r?r[c]=r[f]:delete r[c],c+=l,f+=l;return r}},function(t,n,r){var e=r(79);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var e=r(26),i=r(17),o=r(115),u=r(16);t.exports=function(t,n,r,c,f){e(n);var a=i(t),s=o(a),l=u(a.length),h=f?l-1:0,v=f?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,f?h<0:l<=h)throw TypeError("Reduce of empty array with no initial value")}for(;f?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,a));return c}},function(t,n,r){"use strict";var e=r(26),i=r(6),o=r(121),u=[].slice,c={},f=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";c[n]=Function("F,a","return new F("+e.join(",")+")")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?f(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){"use strict";var e=r(11).f,i=r(70),o=r(73),u=r(53),c=r(68),f=r(46),a=r(79),s=r(140),l=r(170),h=r(74),v=r(10),p=r(65).fastKey,d=v?"_s":"size",y=function(t,n){var r,e=p(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,s){var l=t(function(t,e){c(t,l,n,"_i"),t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&a(e,r,t[s],t)});return o(l.prototype,{clear:function(){for(var t=this,n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=this,r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){c(this,l,"forEach");for(var n,r=u(t,arguments.length>1?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(this,t)}}),v&&e(l.prototype,"size",{get:function(){return f(this[d])}}),l},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=p(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){s(t,n,function(t,n){this._t=t,this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?l(0,r.k):"values"==n?l(0,r.v):l(0,[r.k,r.v]):(t._t=void 0,l(1))},r?"entries":"values",!r,!0),h(n)}}},function(t,n,r){var e=r(114),i=r(161);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var e=r(73),i=r(65).getWeak,o=r(2),u=r(6),c=r(68),f=r(79),a=r(48),s=r(24),l=a(5),h=a(6),v=0,p=function(t){return t._l||(t._l=new d)},d=function(){this.a=[]},y=function(t,n){return l(t.a,function(t){return t[0]===n})};d.prototype={get:function(t){var n=y(this,t);if(n)return n[1]},has:function(t){return!!y(this,t)},set:function(t,n){var r=y(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=h(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,o){var a=t(function(t,e){c(t,a,n,"_i"),t._i=v++,t._l=void 0,void 0!=e&&f(e,r,t[o],t)});return e(a.prototype,{delete:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).delete(t):n&&s(n,this._i)&&delete n[this._i]},has:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).has(t):n&&s(n,this._i)}}),a},def:function(t,n,r){var e=i(o(n),!0);return!0===e?p(t).set(n,r):e[t._i]=r,t},ufstore:p}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(132)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(6),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var e=r(2);t.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n,r){"use strict";var e=r(72),i=r(125),o=r(116),u=r(17),c=r(115),f=Object.assign;t.exports=!f||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=f({},t)[r]||Object.keys(f({},n)).join("")!=e})?function(t,n){for(var r=u(t),f=arguments.length,a=1,s=i.f,l=o.f;f>a;)for(var h,v=c(arguments[a++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:f},function(t,n,r){var e=r(11),i=r(2),o=r(72);t.exports=r(10)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(30),i=r(71).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(24),i=r(30),o=r(117)(!1),u=r(145)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){var e=r(72),i=r(30),o=r(116).f;t.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),f=c.length,a=0,s=[];f>a;)o.call(u,r=c[a++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(71),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(150)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(150),u=/^[\-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(16),i=r(149),o=r(46);t.exports=function(t,n,r,u){var c=String(o(t)),f=c.length,a=void 0===r?" ":String(r),s=e(n);if(s<=f||""==a)return c;var l=s-f,h=i.call(a,Math.ceil(l/a.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Map",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(this,t);return n&&n.v},set:function(t,n){return e.def(this,0===t?0:t,n)}},e,!0)},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var e,i=r(48)(0),o=r(28),u=r(65),c=r(172),f=r(166),a=r(6),s=u.getWeak,l=Object.isExtensible,h=f.ufstore,v={},p=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},d={get:function(t){if(a(t)){var n=s(t);return!0===n?h(this).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(this,t,n)}},y=t.exports=r(118)("WeakMap",p,d,f,!0,!0);7!=(new y).set((Object.freeze||Object)(v),7).get(v)&&(e=f.getConstructor(p),c(e.prototype,d),u.NEED=!0,i(["delete","has","get","set"],function(t){var n=y.prototype,r=n[t];o(n,t,function(n,i){if(a(n)&&!l(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return"set"==t?this:o}return r.call(this,n,i)})}))},,,,function(t,n){"use strict";function r(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")})}if(yiliaConfig&&yiliaConfig.toc_hide_index){document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}t.exports={init:r}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n){var r=/\/|index.html/g;return t.replace(r,"")===n.replace(r,"")}function o(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var o=t[r];i(n,o.getAttribute("href"))&&(0,h.default)(o,"active")}}function u(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}function c(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}function f(t,n,r,e,i){var o=u(t),f=c(t)-n;if(f-r<=i){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,d.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(r||f)+"px",a.style.left=o+"px",a.style.zIndex=e||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=r(156),h=e(l),v=r(157),p=(e(v),r(382)),d=e(p),y=r(128),g=e(y),b=r(190),m=e(b),x=r(129);(function(){g.default.versions.mobile&&window.screen.width<800&&(o(),s())})(),(0,x.addLoadEvent)(function(){m.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(r(381),r(391),r(198),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;var e="defineProperty";n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},,,function(t,n,r){r(210),t.exports=r(52).RegExp.escape},,,,function(t,n,r){var e=r(6),i=r(138),o=r(7)("species");t.exports=function(t){var n;return i(t)&&(n=t.constructor,"function"!=typeof n||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){var e=r(202);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(2),i=r(50),o="number";t.exports=function(t){if("string"!==t&&t!==o&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),t!=o)}},function(t,n,r){var e=r(72),i=r(125),o=r(116);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){var e=r(72),i=r(30);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){"use strict";var e=r(208),i=r(121),o=r(26);t.exports=function(){for(var t=o(this),n=arguments.length,r=Array(n),u=0,c=e._,f=!1;n>u;)(r[u]=arguments[u++])===c&&(f=!0);return function(){var e,o=this,u=arguments.length,a=0,s=0;if(!f&&!u)return i(t,r,o);if(e=r.slice(),f)for(;n>a;a++)e[a]===c&&(e[a]=arguments[s++]);for(;u>s;)e.push(arguments[s++]);return i(t,e,o)}}},function(t,n,r){t.exports=r(3)},function(t,n){t.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},function(t,n,r){var e=r(1),i=r(209)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(160)}),r(78)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(130)}),r(78)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(53),i=r(1),o=r(17),u=r(169),c=r(137),f=r(16),a=r(131),s=r(154);i(i.S+i.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,i,l,h=o(t),v="function"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,b=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==b||v==Array&&c(b))for(n=f(h.length),r=new v(n);n>g;g++)a(r,g,y?d(h[g],g):h[g]);else for(l=b.call(h),r=new v;!(i=l.next()).done;g++)a(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(138)})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=r(67),u=r(16),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(131);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(135),o=r(45),u=r(75),c=r(16),f=[].slice;e(e.P+e.F*r(4)(function(){i&&f.call(i)}),"Array",{slice:function(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,"Array"==e)return f.call(this,t,n);for(var i=u(t,r),a=u(n,r),s=c(a-i),l=Array(s),h=0;h<s;h++)l[h]="String"==e?this.charAt(i+h):this[i+h];return l}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(26),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(74)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=Date.prototype.getTime,u=function(t){return t>9?t:"0"+t};e(e.P+e.F*(i(function(){return"0385-07-25T07:06:39.999Z"!=new Date(-5e13-1).toISOString()})||!i(function(){new Date(NaN).toISOString()})),"Date",{toISOString:function(){
if(!isFinite(o.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":n>9999?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(r>99?r:"0"+u(r))+"Z"}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(27)(i,e,r(204))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(28)(e,o,function(){var t=c.call(this);return t===t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(163)})},function(t,n,r){"use strict";var e=r(6),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=r(66),o=r(24),u=Function.prototype,c="name",f=Object.isExtensible||function(){return!0};c in u||r(10)&&e(u,c,{configurable:!0,get:function(){try{var t=this,n=(""+t).match(/^\s*function ([^ (]*)/)[1];return o(t,c)||!f(t)||e(t,c,i(5,n)),n}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(171),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var i=r(1),o=Math.asinh;i(i.S+i.F*!(o&&1/o(0)>0),"Math",{asinh:e})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(142);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(141);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1),i=r(142),o=Math.pow,u=o(2,-52),c=o(2,-23),f=o(2,127)*(2-c),a=o(2,-126),s=function(t){return t+1/u-1/u};e(e.S,"Math",{fround:function(t){var n,r,e=Math.abs(t),o=i(t);return e<a?o*s(e/a/c)*a*c:(n=(1+c/u)*e,r=n-(n-e),r>f||r!=r?o*(1/0):o*r)}})},function(t,n,r){var e=r(1),i=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,o=0,u=0,c=arguments.length,f=0;u<c;)r=i(arguments[u++]),f<r?(e=f/r,o=o*e*e+1,f=r):r>0?(e=r/f,o+=e*e):o+=r;return f===1/0?1/0:f*Math.sqrt(o)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)/Math.LN10}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(171)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(142)})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(45),u=r(136),c=r(50),f=r(4),a=r(71).f,s=r(31).f,l=r(11).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(70)(y))==v,b="trim"in String.prototype,m=function(t){var n=c(t,!1);if("string"==typeof n&&n.length>2){n=b?n.trim():h(n,3);var r,e,i,o=n.charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,f=n.slice(2),a=0,s=f.length;a<s;a++)if((u=f.charCodeAt(a))<48||u>i)return NaN;return parseInt(f,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?f(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(m(n)),r,p):m(n)};for(var x,w=r(10)?a(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),S=0;w.length>S;S++)i(d,x=w[S])&&!i(p,x)&&l(p,x,s(d,x));p.prototype=y,y.constructor=p,r(28)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(168)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(168),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(178);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),i=r(67),o=r(159),u=r(149),c=1..toFixed,f=Math.floor,a=[0,0,0,0,0,0],s="Number.toFixed: incorrect invocation!",l="0",h=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*a[r],a[r]=e%1e7,e=f(e/1e7)},v=function(t){for(var n=6,r=0;--n>=0;)r+=a[n],a[n]=f(r/t),r=r%t*1e7},p=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==a[t]){var r=String(a[t]);n=""===n?r:n+u.call(l,7-r.length)+r}return n},d=function(t,n,r){return 0===n?r:n%2==1?d(t,n-1,r*t):d(t*t,n/2,r)},y=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){c.call({})})),"Number",{toFixed:function(t){var n,r,e,c,f=o(this,s),a=i(t),g="",b=l;if(a<0||a>20)throw RangeError(s);if(f!=f)return"NaN";if(f<=-1e21||f>=1e21)return String(f);if(f<0&&(g="-",f=-f),f>1e-21)if(n=y(f*d(2,69,1))-69,r=n<0?f*d(2,-n,1):f/d(2,n,1),r*=4503599627370496,(n=52-n)>0){for(h(0,r),e=a;e>=7;)h(1e7,0),e-=7;for(h(d(10,e,1),0),e=n-1;e>=23;)v(1<<23),e-=23;v(1<<e),h(1,1),v(2),b=p()}else h(0,r),h(1<<-n,0),b=p()+u.call(l,a);return a>0?(c=b.length,b=g+(c<=a?"0."+u.call(l,a-c)+b:b.slice(0,c-a)+"."+b.slice(c-a))):b=g+b,b}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(159),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(70)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(173)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("freeze",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(30),i=r(31).f;r(49)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(49)("getOwnPropertyNames",function(){return r(174).f})},function(t,n,r){var e=r(17),i=r(32);r(49)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6);r(49)("isExtensible",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(6);r(49)("isFrozen",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(6);r(49)("isSealed",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(180)})},function(t,n,r){var e=r(17),i=r(72);r(49)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("preventExtensions",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("seal",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(144).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(28)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(178);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u=r(69),c=r(3),f=r(53),a=r(114),s=r(1),l=r(6),h=r(26),v=r(68),p=r(79),d=r(146),y=r(151).set,g=r(143)(),b="Promise",m=c.TypeError,x=c.process,w=c[b],x=c.process,S="process"==a(x),_=function(){},O=!!function(){try{var t=w.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(_,_)};return(S||"function"==typeof PromiseRejectionEvent)&&t.then(_)instanceof n}catch(t){}}(),E=function(t,n){return t===n||t===w&&n===o},P=function(t){var n;return!(!l(t)||"function"!=typeof(n=t.then))&&n},j=function(t){return E(w,t)?new F(t):new i(t)},F=i=function(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw m("Bad Promise constructor");n=t,r=e}),this.resolve=h(n),this.reject=h(r)},M=function(t){try{t()}catch(t){return{error:t}}},A=function(t,n){if(!t._n){t._n=!0;var r=t._c;g(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,f=n.reject,a=n.domain;try{u?(i||(2==t._h&&I(t),t._h=1),!0===u?r=e:(a&&a.enter(),r=u(e),a&&a.exit()),r===n.promise?f(m("Promise-chain cycle")):(o=P(r))?o.call(r,c,f):c(r)):f(e)}catch(t){f(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){y.call(c,function(){var n,r,e,i=t._v;if(T(t)&&(n=M(function(){S?x.emit("unhandledRejection",i,t):(r=c.onunhandledrejection)?r({promise:t,reason:i}):(e=c.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=S||T(t)?2:1),t._a=void 0,n)throw n.error})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!T(n.promise))return!1;return!0},I=function(t){y.call(c,function(){var n;S?x.emit("rejectionHandled",t):(n=c.onrejectionhandled)&&n({promise:t,reason:t._v})})},k=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),A(n,!0))},L=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw m("Promise can't be resolved itself");(n=P(t))?g(function(){var e={_w:r,_d:!1};try{n.call(t,f(L,e,1),f(k,e,1))}catch(t){k.call(e,t)}}):(r._v=t,r._s=1,A(r,!1))}catch(t){k.call({_w:r,_d:!1},t)}}};O||(w=function(t){v(this,w,b,"_h"),h(t),e.call(this);try{t(f(L,this,1),f(k,this,1))}catch(t){k.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(73)(w.prototype,{then:function(t,n){var r=j(d(this,w));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=S?x.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&A(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),F=function(){var t=new e;this.promise=t,this.resolve=f(L,t,1),this.reject=f(k,t,1)}),s(s.G+s.W+s.F*!O,{Promise:w}),r(81)(w,b),r(74)(b),o=r(52)[b],s(s.S+s.F*!O,b,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),s(s.S+s.F*(u||!O),b,{resolve:function(t){if(t instanceof w&&E(t.constructor,this))return t;var n=j(this);return(0,n.resolve)(t),n.promise}}),s(s.S+s.F*!(O&&r(123)(function(t){w.all(t).catch(_)})),b,{all:function(t){var n=this,r=j(n),e=r.resolve,i=r.reject,o=M(function(){var r=[],o=0,u=1;p(t,!1,function(t){var c=o++,f=!1;r.push(void 0),u++,n.resolve(t).then(function(t){f||(f=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o&&i(o.error),r.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=M(function(){p(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i&&e(i.error),r.promise}})},function(t,n,r){var e=r(1),i=r(26),o=r(2),u=(r(3).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(4)(function(){u(function(){})}),"Reflect",{apply:function(t,n,r){var e=i(t),f=o(r);return u?u(e,n,f):c.call(e,n,f)}})},function(t,n,r){var e=r(1),i=r(70),o=r(26),u=r(2),c=r(6),f=r(4),a=r(163),s=(r(3).Reflect||{}).construct,l=f(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!f(function(){s(function(){})});e(e.S+e.F*(l||h),"Reflect",{construct:function(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(a.apply(t,e))}var f=r.prototype,v=i(c(f)?f:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(50);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(139)(o,"Object",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return a(t)===s?t[n]:(r=i.f(t,n))?u(r,"value")?r.value:void 0!==r.get?r.get.call(s):void 0:f(c=o(t))?e(c,n,s):void 0}var i=r(31),o=r(32),u=r(24),c=r(1),f=r(6),a=r(2);c(c.S,"Reflect",{get:e})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(177)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(144);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var f,h,v=arguments.length<4?t:arguments[3],p=o.f(s(t),n);if(!p){if(l(h=u(t)))return e(h,n,r,v);p=a(0)}return c(p,"value")?!(!1===p.writable||!l(v)||(f=o.f(v,n)||a(0),f.value=r,i.f(v,n,f),0)):void 0!==p.set&&(p.set.call(v,r),!0)}var i=r(11),o=r(31),u=r(32),c=r(24),f=r(1),a=r(66),s=r(2),l=r(6);f(f.S,"Reflect",{set:e})},function(t,n,r){var e=r(3),i=r(136),o=r(11).f,u=r(71).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),o=void 0===n;return!r&&e&&t.constructor===a&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&o?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(t){t in a||o(a,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=a,a.prototype=l,r(28)(e,"RegExp",a)}r(74)("RegExp")},function(t,n,r){r(119)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("replace",2,function(t,n,r){return[function(e,i){"use strict";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},function(t,n,r){r(119)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("split",2,function(t,n,e){"use strict";var i=r(122),o=e,u=[].push,c="split",f="length",a="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[f]||2!="ab"[c](/(?:ab)*/)[f]||4!="."[c](/(.?)(.?)/)[f]||"."[c](/()()/)[f]>1||""[c](/.?/)[f]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],d=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),y=0,g=void 0===n?4294967295:n>>>0,b=new RegExp(t.source,d+"g");for(s||(e=new RegExp("^"+b.source+"$(?!\\s)",d));(c=b.exec(r))&&!((l=c.index+c[0][f])>y&&(p.push(r.slice(y,c.index)),!s&&c[f]>1&&c[0].replace(e,function(){for(v=1;v<arguments[f]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[f]>1&&c.index<r[f]&&u.apply(p,c.slice(1)),h=c[0][f],y=l,p[f]>=g));)b[a]===c.index&&b[a]++;return y===r[f]?!h&&b.test("")||p.push(""):p.push(r.slice(y)),p[f]>g?p.slice(0,g):p}}else"0"[c](void 0,0)[f]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(r,i){var o=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,o,i):e.call(String(o),r,i)},e]})},function(t,n,r){"use strict";r(184);var e=r(2),i=r(120),o=r(10),u="toString",c=/./[u],f=function(t){r(28)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(29)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},function(t,n,r){"use strict";r(29)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(29)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(29)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="endsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{endsWith:function(t){var n=o(this,t,u),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),f=void 0===r?e:Math.min(i(r),e),a=String(t);return c?c.call(n,a,f):n.slice(f-a.length,f)===a}})},function(t,n,r){"use strict";r(29)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(29)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},function(t,n,r){"use strict";r(29)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},function(t,n,r){var e=r(1),i=r(75),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(148),o="includes";e(e.P+e.F*r(134)(o),"String",{includes:function(t){return!!~i(this,t,o).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(29)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(147)(!0);r(140)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(29)("link",function(t){return function(n){return t(this,"a","href",n)}})},function(t,n,r){var e=r(1),i=r(30),o=r(16);e(e.S,"String",{raw:function(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(149)})},function(t,n,r){"use strict";r(29)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="startsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(29)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(29)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(29)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(10),u=r(1),c=r(28),f=r(65).KEY,a=r(4),s=r(126),l=r(81),h=r(76),v=r(7),p=r(182),d=r(153),y=r(206),g=r(205),b=r(138),m=r(2),x=r(30),w=r(50),S=r(66),_=r(70),O=r(174),E=r(31),P=r(11),j=r(72),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(71).f=O.f=Z,r(116).f=X,r(125).f=tt,o&&!r(69)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(27)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(127),o=r(152),u=r(2),c=r(75),f=r(16),a=r(6),s=r(3).ArrayBuffer,l=r(146),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return p&&p(t)||a(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new h(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(f(i-e)),a=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,a.getUint8(e++));return o}}),r(74)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(127).ABV,{DataView:r(152).DataView})},function(t,n,r){r(55)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){"use strict";var e=r(166);r(118)("WeakSet",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)("includes")},function(t,n,r){var e=r(1),i=r(143)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(165)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o+(e>>>0)+((i&u|(i|u)&~(i+u>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,f=i>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>16)+((o*f>>>0)+(a&r)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o-(e>>>0)-((~i&u|~(i^u)&i-u>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,f=i>>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>>16)+((o*f>>>0)+(a&r)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(176)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),i=r(177),o=r(30),u=r(31),c=r(131);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r=o(t),e=u.f,f=i(r),a={},s=0;f.length>s;)c(a,n=f[s++],e(r,n));return a}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(176)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),i=r(3),o=r(52),u=r(143)(),c=r(7)("observable"),f=r(26),a=r(2),s=r(68),l=r(73),h=r(27),v=r(79),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},m=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};m.prototype=l({},{unsubscribe:function(){b(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var w=function(t){s(this,w,"Observable","_f")._f=f(t)};l(w.prototype,{subscribe:function(t){return new m(t,this._f)},forEach:function(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){f(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(w,{from:function(t){var n="function"==typeof this?this:w,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new("function"==typeof this?this:w)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(w.prototype,c,function(){return this}),e(e.G,{Observable:w}),r(74)("Observable")},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var f=c.get(n);return f.delete(r),!!f.size||c.delete(n)}})},function(t,n,r){var e=r(185),i=r(161),o=r(54),u=r(2),c=r(32),f=o.keys,a=o.key,s=function(t,n){var r=f(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function(t){return s(u(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){
return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(26),u=e.key,c=e.set;e.exp({metadata:function(t,n){return function(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(165)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(16),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(139)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padEnd:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padStart:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(153)("asyncIterator")},function(t,n,r){r(153)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){for(var e=r(155),i=r(28),o=r(3),u=r(27),c=r(80),f=r(7),a=f("iterator"),s=f("toStringTag"),l=c.Array,h=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],v=0;v<5;v++){var p,d=h[v],y=o[d],g=y&&y.prototype;if(g){g[a]||u(g,a,l),g[s]||u(g,s,d),c[d]=l;for(p in e)g[p]||i(g,p,e[p],!0)}}},function(t,n,r){var e=r(1),i=r(151);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(121),u=r(207),c=e.navigator,f=!!c&&/MSIE .\./.test(c.userAgent),a=function(t){return f?function(n,r){return t(o(u,[].slice.call(arguments,2),"function"==typeof n?n:Function(n)),r)}:t};i(i.G+i.B+i.F*f,{setTimeout:a(e.setTimeout),setInterval:a(e.setInterval)})},function(t,n,r){r(330),r(269),r(271),r(270),r(273),r(275),r(280),r(274),r(272),r(282),r(281),r(277),r(278),r(276),r(268),r(279),r(283),r(284),r(236),r(238),r(237),r(286),r(285),r(256),r(266),r(267),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(239),r(240),r(241),r(242),r(243),r(244),r(245),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(317),r(322),r(329),r(320),r(312),r(313),r(318),r(323),r(325),r(308),r(309),r(310),r(311),r(314),r(315),r(316),r(319),r(321),r(324),r(326),r(327),r(328),r(231),r(233),r(232),r(235),r(234),r(220),r(218),r(224),r(221),r(227),r(229),r(217),r(223),r(214),r(228),r(212),r(226),r(225),r(219),r(222),r(211),r(213),r(216),r(215),r(230),r(155),r(302),r(307),r(184),r(303),r(304),r(305),r(306),r(287),r(183),r(185),r(186),r(342),r(331),r(332),r(337),r(340),r(341),r(335),r(338),r(336),r(339),r(333),r(334),r(288),r(289),r(290),r(291),r(292),r(295),r(293),r(294),r(296),r(297),r(298),r(299),r(301),r(300),r(343),r(369),r(372),r(371),r(373),r(374),r(370),r(375),r(376),r(354),r(357),r(353),r(351),r(352),r(355),r(356),r(346),r(368),r(377),r(345),r(347),r(349),r(348),r(350),r(359),r(360),r(362),r(361),r(364),r(363),r(365),r(366),r(367),r(344),r(358),r(380),r(379),r(378),t.exports=r(52)},function(t,n){function r(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}t.exports=r},,,,,,,,,function(t,n,r){(function(n,r){!function(n){"use strict";function e(t,n,r,e){var i=n&&n.prototype instanceof o?n:o,u=Object.create(i.prototype),c=new p(e||[]);return u._invoke=s(t,r,c),u}function i(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function o(){}function u(){}function c(){}function f(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function a(t){function n(r,e,o,u){var c=i(t[r],t,e);if("throw"!==c.type){var f=c.arg,a=f.value;return a&&"object"==typeof a&&m.call(a,"__await")?Promise.resolve(a.__await).then(function(t){n("next",t,o,u)},function(t){n("throw",t,o,u)}):Promise.resolve(a).then(function(t){f.value=t,o(f)},u)}u(c.arg)}function e(t,r){function e(){return new Promise(function(e,i){n(t,r,e,i)})}return o=o?o.then(e,e):e()}"object"==typeof r&&r.domain&&(n=r.domain.bind(n));var o;this._invoke=e}function s(t,n,r){var e=P;return function(o,u){if(e===F)throw new Error("Generator is already running");if(e===M){if("throw"===o)throw u;return y()}for(r.method=o,r.arg=u;;){var c=r.delegate;if(c){var f=l(c,r);if(f){if(f===A)continue;return f}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(e===P)throw e=M,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);e=F;var a=i(t,n,r);if("normal"===a.type){if(e=r.done?M:j,a.arg===A)continue;return{value:a.arg,done:r.done}}"throw"===a.type&&(e=M,r.method="throw",r.arg=a.arg)}}}function l(t,n){var r=t.iterator[n.method];if(r===g){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=g,l(t,n),"throw"===n.method))return A;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return A}var e=i(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,A;var o=e.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=g),n.delegate=null,A):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,A)}function h(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function v(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(h,this),this.reset(!0)}function d(t){if(t){var n=t[w];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=g,n.done=!0,n};return e.next=e}}return{next:y}}function y(){return{value:g,done:!0}}var g,b=Object.prototype,m=b.hasOwnProperty,x="function"==typeof Symbol?Symbol:{},w=x.iterator||"@@iterator",S=x.asyncIterator||"@@asyncIterator",_=x.toStringTag||"@@toStringTag",O="object"==typeof t,E=n.regeneratorRuntime;if(E)return void(O&&(t.exports=E));E=n.regeneratorRuntime=O?t.exports:{},E.wrap=e;var P="suspendedStart",j="suspendedYield",F="executing",M="completed",A={},N={};N[w]=function(){return this};var T=Object.getPrototypeOf,I=T&&T(T(d([])));I&&I!==b&&m.call(I,w)&&(N=I);var k=c.prototype=o.prototype=Object.create(N);u.prototype=k.constructor=c,c.constructor=u,c[_]=u.displayName="GeneratorFunction",E.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===u||"GeneratorFunction"===(n.displayName||n.name))},E.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,c):(t.__proto__=c,_ in t||(t[_]="GeneratorFunction")),t.prototype=Object.create(k),t},E.awrap=function(t){return{__await:t}},f(a.prototype),a.prototype[S]=function(){return this},E.AsyncIterator=a,E.async=function(t,n,r,i){var o=new a(e(t,n,r,i));return E.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},f(k),k[_]="Generator",k.toString=function(){return"[object Generator]"},E.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},E.values=d,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=g,this.done=!1,this.delegate=null,this.method="next",this.arg=g,this.tryEntries.forEach(v),!t)for(var n in this)"t"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=g)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,e&&(r.method="next",r.arg=g),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=m.call(i,"catchLoc"),c=m.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,A):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),A},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),v(r),A}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;v(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:d(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=g),A}}}("object"==typeof n?n:"object"==typeof window?window:"object"==typeof self?self:this)}).call(n,function(){return this}(),r(158))}])</script><script src="/./main.0cf68a.js"></script><script>!function(){!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/slider.e37972.js")}()</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 50%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 50%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">数据结构与算法</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">JavaScript</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很开心能认识你</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>